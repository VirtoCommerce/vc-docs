{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"For new usersFor current Storefront and Theme users <p>Virto Commerce Frontend is a single-page web application (SPA) with a fresh look on ecommerce solutions. This is where common B2B and B2C scenarios are combined with the most bleeding-edge technologies to deliver blazing-fast and fully functional solutions. It implements common business use cases needed for a vast majority of projects we build.</p> <p>Virto Commerce Frontend is designed to be used as-is within the actual Virto Commerce Platform. You can modify it by implementing desired components, pages, and shared logic to correspond with your project goals.</p> <p>Deploy Frontend Application</p> <p>As of July 2024, Virto Commerce Storefront and Theme have been replaced with the Frontend Application. </p> <p>Note</p> <p>Current users now have the following options:</p> <ol> <li>Migrate to the new storefrontless architecture on your own or with our assistance.</li> <li>Continue using the Storefront with the 1.62 version, which will receive updates until the end of 2024. After that, while it will still be possible to use the Storefront, no further updates will be provided.</li> </ol> <p>The primary objective of the new Virto Commerce Frontend Architecture is to simplify and expedite the development of ecommerce solutions based on the Virto Commerce Platform. This architecture replaces the custom vc-storefront with a standard load balancer, such as nginx or Azure Load Balancer. All business logic previously handled by vc-storefront is now integrated into the Platform through xAPI modules. This change ensures that developing business logic for client applications is now consistent with platform development.</p> <p>Virto Commerce Frontend (B2B-Theme 2.x) is now a Single Page Application (SPA) stored in static resources. The load balancer is configured to route requests from the client machine to both static content and xAPI endpoints. Additionally, this architecture supports the integration and utilization of third-party SPA applications.</p> <p></p> <p></p>"},{"location":"#technologies-used","title":"Technologies used","text":"<ul> <li> <p>Vue3: Progressive frontend framework with its key features allowing one to build fast applications.</p> </li> <li> <p>TypeScript: All components and composables have type definitions, so that IDE could help you build clean and working code.</p> </li> <li> <p>TailwindCSS: The most popular and growing CSS framework providing wonderful flexible structure to speed up styling.</p> </li> <li> <p>Husky + ESLint + Prettier: Autoformat, check, and fix your code and prevent ugly code style within repository.</p> </li> <li> <p>Vite: Faster than Webpack, it is used to develop code with HMR benefits and build for production.</p> </li> <li> <p>GraphQL : Use flexible GraphQL queries and mutations to safely work with back end.</p> </li> </ul>"},{"location":"#key-non-functional-features","title":"Key non-functional features","text":"<ul> <li> <p>Development performance: Achieve rapid development using the most effective solution. Deploy the SPA in seconds and start modifying code with HMR features.</p> </li> <li> <p>Client performance: Reach and maintain high performance metrics as provided by Google PageSpeed Insights.</p> </li> <li> <p>Atomic design pattern: Base the UI on Atoms, Molecules, and Organisms, combined within Pages and shared Components for high code reusability.</p> </li> <li> <p>Fully responsive: Ensure the application works seamlessly on multiple devices, from desktops to mobile phones, providing an excellent UI and UX.</p> </li> <li> <p>Simple styling and customization: Use TailwindCSS for straightforward and convenient CSS usage, minimizing code and leveraging a highly customizable framework.</p> </li> <li> <p>Fully aligned with Virto Commerce Platform: Integrate the SPA with the Virto Commerce Platform to support all common B2B and B2C scenarios.</p> </li> </ul>"},{"location":"#application-structure","title":"Application structure","text":"<pre><code>\u251c\u2500\u2500 assets                           // Scripts, styles and other assets compiled and minified for production.\n|\n\u251c\u2500\u2500 client-app                       // The main folder for the application.\n|   \u251c\u2500\u2500 assets                       // Assets needed to be precompiled during building.\n|   |   \u2514\u2500\u2500...\n|   |\n|   \u251c\u2500\u2500 core                          // Common utilities and shared logic that can be used by any pages and libraries.\n|   |   \u251c\u2500\u2500 api/graphql               // GraphQL Models aligned with the Virto Backoffice.\n|   |   |   \u2514\u2500\u2500...\n|   |   \u251c\u2500\u2500 composables               // Core composables (app-level shared logic).\n|   |   |   \u2514\u2500\u2500...\n|   |   \u251c\u2500\u2500 directives                // Core Vue directives.\n|   |   |   \u2514\u2500\u2500...\n|   |   \u251c\u2500\u2500 plugins                   // Core Vue plugins.\n|   |   |   \u2514\u2500\u2500...\n|   |   \u251c\u2500\u2500 enums                     // Core enums.\n|   |   |   \u2514\u2500\u2500...\n|   |   \u251c\u2500\u2500 types                     // Core types.\n|   |   |   \u2514\u2500\u2500...\n|   |   \u251c\u2500\u2500 utilities                 // Some miscellaneous utils.\n|   |   |   \u2514\u2500\u2500...\n|   |   \u2514\u2500\u2500 constants.ts              // Global-available constants (DO NOT USE, will be removed later).\n|   |\n|   \u251c\u2500\u2500 pages                         // Set of application pages used within Application router.\n|   |   \u2514\u2500\u2500...\n|   |\n|   \u251c\u2500\u2500 public                        // Statically served files.\n|   |   \u2514\u2500\u2500 static \n|   |       \u251c\u2500\u2500 icons                 // Icons used for favicons, PWA, etc.\n|   |       \u2514\u2500\u2500 images                // Static images used inside the application.\n|   |\n|   \u251c\u2500\u2500 router                        // SPA routing configuration.\n|   |   \u2514\u2500\u2500...\n|   |\n|   \u251c\u2500\u2500 shared                        // A set of shared files grouped by their domain context.\n|   |   \u251c\u2500\u2500 catalog                   // Grouping context (ex.: catalog browsing).\n|   |   |   \u251c\u2500\u2500 components            // The collection of components specific for this domain context.\n|   |   |   |   \u2514\u2500\u2500...\n|   |   |   \u251c\u2500\u2500 composables           // The collection of shared logic written using Composable API pattern.\n|   |   |   |   \u2514\u2500\u2500...\n|   |   |   \u251c\u2500\u2500 types                 // Types used in this context.\n|   |   |   |   \u2514\u2500\u2500...\n|   |   |   \u251c\u2500\u2500 utils                 // Utilities and helpers specific for this context.\n|   |   |   |   \u2514\u2500\u2500...\n|   |   |   \u2514\u2500\u2500 index.ts              // Entry point for this context used as library.\n|   |   |\n|   |   \u2514\u2500\u2500...\n|   |\n|   \u251c\u2500\u2500 ui-kit                        // Atoms, Molecules, Organisms and their types, used within the whole application.\n|   |   \u2514\u2500\u2500...\n|   |\n|   \u251c\u2500\u2500 App.vue                       // Main Application component. Use it as a wrapper for routable pages.\n|   \u251c\u2500\u2500 env.d.ts                      // Definition file to provide IDE IntelliSense support.\n|   \u251c\u2500\u2500 main.ts                       // Application entry point. Main initialization script.\n|   \u251c\u2500\u2500 shims-acceptjs.d.ts           // Definition file to provide IDE IntelliSense support for Accept.js (Authorize.net).\n|   \u251c\u2500\u2500 shims-graphql.d.ts            // Definition file to provide IDE IntelliSense support for importing *.graphql files.\n|   \u251c\u2500\u2500 shims-vue.d.ts                // Definition file to provide IDE IntelliSense support for importing *.vue files.\n|   \u251c\u2500\u2500 vue.d.ts                      // Definition file to provide IDE IntelliSense support for additional global Vue properties.\n|   \u2514\u2500\u2500 vue-router.d.ts               // Definition file to provide IDE IntelliSense support for additional global Vue Router properties.\n|\n\u251c\u2500\u2500 config\n|   \u251c\u2500\u2500 menu.json\n|   \u2514\u2500\u2500 settings_data.json\n|   \n\u251c\u2500\u2500 examples                          // Code snippets and examples for different use cases.\n|   \u2514\u2500\u2500...\n|   \n\u251c\u2500\u2500 locales                           // Locale files used to provide translated content.\n|   \u2514\u2500\u2500...\n|\n\u251c\u2500\u2500 modules                           // Auxiliary build files that run in the Node environment.\n|   \u2514\u2500\u2500...                            // Modules with their own components, APIs, and logic.\n|\n\u251c\u2500\u2500 scripts                           // Auxiliary build files that run in the Node environment.\n|   \u2514\u2500\u2500...\n|\n\u251c\u2500\u2500 .babelrc                          // Babel configuration for storybook.\n\u251c\u2500\u2500 .browserslistrc                   // Browserslist config file to support actual versions of browsers.\n\u251c\u2500\u2500 .commitlintrc.json                // Config for Conventional commit hook.\n\u251c\u2500\u2500 .dependency-cruiser.cjs\n\u251c\u2500\u2500 .dependency-graph.cjs\n\u251c\u2500\u2500 .editorconfig                     // Common editor settings to sync codestyle.\n\u251c\u2500\u2500 .env                              // Envfile to define different Environment Variables.\n\u251c\u2500\u2500 .env.local                        // Local envfile to override Environment Variables.\n\u251c\u2500\u2500 .eslintignore                     // Ignore some files from ESlint.\n\u251c\u2500\u2500 .eslintrc.cjs                     // ESlint configuration file.\n\u251c\u2500\u2500 .gitattributes                    // Set attributes to specified path in Git.\n\u251c\u2500\u2500 .gitignore                        // Ignore some files from Git.\n\u251c\u2500\u2500 .npmrc                            // Node.js package manager settings and Node.js restrictions.\n\u251c\u2500\u2500 .prettierignore                   // Ignore some files from Prettier.\n\u251c\u2500\u2500 .prettierrc.json                  // Config for Prettier.\n\u251c\u2500\u2500 .yarnrc.yml                       // Yarn package manager configuration.\n\u251c\u2500\u2500 graphql-codegen\n|   \u2514\u2500\u2500 generator.ts                  // Generate GraphQL types. \n\u251c\u2500\u2500 index.html                        // Vite Development entry point.\n\u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 package.json                      // NPM Package description.\n\u251c\u2500\u2500 postcss.config.cjs                // PostCSS configuration for Tailwind.\n\u251c\u2500\u2500 README.md                         // This file.\n\u251c\u2500\u2500 sonar-project.properties\n\u251c\u2500\u2500 tailwind.config.ts                // TailwindCSS configuration file.\n\u251c\u2500\u2500 tsconfig.app.json                 // Typescript configuration for application.\n\u251c\u2500\u2500 tsconfig.json                     // Main TypeScript configuration file.\n\u251c\u2500\u2500 tsconfig.node.json                // Typescript configuration for Node.js.\n\u251c\u2500\u2500 tsconfig.vitest.json\n\u251c\u2500\u2500 vite.config.ts                    // Vite configuration file.\n\u251c\u2500\u2500 vitest.config.ts \n\u2514\u2500\u2500 yarn.lock                         // Yarn dependencies lock file.\n</code></pre>"},{"location":"#key-functionalities","title":"Key functionalities","text":"<p>The key functionalities include:</p> <ul> <li>Registration and signing in.</li> <li>Password management.</li> <li>Managing personal and corporate accounts.</li> <li>Managing quote requests.</li> <li>Managing lists.</li> <li>Access assignment.</li> <li>Product comparison.</li> <li>Bulk orders.</li> <li>Intuitive navigation.</li> <li>Buying digital and physical products. </li> <li>Searching and filtering products.</li> <li>Managing push messages.</li> <li>Reviewing products.</li> </ul> <p> </p> Architecture \u2192"},{"location":"architecture/","title":"Architecture","text":"<p>The simplified and accelerated Frontend Application architecture is as follows: </p> <p></p> <p>It includes: </p> <ul> <li>Client.</li> <li>Browser.</li> <li>Load balancer.</li> <li>Static Content Storage (Virto Commerce Frontend or any SPA application).</li> <li>Virto Commerce Platform (xAPI/GraphQL).</li> <li>CDN (optional, placed before the load balancer).</li> <li>Prerender.IO (optional for Server-Side Rendering).</li> </ul> <p>The workflow ensures a seamless and efficient operation of the Virto Commerce Frontend Application:</p> <ol> <li> <p>Client request:</p> <ul> <li>The client opens the frontend application in their browser.</li> <li>The browser sends a request to the load balancer to retrieve the index.html file.</li> </ul> </li> <li> <p>Load balancer routing:</p> <ul> <li>The load balancer is configured with specific routing rules to handle different types of requests efficiently:<ul> <li>API Requests: If the path matches an xAPI request or a token retrieval request, the load balancer routes the request to the Virto Commerce Platform API.</li> <li>Static Content Requests: If the request is for a file, the load balancer serves the static content directly. If the file is not found, a 404 error is returned.</li> <li>Folder Requests: If the request is for a folder, the load balancer serves the index.html file with a 200 response.</li> </ul> </li> </ul> </li> <li> <p>Single Page Application (SPA) loading:</p> <ul> <li>The Single Page Application (SPA) loads in the client\u2019s browser.</li> <li>The SPA handles both static and dynamic routing within the application.</li> </ul> </li> <li> <p>API interaction and content rendering:</p> <ul> <li>The SPA makes API requests to fetch necessary data.</li> <li>The page content is rendered based on the data received from the API.</li> </ul> </li> <li> <p>User interaction:</p> <ul> <li>Further interactions occur within the SPA context.</li> </ul> </li> <li> <p>Enhanced functionalities (optional):</p> <ul> <li>Additional functionalities can be configured through the IT infrastructure to enhance performance and security:<ul> <li>CDN Integration: Integrate with a Content Delivery Network (CDN) to serve static content faster and reduce server load.</li> <li>Firewall and DDoS Protection: Implement firewall rules and Distributed Denial of Service (DDoS) protection to secure the application.</li> <li>Server-Side Rendering (SSR): Configure SSR to improve SEO and initial load times by rendering pages on the server before sending them to the client.</li> </ul> </li> </ul> </li> </ol> <p> </p> \u2190 Overview Modules architecture \u2192"},{"location":"deployment/","title":"Deployment","text":"<p>This section provides detailed instructions on how to deploy the new Virto Commerce Frontend Application across various environments. The deployment options available are:</p> <ul> <li>Virto Cloud.</li> <li>Azure.</li> <li>Local machine.</li> </ul>"},{"location":"deployment/#deployment-on-virto-cloud","title":"Deployment on Virto Cloud","text":"<p>Virto Cloud natively supports the new architecture. Use the following methods to deploy in Virto Cloud:</p> <ul> <li>Through configuration files.</li> <li>Through Virto Cloud portal.</li> </ul>"},{"location":"deployment/#through-configuration-file","title":"Through configuration file","text":"<p>To deploy through configuration files:</p> <ol> <li>Disable the storefront application by removing it from the configuration.</li> <li>Add a reference to the Virto Commerce Frontend Application 2.x.</li> <li>Enable the routes section. The table below shows the mapping of paths to platform routes. The platform routes handle all requests related to the SPA's core functionality, such as authentication, authorization, file management, and data querying.</li> </ol> Path Description /xapi A custom API endpoint for interacting with the SPA's backend services. /files A path for uploading and downloading files from the SPA's storage. /connect/token A path for requesting and refreshing access tokens for the SPA's users. /graphql A path for executing GraphQL queries and mutations on the SPA's data. /revoke/token A path for revoking access tokens for the SPA's users. /api/files An alternative path for accessing the SPA's file management service. <p>These routes are integral to ensuring that the SPA operates smoothly and securely, handling everything from user authentication to complex data interactions.</p> <p>The appropriate snippet of the environments.yml file is as follows:</p> environments.yml<pre><code>storefront:\n    enabled: false\n    imageRepository: virtopaasregistrymain.azurecr.io/vcptcore/storefront\n    servicePlan: S1\n    imageTag: 6.37.0-master-628b3528\n    config:\n      DOTNET_USE_POLLING_FILE_WATCHER: true\n      ASPNETCORE_FORWARDEDHEADERS_ENABLED: true\n      CookieAuthenticationOptions__ExpireTimeSpan: 12:00:00\n      SnapshotCollectorConfiguration__IsEnabled: false\n      Swagger__UI__Enable: true\n      VirtoCommerce__DefaultStore: B2B-store\n      VirtoCommerce__Endpoint__Password: store\n    themes:\n          B2B-store: https://vc3prerelease.blob.core.windows.net/packages/b2b-webservice.zip\ningress: {}\ncustomApps:\n    app1:\n        enabled: false\n    app2:\n        enabled: false\nroutes:\n- host: vcptcore-dev-storefront.govirto.com\n    root: B2B-store\n    paths:\n    - path: /xapi\n        route: platform\n    - path: /files\n        route: platform\n    - path: /connect/token\n        route: platform\n    - path: /graphql\n        route: platform\n    - path: /revoke/token\n        route: platform\n    - path: /api/files\n        route: platform\nprotectedParameters:\n    - platform.image.tag\n    - storefront.image.tag\n    #- themes.B2B-store\n    #- custom.app1.image.tag\n</code></pre>"},{"location":"deployment/#through-virto-cloud-portal","title":"Through Virto Cloud portal","text":"<p>You can find detailed instructions here.</p>"},{"location":"deployment/#deployment-on-azure","title":"Deployment on Azure","text":"<p>To deploy the Frontend Application on Azure:</p> <ol> <li> <p>Create all Azure resources using the Azure button:</p> <p></p> </li> <li> <p>Fill in the required values on the Custom deployment page and create Azure resources:</p> <p></p> </li> <li> <p>After successful deployment, open the Platform and perform initial setup, installing sample data if necessary.</p> </li> <li>Change the default password for the admin user. </li> <li> <p>Set the store URL (Stores \u2192 Your store \u2192 Store URL) in the Platform in the form of <code>http://x.x.x.x/</code>:</p> <p></p> </li> <li> <p>Use the Azure Application Gateway IP address to access the Frontend part of Virtocommerce solutions.</p> </li> </ol> <p>Your Frontend App has now been successfully deployed on Azure.</p>"},{"location":"deployment/#common-deployment-issues","title":"Common deployment issues","text":"<p>During the deployment process, various issues can arise that require attention, including:</p> <ul> <li>Azure template validation issue.</li> <li>Password issue.</li> <li>Azure infrastructure issue.</li> </ul>"},{"location":"deployment/#azure-template-validation-issue","title":"Azure template validation issue","text":"<p>An Azure template validation error may occur if a resource with the selected name already exists. The error message typically indicates that the name must be modified before proceeding. </p> <p></p> <p>This issue can arise because the template uses the <code>App Service Name</code> parameter as a name for other Azure resources, potentially leading to conflicts.</p>"},{"location":"deployment/#password-issue","title":"Password issue","text":"<p>Errors may occur if the password entered in the <code>Sql Administrator Password</code> field does not meet complexity requirements. </p> <p></p> <p>To resolve this, the template must be redeployed with a new, compliant password.</p>"},{"location":"deployment/#azure-infrastructure-issue","title":"Azure infrastructure issue","text":"<p>The error occurs during the deployment process and has a self-explanatory description. </p> <p></p> <p>The problem is usually temporary and cannot be solved by the user. The workaround is to use a new resource group for the deployment.</p>"},{"location":"deployment/#deployment-on-local-machine","title":"Deployment on local machine","text":"<p>Deploying on a local machine includes:</p> <ol> <li>Meeting the prerequisites.</li> <li>Deploying the Frontend Application.</li> </ol>"},{"location":"deployment/#prerequisites","title":"Prerequisites","text":"<p>Before installing the Frontend Application:</p> <ol> <li>Install Platform latest version or connect to an instance of the platform that is already set up and running on a cloud service.</li> <li>Install Experience API/xAPI modules:<ul> <li>xAPI</li> <li>Profile Experience API</li> </ul> </li> <li> <p>Install the following modules for development (but not in production. This will be changed soon):</p> <ul> <li>File experience API</li> <li>Push messages</li> <li>Skyflow</li> <li>xRecommend</li> </ul> </li> <li> <p>Install Node.js v22 (22.10.0 or higher).</p> </li> <li>Enable corepack (run as administrator on Windows):</li> </ol> <pre><code>corepack enable\n</code></pre> <p>If you have installed <code>yarn</code> globally, uninstall it:</p> <ul> <li> <p>via <code>npm</code>:</p> <pre><code>npm uninstall --global yarn\n</code></pre> </li> <li> <p>or through your operation system installation tools:</p> <ul> <li>Control Panel, Chocolatey, or Scoop on Windows.</li> <li>Launchpad, Finder, Homebrew, or MacPorts on macOS.</li> <li>Native package manager such as apt on Linux.</li> </ul> </li> </ul>"},{"location":"deployment/#frontend-application-deployment","title":"Frontend Application deployment","text":"<p>To deploy the Frontend Application on a local machine:</p> <ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/VirtoCommerce/vc-frontend.git \"C:\\vc-frontend\\\"\n</code></pre> </li> <li> <p>Check <code>yarn</code> version. It should be 4.1.0 or higher (not 1.XX.):</p> <pre><code>yarn -v\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>yarn install\n</code></pre> </li> <li> <p>Build and run with hot reload for development:</p> <ol> <li>Add new .env.local file.</li> <li> <p>Copy APP_BACKEND_URL from the .env file and set its value to the correct endpoint to Virto Commerce Platform:</p> <pre><code># .env.local file\nAPP_BACKEND_URL=https://localhost:5001\n</code></pre> </li> <li> <p>Run <code>yarn dev</code> or <code>yarn dev-expose</code>:</p> <p></p> </li> <li> <p>Follow the link provided in the terminal.</p> </li> </ol> </li> </ol> <p>Your Frontend Application is now running successfully.</p> <p></p>"},{"location":"deployment/#build-options","title":"Build options","text":"<p>Choose the appropriate build command based on your needs:</p> <ul> <li> <p>Build for production with validation and minification:</p> <pre><code>yarn build\n</code></pre> </li> <li> <p>Build in development mode:</p> <pre><code>yarn build:dev\n</code></pre> </li> <li> <p>Build in development mode with change tracking:</p> <pre><code>yarn build:watch\n</code></pre> </li> </ul>"},{"location":"deployment/#types-generation","title":"Types generation","text":"<p>To keep your project aligned with the GraphQL server, you need to generate the necessary types by running the following command:</p> <pre><code>yarn generate:graphql\n</code></pre> <p>This command generates the types.ts file for the Core App and independent modules. Even if independent modules are not installed on the platform, the types can still be generated safely.</p>"},{"location":"deployment/#dependency-analysis","title":"Dependency analysis","text":"<p>The following sections guide you through analyzing bundle sizes and visualizing the dependency graph.</p>"},{"location":"deployment/#bundle-size-analysis","title":"Bundle size analysis","text":"<p>To optimize your application, it\u2019s important to understand the size of various JavaScript chunks like vendor.js and index.js. Run the following command to analyze bundle sizes:</p> <pre><code>yarn generate:bundle-map\n</code></pre> <p>The results will be saved in the artifacts folder, providing you with a clear overview of your bundle sizes.</p>"},{"location":"deployment/#visualize-dependency-graph","title":"Visualize dependency graph","text":"<p>Use the command below to generate a dependency graph:</p> <pre><code>yarn generate:dependency-graph\n</code></pre> <p>Note</p> <p>This command requires specific parameters to run successfully. For example:</p> <pre><code>yarn generate:dependency-graph client-app/main.ts client-app/shared/account/components/checkout-default-success-modal.vue\n</code></pre> <p>The generated graph will be saved in the artifacts folder for your review.</p>"},{"location":"deployment/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter an error such as <code>dot command not found</code> on Windows, it's likely due to a missing Graphviz installation. Ensure that Graphviz is installed on your system to resolve this issue.</p> <p> </p> \u2190 Architecture Update \u2192"},{"location":"merge/","title":"Merge Updates","text":"<p>To bring the latest changes from the official Virto Commerce theme (e.g., vc-theme-b2b-vue) into your project:</p> <ol> <li> <p>Create a dedicated branch for the update. Replace <code>{1_18}</code> with the theme version in the branch name, for example:</p> <pre><code>git branch update-{1_18}\n</code></pre> </li> <li> <p>Add the official theme repository as an upstream remote:</p> <pre><code>git remote add upstream &lt;link&gt;\n</code></pre> </li> <li> <p>Fetch the latest updates from upstream:</p> <pre><code>git fetch upstream\n</code></pre> </li> <li> <p>Merge the upstream branch into your update branch:</p> <pre><code>git merge {1_18}\n</code></pre> </li> <li> <p>Resolve any merge conflicts if they appear.</p> </li> <li> <p>Remove the temporary upstream remote:</p> <pre><code>git remote remove upstream\n</code></pre> </li> </ol> <p>The latest official changes have been brought into your project.</p> <p> </p> \u2190 Customization and development accelerators Migration to Storefrontless architecture \u2192"},{"location":"migration-on-azure/","title":"Migration on Azure Cloud","text":"<p>The migration process begins with an existing Virto Commerce setup, where:</p> <ul> <li>The initial platform deployment was created using the Deploy to Azure button from the Deploy VC Platform to Azure Cloud article.</li> <li>The Storefront deployment was created using the Deploy Virto Commerce Storefront to Azure Cloud link from the Deploy VC Storefront to Azure Cloud article. </li> </ul> <p>Note</p> <p>If you didn\u2019t use the Deploy VC Platform to Azure Cloud article and the names of the Azure resources differ (for example, the web application name is platform and the SQL server name is sql-server), you will need to modify the ARM template to match the correct names.</p> <p>The result of initial deployment is as follows:</p> <p></p> <ol> <li>Use an ARM template to add the necessary Azure resources for running the Platform with the Theme v.2.0.0 and higher. </li> <li> <p>Open the Azure portal and provide the required Azure resources. Use the existing resource group and the name of the existing Platform Web Application. If the name of the platform application doesn\u2019t match the existing application, the new web application will be created for the Platform.</p> <p></p> </li> <li> <p>Click Review + create, verify the values again, and click Create. The deployment will begin.</p> </li> <li> <p>After the deployment is complete, the resource list will look as follows (new resources are highlighted): </p> <p></p> </li> <li> <p>Add a store URL (Stores \u2192 B2B-store \u2192 Store URL) pointing to the Azure Application Gateway IP address in the format http://x.x.x.x/:</p> <p></p> </li> <li> <p>Use the Azure Application Gateway IP address (http://x.x.x.x/) to access the frontend part of the Virto Commerce solution:</p> <p></p> </li> <li> <p>Test the functionality, then remove the Storefront resources:</p> <p></p> </li> </ol> <p> </p> \u2190 Migration options overview Migration on local machine \u2192"},{"location":"migration-on-local-machine/","title":"Migrate on Local Machine","text":"<p>If you are currently running a local deployment of Virto Commerce with the Platform, Storefront, and Theme files stored on the filesystem, this guide will help you migrate to the new Virto Commerce architecture:</p> <ol> <li>Stop and disable VC Storefront. For example, if you use Docker, locate the docker-compose.yml file that manages your VC Solution, then remove the VC storefront service definition from it.</li> <li>If you are using the standard, non-customized VC Theme, remove the theme files from the directory in which they are stored. Otherwise, you'll need to migrate your customization to the VC Theme version.</li> <li>Deploy Frontend Application on a local machine.</li> </ol> <p>You have successfully migrated to new architecture.</p> <p> </p> \u2190 Migration on Azure Cloud Authentication types \u2192"},{"location":"migration/","title":"Migration","text":"<p>Current Storefront and Theme users have the following options:</p> <ul> <li>Migrate to the new Storefrontless architecture:<ul> <li>Using our guide for migration on Azure Cloud. </li> <li>Using our guide for migration on a local machine.</li> <li>With our assistance.</li> </ul> </li> <li>Continue using the Storefront with the 1.62 version, which will receive updates until the end of 2024. After that, while it will still be possible to use the Storefront, no further updates will be provided.</li> </ul> <p> </p> \u2190 Merging Frontend updates Migration on Azure Cloud \u2192"},{"location":"spa-architecture-for-seo-and-404-handling/","title":"SPA Architecture for SEO and 404 Handling","text":"<p>Virto Commerce Storefront is built as a Single Page Application (SPA) using Vue.js. This architecture provides fast navigation and app-like responsiveness while maintaining SEO compatibility through a combination of clean URLs, dynamic rendering, and fallback routing.</p> <p>The Virto SPA architecture loads a single index.html file and dynamically renders content using GraphQL. Static assets such as JavaScript, CSS, images, and sitemap files are served directly by the CDN or static content server.</p> <p>The request flow is as follows:</p> <ol> <li>If a URL matches a static file, that file is returned.</li> <li>If not, the request is routed to index.html with an HTTP 200 status.</li> <li>The Vue app interprets the path (via the HTML5 History API) and renders the correct page content (e.g., /category/widgets).</li> </ol> <p>This enables clean, shareable URLs and allows users to navigate or refresh pages without breaking.</p> <p></p> <p>It provides the following benefits:</p> <ul> <li>Clean URLs using history mode</li> <li>Deep linking and bookmarking</li> <li>Fast client-side navigation</li> </ul> <p>Note</p> <p>Google recommends using the History API for SPAs to enable crawlable URLs.</p>"},{"location":"spa-architecture-for-seo-and-404-handling/#seo-and-dynamic-rendering-with-prerenderio","title":"SEO and dynamic rendering with Prerender.io","text":"<p>One challenge of SPAs is that search engine bots may not fully execute JavaScript, which limits content visibility. Virto solves this using Prerender, a dynamic rendering solution that generates static HTML snapshots for bots. In other words, search engines see a server-side rendered version, while normal users get the client-side SPA. This hybrid approach delivers the best of both worlds: crawlers see meaningful HTML content (page titles, meta tags, product info), and users still enjoy a fast single-page experience. </p> <p>This works as follows:</p> <ul> <li>A reverse proxy (e.g., Nginx) sits in front of the storefront.</li> <li>If a request comes from a known bot (Googlebot, Facebook, etc.), it is routed to Prerender.</li> <li>Prerender returns a fully rendered HTML version of the page.</li> <li>Normal users continue to get the SPA experience.</li> </ul> <p>This hybrid approach ensures bots receive meaningful content while keeping performance high for users. </p> <p> Setting up Prerender.io with Azure Application Gateway </p> <p>It provides the following benefits:</p> <ul> <li>Full HTML content for bots (title, meta, schema).</li> <li>No major changes required to the SPA architecture.</li> <li>Simpler than full server-side rendering (SSR).</li> </ul>"},{"location":"spa-architecture-for-seo-and-404-handling/#handling-404s-in-spa","title":"Handling 404s in SPA","text":"<p>Because Virto always serves index.html even for unknown URLs, the HTTP response is always 200 \u2014 even when the page doesn't exist. The Vue app handles these cases and displays a custom 404 page (e.g., the CMS page with slug /404). However, that error page is a soft 404: the browser shows an error message, but the server has already sent a 200 OK status. This is a common SPA behavior. It ensures the user sees an error page (and can navigate from it), but from the server\u2019s point of view the request was fulfilled. </p> <p>Virto\u2019s current SPA setup can\u2019t immediately send a 404 status from the server for a missing route, because that would break the SPA flow (the load balancer simply forwarded the request to the app). In practice, when a page isn\u2019t found the SPA shows the 404 content, but Googlebot still sees a 200 response \u2013 what Google calls a soft 404. </p> <p>Google suggests workarounds: for example, after determining content is missing, use a client redirect to a dedicated error URL that does return 404 (for instance, /not-found handled by the server) or add a noindex meta tag on the error page. </p> <p></p> <p>Note</p> <p>Virto Cloud is working on support for server-side HTTP 404 responses based on route handling rules (e.g., custom Nginx logic).</p>"},{"location":"spa-architecture-for-seo-and-404-handling/#tracking-and-fixing-broken-links","title":"Tracking and fixing broken links","text":"<p>Broken links harm SEO and user experience. Virto provides tools to detect and manage them effectively:</p> <ul> <li>Tracking with Google Analytics 4.</li> <li>Using broken links management tool.</li> </ul>"},{"location":"spa-architecture-for-seo-and-404-handling/#tracking-with-google-analytics-4","title":"Tracking with Google Analytics 4","text":"<ul> <li>GA4 automatically logs pageviews, including visits to your 404 page</li> <li>Use a unique title (e.g., \"Page not found\") to filter 404s</li> <li>Use GA4 Engagement reports to identify broken URLs</li> </ul> <p>In practice, you\u2019d filter GA4 by the 404 page\u2019s title or URL, revealing which missing-URL users (or bots) tried to access. Analytics Mania and MeasureSchool have guides on using GA4 for 404 tracking that explain this in detail.</p>"},{"location":"spa-architecture-for-seo-and-404-handling/#using-broken-links-management-tool","title":"Using broken links management tool","text":"<p>This tool logs any 404 hits and lets the team mark each one for action. For example, you can ignore harmless 404s, or set client-side redirects. Virto supports internal redirects (redirecting to another page in the store) or external redirects. There\u2019s also an option to use load balancer (or CDN) rules: for certain legacy URLs you can force a real HTTP 404 instead of letting the SPA catch it, if needed for SEO or compliance. </p> <p>In short, the workflow is: </p> <ol> <li>Track broken links via GA4.</li> <li>Review them in the tool.</li> <li>Either ignore, redirect to a new URL, or explicitly return a 404 status. </li> </ol> <p>This flexibility helps marketing teams fix SEO issues without changing code.</p>"},{"location":"spa-architecture-for-seo-and-404-handling/#alignment-with-best-practices","title":"Alignment with best practices","text":"<p>Overall, Virto\u2019s SPA frontend aligns with current SEO best practices for modern sites. By using clean URLs (History API) and ensuring every page is reachable at a unique path, it meets Google\u2019s recommendation to avoid hash-based routes. By integrating a pre-rendering service, it gives crawlers HTML content to index without sacrificing user experience. The SPA\u2019s fallback to a 200-status index page is a known compromise, but Google explicitly acknowledges this pattern and suggests mitigating it via redirects or noindex tags. With GA4 and Virto\u2019s broken-links tool, teams have visibility into soft 404s and can correct them through redirects (which is actually recommended over leaving soft 404s) or by adjusting their content.</p> <p>Virto\u2019s frontend serves static files directly and routes all other requests through the SPA (index.html), giving smooth in-app navigation and shareable deep links. Prerender  is used to intercept bots and serve SEO-friendly HTML snapshots. Unresolved URLs still return 200+SPA 404 content (a soft 404) by default, but tools like GA4 tracking and the built-in broken links manager help teams detect and handle these cases (via redirects or ignore rules). This architecture strikes a balance between an app-like storefront and SEO needs, following guidelines from Google and SEO experts.</p>"},{"location":"spa-architecture-for-seo-and-404-handling/#avoiding-stale-templates","title":"Avoiding stale templates","text":"<p>To prevent outdated .html templates from being served, make sure your custom module uses the updated webpack.config.js. The latest setup embeds Vue templates directly into app.js, ensuring that the SPA always renders fresh, up-to-date content\u2014critical for both user experience and SEO rendering via services like Prerender.</p> <p> </p> \u2190 Modules architecture Deployment \u2192"},{"location":"update/","title":"Update","text":"<p>New releases are published every two weeks on the GitHub repository releases page.</p> <p>Note</p> <p>It is strongly recommended to update with every release to reduce the risk of merge conflicts and integration issues.</p>"},{"location":"update/#update-from-original-repository-upstream","title":"Update from original repository (upstream)","text":"<p>To fetch and merge changes from the original repository into your current project:</p> <ol> <li> <p>Create a new branch for the update. Replace 1_18 from our example with the target version or tag you are syncing to:</p> <pre><code>git checkout -b update-1_18\n</code></pre> </li> <li> <p>Add the upstream remote. Replace the URL with the actual upstream repository:</p> <pre><code>git remote add upstream https://github.com/VirtoCommerce/vc-frontend.git\n</code></pre> </li> <li> <p>Fetch upstream changes. This will download all branches and commits from upstream, without merging:</p> <pre><code>git fetch upstream\n</code></pre> </li> <li> <p>Merge changes from the dev branch of the upstream into your current branch:</p> <pre><code>git merge upstream/dev\n</code></pre> <p>Note</p> <p>Resolve any merge conflicts if prompted.</p> </li> <li> <p>(Optional) Remove the upstream remote if you don\u2019t need to keep the upstream reference:</p> <pre><code>git remote remove upstream\n</code></pre> </li> </ol> <p>Note</p> <p>Use <code>git remote -v</code> to list current remotes. If you plan to pull updates frequently, you can skip removing upstream. Always test merged code before pushing to production.</p>"},{"location":"update/#merge-specific-release-from-upstream-recommended","title":"Merge specific release from upstream (recommended)","text":"<p>If you need a specific version instead of a branch:</p> <ol> <li> <p>Select the desired release from https://github.com/VirtoCommerce/vc-frontend/releases</p> </li> <li> <p>Add the upstream remote:</p> <pre><code>git remote add upstream https://github.com/VirtoCommerce/vc-frontend.git\n</code></pre> </li> <li> <p>Fetch all tags:</p> <pre><code>git fetch upstream --tags\n</code></pre> </li> <li> <p>Merge the specific release tag (e.g. 2.22.0):</p> <pre><code>git merge tags/2.22.0\n</code></pre> </li> </ol> <p> </p> \u2190 Deployment Theme customization \u2192"},{"location":"authentication/adding-google-as-sso-provider/","title":"Add Google as SSO Provider","text":"<p>To integrate Google as a new SSO provider, install the Google SSO module. After that:</p> <ol> <li>Create Google OAuth 2.0 Client.</li> <li>Set the appsettings.json file.</li> <li>Manage Platform settings.</li> </ol>"},{"location":"authentication/adding-google-as-sso-provider/#create-google-oauth-20-client","title":"Create Google OAuth 2.0 Client","text":"<p>To integrate Google APIs with your application using OAuth 2.0, you need to create authorization credentials. These credentials will allow your app to access the enabled APIs for your project:</p> <ol> <li>Go to the Google API &amp; Services Console.</li> <li>Create a new project if you don't have one, then open the project dashboard.</li> <li>Configure OAuth consent screen. In the OAuth consent screen tab:<ol> <li>Select User Type \u2192 External and click Create.</li> <li>Fill in the App Information (name, user support email, and developer contact information).</li> <li>Skip the Scopes and Test users sections for now.</li> <li>Review your settings and return to the dashboard.</li> </ol> </li> <li>Navigate to the Credentials tab, select Create credentials \u2192 OAuth client ID.</li> <li>Choose Web application as the Application type and name your credentials.</li> <li> <p>In the Authorized redirect URIs section, click ADD URI to specify the redirect URI. Ensure your platform uses HTTPS; otherwise, SSO will not function correctly.</p> <p>Note</p> <p>If your platform runs on a local machine, put https://localhost:10645/signin-google.</p> </li> <li> <p>Click Create.</p> </li> <li>Save Client ID and Client Secret to use them in the module.</li> </ol>"},{"location":"authentication/adding-google-as-sso-provider/#set-appsettingsjson-file","title":"Set appsettings.json file","text":"<p>Store Google Client ID, secret values and other sensitive settings in KeyVault Storage. In our example, we use the appsettings.json configuration file. Add the following section to the configuration:</p> appsettings.json<pre><code>\"Google\": {\n    \"Enabled\": true,\n    \"AuthenticationType\": \"Google\",\n    \"AuthenticationCaption\": \"Google\",\n    \"ClientId\": \"&lt;your Client ID&gt;\",\n    \"ClientSecret\": \"&lt;your Client Secret&gt;\",\n    \"DefaultUserType\": \"Manager\"\n},\n</code></pre>"},{"location":"authentication/adding-google-as-sso-provider/#manage-platform-settings","title":"Manage Platform settings","text":"<p>Configure store settings:</p> <ol> <li>Click Stores in the main menu.</li> <li>In the next blade, select the desired store.</li> <li>In the next blade, click on the Authentication widget.</li> <li> <p>In the next blade, enable/disable Google sign-in for the selected store.</p> <p></p> <p>Note</p> <p>By default, all registered authentication types are enabled.</p> </li> <li> <p>Click Save to save the changes.</p> </li> </ol> <p>The GraphQL query confirms that authentication via Google AD is enabled:</p> <p></p> <p>The Google authentication button appears on the login page of the Frontend Application:</p> <p></p> <p> </p> \u2190 Adding Azure AD (Entra ID) as SSO provider  Google Analytics events  \u2192"},{"location":"authentication/adding-sso-provider/","title":"Add Entra ID (Azure AD) as SSO Provider","text":"<p>Note</p> <p>Azure Active Directory (Azure AD) has been renamed to Microsoft Entra ID. For the remainder of this guide, these terms are considered synonymous.</p> <p>To integrate Entra ID (Azure AD) as a new SSO provider, install the Azure AD module. After that:</p> <ol> <li>Manage backend settings.</li> <li>Manage Platform settings.</li> </ol>"},{"location":"authentication/adding-sso-provider/#backend-settings","title":"Backend settings","text":"<p>Set up the necessary environment variables for the Platform backend to enable user authentication via the Azure AD authentication provider. To allow the Frontend Application to authenticate users as well, enable the corresponding SSO option for the desired store in the Platform interface:</p> environment.yml<pre><code>set \"Azuread:Enabled=true\"\nset \"AzureAd:ApplicationId=86d0***82\"\nset \"Azurend:TenantId=bc03***23\"\nset \"AzureAd:ValidateIssuer=MultitenantAzureAD\"\n</code></pre>"},{"location":"authentication/adding-sso-provider/#platform-settings","title":"Platform settings","text":"<p>Configure store settings:</p> <ol> <li>Click Stores in the main menu.</li> <li>In the next blade, select the desired store.</li> <li>In the next blade, click on the Authentication widget.</li> <li> <p>In the next blade, enable/disable authentication types for the selected store.</p> <p></p> <p>Note</p> <p>By default, all registered authentication types are enabled.</p> </li> <li> <p>Click Save to save the changes.</p> </li> </ol> <p>The GraphQL query confirms that authentication via Entra ID (Azure AD) is enabled:</p> <p></p> <p>The Azure AD (Entra ID) authentication button appears on the login page of the Frontend Application:</p> <p></p> <p>Note</p> <p>If an account does not exist, clicking on the Azure Active Directory button will automatically create a new account.</p> <p> </p> \u2190 Anonymous authentication  Adding Google as SSO provider  \u2192"},{"location":"authentication/anonymous-authentication/","title":"Anonymous Authentication","text":"<p>Anonymous authentication allows an e-commerce system to track and manage interactions for users who haven't logged in. In the Virto Commerce Frontend Application, anonymous users are recognized using a unique identifier stored locally in their browser.</p> <p>When a visitor accesses the website, Virto Commerce assigns an anonymous ID to that user if they don\u2019t already have one. This ID is stored in the browser\u2019s <code>localStorage</code>. This enables the system to recognize the user as long as they remain on the same device and browser. When the Frontend Application needs to fetch data about the user (for example, their shopping cart, browsing history, or preferences), it sends a <code>getMe</code> request to the backend. This request includes the anonymous user ID that was stored earlier in <code>localStorage</code>. Instead of creating a new anonymous user for every session, the backend now checks whether an ID was provided in the request. If the ID is not empty and does not belong to an existing user, that ID is returned. Otherwise, a new one is generated. In other words, no anonymous profiles are stored on the server, and the backend only checks whether an ID was provided in the request. </p> <p></p> <p>Anonymous authentication provides the following benefits:</p> <ul> <li>Enhanced user experience.</li> <li>Faster performance.</li> <li>Simplicity for developers.</li> </ul> <p>Anonymous authentication can be used for: </p> <ul> <li>Guest checkout: Users can shop without logging in and still have their carts preserved across browsing sessions.</li> <li>Abandoned cart recovery: If a user adds items to their cart and leaves without logging in, their cart can be retained when they return, potentially leading to higher conversion rates.</li> </ul> <p> </p> \u2190 Token-based authentication Adding Azure AD (Entra ID) as SSO provider  \u2192"},{"location":"authentication/authentication-types/","title":"Authentication Types","text":"<p>At the heart of Virto Commerce Frontend\u2019s security is token-based authentication. This approach offers a streamlined way to verify users while maintaining a high level of security. There are two primary methods for obtaining these tokens in Virto Commerce Frontend:</p> <ul> <li> <p>Username and password authentication: The most common form of authentication involves users logging in with their username and password. Upon successful authentication, a token is generated and sent to the user. This token is then used for subsequent requests, ensuring that the user remains authenticated without the need to re-enter their credentials.</p> <p></p> </li> <li> <p>Single Sign-On (SSO) via Providers like Entra ID (Azure AD) or Google: For businesses that use Single Sign-On (SSO), Virto Commerce Frontend supports integration with SSO providers such as Azure Active Directory (Azure AD or Entra ID) or Google. This method allows users to authenticate using their existing credentials from another trusted provider. Once authenticated through SSO provider, the platform issues a token that the user can use to access Virto Commerce\u2019s features without needing to log in separately.</p> <p></p> </li> </ul> <p> Adding Entra ID [Azure AD] as SSO provider</p> <p> Adding Google as SSO provider</p> <p> </p> \u2190 Migration to Storefrontless architecture Anonymous authentication \u2192"},{"location":"customization/accelerators-guidelines/","title":"Guidelines for Using Accelerators","text":"<p>To ensure your project remains stable, maintainable, and easy to update, please follow these core principles: </p> <ul> <li>Preserve the core, extend with new files: Avoid modifying the original scripts directly. Doing so will create significant merge conflicts when you pull future updates from the base repository. Instead, always create new files for your custom logic and compose them with the base tooling if needed.</li> <li>Follow established conventions: Build upon the existing foundation to ensure consistency. Place your new scripts in the scripts/ directory, write them in TypeScript, and add corresponding commands to package.json. Mimicking the existing patterns will make your project easier for your team to understand and maintain.</li> <li>Namespace your custom scripts: To prevent naming conflicts with future updates and to clearly distinguish your project's specific tooling, it is best practice to prefix your custom package.json scripts. For example: <code>custom:generate-component</code> or <code>myproject:validate-theme</code>.</li> <li>Ensure compatibility: After adding a new accelerator, always validate that you have not broken any core functionalities. Run the main workflows (build, test, lint) to guarantee that your new tooling coexists safely with the base platform and does not introduce regressions.</li> </ul> <p> </p> \u2190 Development accelerators Localization \u2192"},{"location":"customization/accelerators-overview/","title":"Development Accelerators","text":"<p>Development accelerators are tools and scripts that automate routine tasks, enforce consistency, and speed up the workflow. When extending Frontend for your custom e-commerce project, you will likely want to create your own development accelerators:</p> Aspect Command(s) / Tools Location Description Code generation <code>yarn generate:graphql-types</code> /scripts/graphql-codegen/generator.ts Generates TypeScript types from GraphQL schemas and queries for safe API usage. Linting and formatting <code>yarn lint-staged</code> <code>yarn lint</code> <code>yarn lint:fix</code> <code>yarn prettier</code> <code>yarn prettier:fix</code> eslint.config.js  .prettierrc.json  .prettierignore Ensures consistent code style with automated linting/formatting before commits. Commit message convention <code>commitlint</code> .commitlintrc.json Enforces standard commit message format for readable history &amp; changelogs. Internationalization (i18n) <code>yarn check-locales</code> <code>yarn fix-locales</code> /scripts/ Detects and fixes missing translation keys across locale files. Type checking <code>yarn validate:types</code> (<code>vue-tsc</code>) Project root Validates TypeScript across the codebase to ensure type safety. Dependency validation <code>yarn validate:dependencies</code> (<code>dependency-cruiser</code>) .dependency-cruiser.cjs Enforces dependency rules and prevents architectural violations. UI development (Storybook) <code>yarn storybook:dev</code> <code>yarn storybook:build</code> .storybook/ Develop and test UI components in isolation with Storybook. Bundle analysis <code>yarn generate:bundle-map</code> /artifacts/bundle-map.html Generates a visual map of JS bundles to identify heavy dependencies. Dependency graph <code>yarn generate:dependency-graph</code> /artifacts/dependency-graph.html Produces a graph of module dependencies to analyze architecture. Local SSL certificates <code>yarn generate:certificates</code> /scripts/generate-certificates.ts Creates SSL certificates for secure local development (HTTPS). <p> </p> \u2190 Customization Guidelines for using accelerators \u2192"},{"location":"customization/customization-overview/","title":"Overview","text":"<p>The following folders with files define the Frontend functionality and appearance:</p> Folder Function Content client-app/assets Visual theme customization <ul><li>icons: SVG and icon files used throughout the Frontend.</li><li>images: Static images such as banners, logos, and placeholders.</li><li>presets: Predefined configurations for the theme.</li><li>styles: SCSS/CSS files that define the look and feel of the Frontend, including colors, spacing, typography, and component styles.</li></ul> config Functionality customization <ul><li>manifest.webmanifest: Metadata for the web application.</li><li>menu.json: The navigation menu structure and items for the Frontend.</li> <li>product-default.json: Default product display settings.</li> <li>product_b2c.json: Specific product configuration for B2C stores.</li> <li>settings_data.json: Feature configurations. You can enable/disable quotes and product comparison, set limits for lists, configure order and quote statuses, and more.</li></ul> <p> Complete Frontend structure</p> <p>Some components are intuitive, while others can be clicked to view a detailed customization guide.</p> <p> </p> \u2190 Customization and development accelerators Visual theme customization \u2192"},{"location":"customization/functionality-customization/","title":"Functionality Customization","text":"<p>This guide explains how to customize Virto Commerce Frontend functionality using configuration files. Each file controls a specific aspect of the Frontend:</p> <ul> <li>manifest.webmanifest defines Progressive Web App (PWA) settings.</li> <li>menu.json configures navigation menus for desktop and mobile.</li> <li>product-default.json and product_b2c.json manage product page layout and content blocks.</li> <li>settings_data.json provides global Frontend settings for browsing, checkout, search, vendors, branding, and more.</li> </ul> <p>By adjusting these files, you can flexibly tailor the Frontend experience without modifying the core application code.</p>"},{"location":"customization/functionality-customization/#manifestwebmanifest","title":"manifest.webmanifest","text":"<p>The manifest.webmanifest file defines Progressive Web App (PWA) settings for the Virto Commerce Frontend. It allows you to configure how the Frontend behaves when installed on devices or added to the home screen, as well as control certain visual and functional aspects.</p> Field Purpose <code>name</code> Full name of the store. Displayed when the app is installed on a device. <code>short_name</code> Shortened name for UI contexts where space is limited (e.g., home screen icons). <code>description</code> Provides a description of the store, used by search engines or PWA installers. <code>lang</code> Default language of the application, affecting accessibility and SEO. <code>display</code> Determines how the app appears when launched: <code>standalone</code> hides the browser UI, giving an app-like experience. <code>orientation</code> Controls device orientation. <code>start_url</code> The URL that opens when users launch the PWA from a home screen shortcut. <code>background_color</code> Sets the background color displayed during app loading. <code>theme_color</code> Sets the color for the browser UI elements (status bar, address bar) and splash screen. <code>icons</code> Defines icons for the PWA on different devices and screen sizes. SVG, PNG, or other formats can be used. <p>Example. Setting default language</p> <pre><code>...\n  \"name\": \"Store\",\n  \"short_name\": \"Store\",\n  \"description\": \"Store description\",\n  \"lang\": \"en-US\",\n  \"display\": \"standalone\",\n  \"orientation\": \"any\",\n...\n</code></pre> <p></p>"},{"location":"customization/functionality-customization/#menujson","title":"menu.json","text":"<p>The menu.json file defines the structure and behavior of header and footer menus in the Virto Commerce Frontend. It allows you to configure which menu items appear, their order, associated icons, routes, and nested submenus, providing a flexible way to adapt navigation to your Frontend needs.</p> Section Purpose <code>header.desktop.main</code> Defines the main menu items for the desktop view. Each item can include an ID, route, title, icon, and priority for ordering. <code>header.desktop.account</code> Defines the My Account dropdown for desktop, including links like Dashboard, Profile, Orders, Lists, and Saved Credit Cards. <code>header.desktop.corporate</code> Defines the corporate menu for desktop users, such as Company Info and Company Members. <code>header.mobile.main</code> Defines the main menu items for mobile devices, including catalog, compare, bulk order, cart, and contact links. <code>header.mobile.account</code> Defines the mobile My Account menu with nested items similar to desktop. <code>header.mobile.corporate</code> Defines the mobile corporate menu items. <code>footer</code> Defines footer navigation items (empty in this example, but can be populated similarly). <p>Example. Setting menu items order</p> <pre><code>...\n        {\n          \"id\": \"bulk-order\",\n          \"route\": {\n            \"name\": \"BulkOrder\"\n          },\n          ...\n        },\n        {\n          \"id\": \"compare\",\n          \"route\": {\n            \"name\": \"CompareProducts\"\n          },\n        },\n        ...\n        {\n          \"id\": \"lists\",\n          \"route\": {\n            \"name\": \"Lists\"\n          },\n        },\n        ...\n        {\n          \"id\": \"orders\",\n          \"route\": {\n            \"name\": \"Orders\"\n          },\n          ...\n        },\n        {\n          \"id\": \"cart\",\n          \"route\": {\n            \"name\": \"Cart\"\n          },\n        },\n...\n</code></pre> <p></p>"},{"location":"customization/functionality-customization/#product-defaultjson","title":"product-default.json","text":"<p>The product-default.json file defines the layout and content structure of product pages in the Virto Commerce Frontend. It allows you to configure which sections and blocks appear on a product page, their order, visibility, and specific types of content displayed. This provides a flexible way to control product presentation without modifying the core code.</p> Section / Block Purpose <code>settings</code> Contains metadata for the template, such as the template name (<code>name</code>). <code>content</code> Defines the sections that make up the product page. Each section can have an <code>id</code>, <code>type</code>, <code>hidden</code> flag, and <code>blocks</code>. <code>product-info</code> Displays main product details such as properties, description, assets, and variations. <code>product-properties</code> (block) Shows product attributes like SKU, color, size, etc. <code>product-description</code> (block) Displays the full product description. <code>product-assets</code> (block) Shows images, videos, or downloadable files. <code>product-variations</code> (block) Allows selection of different product variants. <code>related-products</code> Displays products related to the current one to encourage cross-selling. <code>recommended-products</code> Displays additional product suggestions based on models such as <code>related-products</code> or <code>bought-together</code>. <code>product-reviews</code> Displays user reviews, ratings, and comments for the product. <p>Example. Displaying the related products section</p> <pre><code>...\n    {\n      \"id\": \"section3\",\n      \"type\": \"related-products\",\n      \"hidden\": false\n    },\n...\n</code></pre> <p></p>"},{"location":"customization/functionality-customization/#product_b2cjson","title":"product_b2c.json","text":"<p>The product_b2c.json file defines a product page template optimized for B2C (Business-to-Consumer) scenarios in Virto Commerce Frontend. It customizes functionality by specifying which sections and blocks appear on the product page, and how they are structured.</p> Section / Block Purpose <code>settings</code> Contains metadata, here naming the template \"Product template B2C\". <code>product-info</code> Displays the main product details. Includes: <ul><li><code>product-options</code>: Lets customers configure product options (e.g., size, color).</li><li><code>product-properties</code>: Shows product attributes like SKU, materials, or specifications.</li><li><code>product-description</code>: Displays the detailed product description.</li><li><code>product-assets</code>: Provides product media, such as images, videos, or downloadable files.</li></ul> <code>related-products</code> Encourages cross-selling by showing items related to the current product. <code>recommended-products</code> Suggests additional items based on models: <ul><li><code>related-products</code>: Shows similar items.</li><li><code>bought-together</code>: Displays products often purchased with the current one.</li></ul> <code>product-reviews</code> Displays user-generated reviews, comments, and ratings. <p>Example. Displaying the recommended products section</p> <pre><code>...\n      \"id\": \"section4\",\n      \"type\": \"recommended-products\",\n      \"hidden\": false,\n...\n</code></pre> <p></p>"},{"location":"customization/functionality-customization/#settings_datajson","title":"settings_data.json","text":"<p>The settings_data.json file defines global theme and Frontend behavior settings for Virto Commerce Frontend. It provides toggles, limits, and configurations that control how the Frontend looks and functions for end users, including the following:</p> Setting / Group Purpose <code>current</code> Specifies the currently active settings profile (e.g., <code>\"default\"</code>). Product browsing and display <ul><li><code>details_browser_target</code>: Defines how product detail links open (<code>_blank</code>, <code>_self</code>).</li><li><code>product_compare_enabled</code> and <code>product_compare_limit</code>: Enables product comparison and sets the max number of items to compare.</li><li><code>product_filters_sorting</code> and <code>product_filters_sorting_direction</code>: Controls if product filters can be sorted, and in which order.</li><li><code>product_quantity_control</code>: Defines the UI for quantity selection (e.g., <code>\"stepper\"</code>).</li><li><code>range_filter_type</code>: Configures filter type (e.g., <code>\"slider\"</code>).</li></ul> Vendors and categories <ul><li><code>vendor_enabled</code>: Enables vendor info display.</li><li><code>vendor_rating_enabled</code>: Shows vendor ratings.</li><li><code>categories_limit</code>: Restricts number of categories shown.</li><li><code>wishlists_limit</code>: Sets max number of wishlists a user can create.</li></ul> Search <ul><li><code>search_max_chars</code>: Max characters allowed in search queries.</li><li><code>search_static_content_suggestions_enabled</code>: Enables static content suggestions in search results.</li><li><code>search_product_phrase_suggestions_enabled</code>: Toggles product phrase suggestions.</li></ul> Checkout <ul><li><code>checkout_multistep_enabled</code>: Toggles multistep checkout flow.</li><li><code>checkout_comment_enabled</code>: Allows buyers to leave comments during checkout.</li><li><code>checkout_purchase_order_enabled</code>: Enables purchase order number field.</li><li><code>checkout_coupon_enabled</code>: Allows coupon code usage.</li><li><code>checkout_gifts_enabled</code>: Enables gift options.</li></ul> Payments and security <ul><li><code>isCVVinSkyflowRequired</code>: Defines whether CVV is mandatory when storing cards in Skyflow.</li></ul> Navigation and layout <ul><li><code>default_return_url</code>: Defines redirect URL after certain actions (e.g., login).</li><li><code>catalog_pagination_mode</code>: Controls pagination style (<code>infinite_scroll</code>, etc.).</li><li><code>desktop_menu_mode</code>: Defines menu layout (<code>horizontal</code>/<code>vertical</code>).</li></ul> Branding and media <ul><li><code>logo_image</code>, <code>logo_inverted_image</code>, <code>favicon_image</code>: Customize Frontend branding.</li><li><code>homepage_background_image</code>: Sets the homepage banner image.</li></ul> Images and media handling <ul><li><code>image_thumbnails_enabled</code>: Enables thumbnail generation.</li><li><code>image_thumbnails_original_fallback_enabled</code>: Falls back to original if thumbnail missing.</li><li><code>image_thumbnails_suffixes</code>: Defines suffixes for different image sizes (<code>sm</code>, <code>md</code>, <code>lg</code>).</li><li><code>image_carousel_in_product_card_enabled</code>: Enables image carousel inside product cards.</li></ul> Messaging and files <ul><li><code>files_enabled</code>: Allows file uploads.</li><li><code>push_messages_enabled</code>: Enables push notifications for Frontend.</li></ul> Pricing and availability <ul><li><code>zero_price_product_enabled</code>: Determines if products with price <code>0</code> can be displayed/purchased.</li></ul> Orders <ul><li><code>orders_statuses</code>: Defines which order statuses are available for customers (continues in file).</li></ul> <p>Example. Enabling products comparison</p> <pre><code>...\n\"settings\": {\n    \"details_browser_target\": \"_blank\",\n\n    \"files_enabled\": true,\n\n    \"push_messages_enabled\": true,\n\n    \"product_compare_enabled\": true,\n    \"product_compare_limit\": 5,\n    \"product_filters_sorting\": false,\n...\n</code></pre> <p></p> <p> </p> \u2190 Visual theme customization Development accelerators \u2192"},{"location":"customization/localization/","title":"Frontend Localization","text":"<p>Virto Commerce Frontend supports localization through JSON-based language files stored in the following folders:</p> Folder path Description /locales/*.json Localizations for shared UI components and global Frontend strings. /client-app/ui-kit/locales/*.json Localizations for UI Kit components (buttons, inputs, alerts, layouts). /client-app/modules/[module]/locales/*.json Localizations for each frontend module (checkout, etc.). <p>By contributing new or updated translations, you can extend the Frontend to support additional languages.</p>"},{"location":"customization/localization/#prepare-localization-file","title":"Prepare localization file","text":"<ol> <li>Open the English localization file in the appropriate folder:</li> <li>Use an AI tool (such as ChatGPT or Grok) to translate it. The simplest prompt is \u201cLocalize this JSON into ...\u201d.</li> <li>Review and adjust the translation for accuracy and terminology consistency.</li> <li>Save the translated file.</li> </ol>"},{"location":"customization/localization/#contribute","title":"Contribute","text":"<p>To add your translation to Virto Commerce Frontend:</p> <ol> <li>Fork the repository.</li> <li>Create a feature branch, e.g.:</li> <li>Add the new JSON translation file to a relevant folder.</li> <li>Run frontend build/tests to ensure the localization loads correctly.</li> <li>Commit and push your changes.</li> <li>Submit a pull request to the main repo.</li> </ol> <p>Once your localization PR is accepted, the new language files are included in the Frontend source. The language becomes available in the Frontend.</p> <p></p> <p> Tracking and fixing missing locales</p> <p> </p> \u2190 Guidelines for using accelerators Tracking and fixing locales \u2192"},{"location":"customization/overview/","title":"Overview","text":"<p>Virto Commerce Frontend is designed to be flexible and extensible. As a developer, you can adapt it to the needs of your e-commerce project in two complementary ways:</p> <ul> <li>Customization of the application itself: Modify the appearance and functionality that define the customer experience (icons, images, SCSS/CSS styles, theme presets, menus, product display settings, and other runtime configurations.)</li> <li>Using development accelerators: Use built-in tools and scripts that automate routine tasks, enforce consistency, and make the customization process faster and safer (GraphQL type generation, locale checks and fixes, bundle analysis, dependency validation, SSL certificate generation).</li> </ul> <p> </p> \u2190 Update Customization \u2192"},{"location":"customization/texts-customization/","title":"Track and Fix Locales","text":"<p>Virto Commerce Frontend provides flexible tools to customize all text content displayed in the Frontend. This includes modifying static texts, translating them into multiple languages, and ensuring consistent localization across the entire application. Text customization is handled through locale files, which define translation keys and their corresponding values for different languages.</p>"},{"location":"customization/texts-customization/#check-for-missing-locale-keys","title":"Check for missing locale keys","text":"<p>To ensure that all locale files have consistent keys across different languages and avoid missing translations, run:</p> <pre><code>yarn check-locales -- path/to/locales_folder path/to/**/locales\n</code></pre> <p>The script outputs warnings for any missing keys in the locale files. Review these warnings to ensure all necessary translations are present. This check is also integrated into the CI pipeline to automate the validation process.</p>"},{"location":"customization/texts-customization/#fix-missing-locales","title":"Fix missing locales","text":"<p>To automatically fix missing translations in the locale files using AI translation, run.</p> <pre><code>yarn fix-locales -- path/to/locales_folder path/to/**/locales\n</code></pre> <p>This command analyzes all locale files, identifies missing keys, translates the missing content from the source language to the target language, and updates the locale files accordingly.</p> <p>Note</p> <p>This command requires the <code>APP_GEMINI_API_KEY</code> environment variable to be set. You can obtain this API key from the Google AI Studio website.</p> <p>Warning</p> <p>This is an experimental feature and may not work as expected.</p> <p> </p> \u2190 Localization Merging Frontend updates \u2192"},{"location":"customization/visual-theme-customization/","title":"Visual Theme Customization","text":"<p>Visual theme customization in Virto Commerce Frontend is based on a flexible system of presets, CSS variables, and style overrides. Presets define the overall look of the Frontend by providing color palettes and design tokens that are automatically converted into reusable CSS custom properties. These variables can be fine-tuned or extended in custom styles, giving you full control over colors, spacing, and component appearance. Additionally, global and per-component options such as border radius ensure consistent, brand-aligned UI design.</p>"},{"location":"customization/visual-theme-customization/#presets","title":"Presets","text":"<p>Presets are JSON files that define color palettes and other design tokens for the Frontend.</p> <p>During project build, presets are converted into CSS custom properties (<code>--color-*</code> variables), which can be reused across all components.</p> <p>For example, <code>\"color_primary_50\": \"#f6f1ef\"</code> becomes <code>--color-primary-50: #f6f1ef</code>.</p> <p>You can use the following presets as a base to create own presets:</p> <ul> <li>The default preset: Uses the base palette without additional variables.</li> <li>The Coffee, Black-Gold, Purple-Pink, Watermelon presets: Redefine palettes and may introduce additional variables if needed.</li> </ul> <p>Note</p> <p>You can use AI to create color palettes - ask it to generate colors for an e-commerce website in JSON format based on presets. </p> <p> Applying presets</p>"},{"location":"customization/visual-theme-customization/#customizable-variables","title":"Customizable variables","text":"<p>The CSS custom properties are generated from presets and can be overridden in _custom.scss.</p> <p>Below is the breakdown of some variables:</p> <p></p>"},{"location":"customization/visual-theme-customization/#border-radius-configuration","title":"Border radius configuration","text":"<p>You can easily adjust border-radius values for all components or on a per-component basis using CSS custom properties.</p> <ul> <li><code>--vc-radius</code>: Sets the global border-radius for all components. Default: 0.5rem (8px).</li> <li> <p>Per-component overrides: If you need a different radius for a specific component, you can override the global value by defining a custom property scoped to that component. For example:</p> <ul> <li><code>--vc-button-radius</code></li> <li><code>--vc-widget-radius</code></li> <li>etc.</li> </ul> </li> </ul> <p>Note</p> <p>Recommended maximum border-radius: 10px (0.625rem). Larger values may appear overly rounded and disrupt visual consistency.</p> _custom.scss<pre><code>:root {\n  // Change the global radius\n  --vc-radius: 0.25rem; // now 4px\n\n  // Override button radius only\n  --vc-button-radius: 0.75rem; // now 12px\n}\n</code></pre>"},{"location":"customization/visual-theme-customization/#styles-customization","title":"Styles customization","text":"<p>Component styles follow the BEM methodology. To avoid merge conflicts and keep your customizations centralized, do not edit the core style files. Instead, put all your overrides into the client-app/assets/styles/_custom.scss file:</p> _custom.scss<pre><code>.vc-container {\n  &amp;__bg {\n    background-color: red;\n  }\n}\n</code></pre> <p> </p> \u2190 Customization overview Functionality customization \u2192"},{"location":"integrations/prerender_io/","title":"Enhancing SEO with Prerender.io","text":"<p>The current Virto Commerce Frontend Application uses the power of Single Page Applications (SPAs) to provide a unique, interactive, and fast user experience. However, while SPAs excel in user experience, they often pose challenges for search engines due to their dynamic nature. This dynamic behavior, which is a strength for user engagement, can become a hurdle in attracting organic traffic.</p> <p>To overcome these challenges and strike a balance between an engaging user experience and search engine optimization (SEO), Prerender.io represents as a valuable solution. Prerender.io generates pre-rendered HTML snapshots for SPAs, significantly improving SEO-friendliness and Web Vitals metrics. This integration doesn't require the adoption of complex Server-Side Rendering (SSR) frameworks like Next or Nuxt, preserving the simplicity of the presentation application. This guide explores how Prerender.io provides a straightforward yet highly effective solution to boost the visibility, performance, and overall experience of Vue.js SPAs.</p>"},{"location":"integrations/prerender_io/#integration-with-virto-commerce-frontend-application","title":"Integration with Virto Commerce Frontend Application","text":"<p>In this guide, we describe the results of Prerender.io  integration with the vc-theme-b2b-vue. A practical example is our site, which is built on vc-theme-b2b-vue and uses the Prerender.io service.</p>"},{"location":"integrations/prerender_io/#configuration-details","title":"Configuration details","text":"<p>The integration involved setting up a reverse proxy using Nginx in front of the VC Frontend Application. Additionally, the vc-theme-b2b-vue and Prerender's cloud service were installed. The Nginx reverse proxy was configured based on the example.</p> <p></p> <p>A notable configuration adjustment was made to ensure proper image loading on Server-Side Rendering (SSR) pages, requiring the activation of the image loading option in the Prerender.io dashboard.</p> <p></p>"},{"location":"integrations/prerender_io/#performance-evaluation","title":"Performance evaluation","text":"<p>To measure the impact of Prerender.io on performance, a PageSpeed analysis was conducted for a category listing page. The comparison involved assessing the performance with and without SSR page rendering through Prerender.io.</p> <p></p>"},{"location":"integrations/prerender_io/#conclusion","title":"Conclusion","text":"<p>The primary advantage of utilizing Prerender.io for custom Virto Commerce frontend solutions, especially those with stringent SEO requirements, lies in its ability to enhance SEO without compromising the purity of the SPA architecture. This eliminates the need for substantial changes or investments in complex SSR frameworks like Nuxt.js.</p> <p>By avoiding server-side logic, Prerender.io enables a streamlined frontend solution, eliminating concerns related to caching, scaling, server error handling, and logging \u2013 elements typically unnecessary for pure SPA applications. Prerender.io offers a simplified and effective solution to enhance search engine visibility and performance without requiring extensive modifications to existing code.</p> <p> SPA JavaScript SEO Challenges and Solutions - Prerender.io</p> <p> Setting Up Prerender.io with Azure Application Gateway</p> <p> </p> \u2190 Google Analytics events  Builder.io  \u2192"},{"location":"integrations/builder-io/catalog-menu-intergration/","title":"Overview","text":"<p>In this article, we will integrate Catalog Menu with the Builder.io CMS. The integration will allow you to create and manage catalog navigation links in the Builder.io CMS and display them in the Virto Commerce vue-b2b-theme.</p> <p>In this guide, we will:</p> <ol> <li>Create a structured data model for the Catalog menu.</li> <li>Create catalog menu content.</li> <li>Fetch catalog navigation links from Builder.io and display them in the vue-b2b-theme.</li> </ol>"},{"location":"integrations/builder-io/catalog-menu-intergration/#create-data-model-in-builderio","title":"Create Data Model in Builder.io","text":"<p>To create data model in Builder.io:</p> <ol> <li>Go to the Models menu and click Create Model in the top right corner. </li> <li>Select the model type from the dropdown list. We will select Data. </li> <li>Enter the name of the component and its description. We will enter Megamenu items. </li> <li> <p>Change preview URL to http://localhost:YOUR_PORT where YOUR_PORT is the port of your Virto Commerce vue-b2b-theme application.</p> <p></p> </li> <li> <p>Set up the actual field in the entry that holds our component. In our example, we click Fields and add a new field called items of the type List. This field will hold the items of the catalog menu. Similarly, we add new fields id, title, icon, route, priority, isCatalogItem, children. The children field will be of the type List and will hold the same fields as its parent. The nesting will be as follows:</p> <pre><code>items\n    \u2514\u2500\u2500 id\n    \u2514\u2500\u2500 title\n    \u2514\u2500\u2500 icon\n    \u2514\u2500\u2500 route\n    \u2514\u2500\u2500 priority\n    \u2514\u2500\u2500 isCatalogItem\n    \u2514\u2500\u2500 children\n        \u2514\u2500\u2500 id\n        \u2514\u2500\u2500 title\n        \u2514\u2500\u2500 icon\n        \u2514\u2500\u2500 route\n        \u2514\u2500\u2500 priority\n        \u2514\u2500\u2500 isCatalogItem\n</code></pre> <p></p> </li> </ol>"},{"location":"integrations/builder-io/catalog-menu-intergration/#create-catalog-menu-content","title":"Create Catalog Menu Content","text":"<p>To create catalog menu content:</p> <ol> <li>Go to the Content menu and click Megamenu items in the Structured data models section. </li> <li>Click New Entry and select Megamenu items model from the dropdown list to create new catalog menu content. </li> <li>On the new page, add the content for the catalog menu.</li> <li>Click + Item to add items to the catalog menu. </li> <li> <p>Click + Child to add children links to the selected item.</p> <p></p> </li> </ol>"},{"location":"integrations/builder-io/catalog-menu-intergration/#fetch-content-from-builderio-and-display-in-vue-b2b-theme","title":"Fetch Content from Builder.io and Display in vue-b2b-theme","text":"<p>To fetch content from Builder.io and display it in the vue-b2b-theme, go to the vue-b2b-theme and edit the <code>useNavigations</code> composable: change the <code>fetchCatalogMenu</code> method to fetch the Catalog Menu from Builder.io. Specifically, replace the <code>getMenu</code> method call with the <code>getContent</code> method call and pass the path to our menu.</p> client-app/core/composables/useNavigations.ts<pre><code>export function useNavigations() {\n    // ...\n      async function fetchCatalogMenu() {\n    // ...\n\n    try {\n      if (catalog_menu_link_list_name) {\n\n        // Commented out the old method of fetching the catalog menu\n        // catalogMenuItems.value = (await getMenu(catalog_menu_link_list_name)).map((item) =&gt;\n        //   convertToExtendedMenuLink(item, true),\n        // );\n\n        // Get catalog menu from Builder.io\n        catalogMenuItems.value = (\n          await getContent({\n            model: \"megamenu-items\",\n            apiKey: themeContext.value.settings.builderIoKey,\n          })\n        )?.data.items\n\n      } else {\n        // ...\n      }\n    }\n    // ...\n  }\n  // ...\n}\n</code></pre> <p>The Catalog Menu has been fetched from Builder.io and displayed in the vue-b2b-theme. Now you can publish the changes and see the Catalog Menu in the vue-b2b-theme.</p>"},{"location":"integrations/builder-io/category-page-integration/","title":"Category page integration","text":"<p>In this article, we will integrate Builder.io CMS into the category page of the Virto Commerce vue-b2b-theme. The integration allows you to create and manage content in Builder.io CMS and display it in the Virto Commerce vue-b2b-theme.</p> <p>To use Builder.io CMS with the page:</p> <ol> <li>Create page model in Builder.io CMS for the category page. The page model defines the properties of the category page and how it is rendered in the Builder.io CMS.</li> <li>Add Builder.io to the page component. This allows you to fetch content from `Builder.io** and display it in the category page.</li> <li>Create content. Add components to your page model and fill them with content.</li> </ol>"},{"location":"integrations/builder-io/category-page-integration/#create-page-model-in-builderio","title":"Create Page Model in Builder.io","text":"<p>To create page model:</p> <ol> <li>Go to the Models menu and click Create Model in the top right corner. </li> <li>Select the model type from the dropdown list. We select Page. </li> <li>Enter the name of the component and its description. We enter Category page.</li> <li> <p>Change preview URL to http://localhost:YOUR_PORT where YOUR_PORT is the port of your Virto Commerce vue-b2b-theme application.</p> <p></p> </li> <li> <p>Add a new field called showSidebar of the type Boolean. This allows you to hide the sidebar if needed. </p> </li> <li> <p>Click Save to save the changes.</p> <p></p> </li> <li> <p>Use this model to create the content for our category page in the Page content section. Go to the Content menu and click Category page in the Page models section. </p> </li> <li> <p>Click New Entry and select Category page model from the dropdown list to create new page:</p> <p></p> </li> </ol>"},{"location":"integrations/builder-io/category-page-integration/#add-builderio-to-the-page-component","title":"Add Builder.io to the Page Component","text":"<p>To integrate Builder.io with the category page:</p> <ol> <li> <p>Edit category.vue page component in the client-app/pages folder.</p> TemplateScript client-app/shared/landing-page.vue<pre><code>&lt;template&gt;\n    &lt;RenderContent\n        v-if=\"canShowContent\"\n        model=\"category-page\"\n        :content=\"content\"\n        :api-key=\"apiKey\"\n        :custom-components=\"registeredComponents\"\n    /&gt;\n    &lt;Category\n        :category-id=\"categoryId\"\n        :show-sidebar=\"content?.data?.showSidebar ?? true\"\n    /&gt;\n&lt;/template&gt;\n</code></pre> client-app/shared/landing-page.vue<pre><code>import { Category } from \"@/shared/catalog\";\nimport { getContent, RenderContent, isPreviewing } from \"@builder.io/sdk-vue/vue3\";\nimport { onMounted, shallowRef } from \"vue\";\nimport { useRouter } from \"vue-router\";\nimport { useBuilder } from \"@/shared/builder-io/composables/useBuilder\";\n\ninterface IProps {\n    categoryId: string;\n}\n\ndefineProps&lt;IProps&gt;();\nconst router = useRouter();\nconst { registeredComponents } = useBuilder();\n\nconst canShowContent = shallowRef(true);\nconst content = shallowRef(null);\nconst pageNotFound = shallowRef(false);\n\nonMounted(async () =&gt; {\n    await tryLoadContent(window.location.pathname);\n});\n\nrouter.beforeEach(async (to) =&gt; {\n    await tryLoadContent(to.fullPath);\n});\n\nasync function tryLoadContent(url: string) {\n    try {\n        const result = await getContent({\n        model: \"category-page\",\n        apiKey: \"121744b9a9944bae8c35aeef88a87ba0\",\n        userAttributes: {\n            urlPath: url,\n        },\n        });\n\n        content.value = result;\n        canShowContent.value = !!content.value || isPreviewing();\n    } catch (e) {\n        pageNotFound.value = true;\n    }\n}\n</code></pre> </li> <li> <p>As we want to use <code>showSidebar</code> property to control sidebar visibility, we change the category.vue component to use props from matcher.vue and add <code>v-if</code> condition in the <code>sidebar</code> section.</p> client-app/shared/catalog/components/category.vue<pre><code>&lt;template&gt;\n    &lt;!-- Sidebar --&gt;\n    &lt;div class=\"flex items-stretch lg:gap-6\"&gt;\n        &lt;template v-if=\"showSidebar\"&gt;\n\n        &lt;!-- Sidebar template --&gt;\n\n        &lt;/template&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre> client-app/shared/catalog/components/category.vue<pre><code>interface IProps {\ncategoryId?: string;\nisSearchPage?: boolean;\nshowSidebar?: boolean;\n}\n\nconst props = withDefaults(defineProps&lt;IProps&gt;(), {\nshowSidebar: true,\n});\n</code></pre> </li> </ol> <p>Now you can preview the category page in the Builder.io and start creating content for it.</p>"},{"location":"integrations/builder-io/category-page-integration/#create-content","title":"Create content","text":"<p>You can create content by adding components to your page model and filling them with content.</p> <p>If you have already added custom components to Builder.io, you can use them to create content for the page. </p> <p> Registering Custom Components</p> <p>As a result, you will get integration of Builder.io CMS with the category page of Virto Commerce vue-b2b-theme:</p> <p></p>"},{"location":"integrations/builder-io/footer-integration/","title":"Footer integration","text":"<p>In this article, we will integrate Footer with the Builder.io CMS. The integration will allow you to create and manage footer sections and navigation links in the Builder.io CMS and display them in the Virto Commerce vue-b2b-theme.</p> <p>In this guide, we will:</p> <ol> <li>Create a structured data model.</li> <li>Fetch footer sections and navigation links from Builder.io and display them in the vue-b2b-theme.</li> </ol>"},{"location":"integrations/builder-io/footer-integration/#create-data-model-in-builderio","title":"Create Data Model in Builder.io","text":"<p>To create data model:</p> <ol> <li>Go to the Models menu and click Create Model in the top right corner. </li> <li>Select the model type from the dropdown list. We select Data. </li> <li>Enter the name of the component and its description. We enter Footer items.</li> <li> <p>Change preview URL to http://localhost:YOUR_PORT where YOUR_PORT is the port of your Virto Commerce vue-b2b-theme application.</p> <p></p> </li> <li> <p>Set up the actual field in the entry that holds our component. In our example, we click Fields and add a new field called columns of the type List. This field will hold the columns of the footer. Similarly, we add new fields title (type Text), links (type List), which is an array. The links field holds the links of the footer. The nesting will be as follows:</p> <pre><code>columns\n    \u2514\u2500\u2500 title\n    \u2514\u2500\u2500 links\n            \u2514\u2500\u2500 title\n            \u2514\u2500\u2500 link\n</code></pre> <p></p> </li> </ol>"},{"location":"integrations/builder-io/footer-integration/#create-footer-content","title":"Create Footer Content","text":"<p>To create footer content:</p> <ol> <li>Go to the Content menu and click Footer items in the Structured data models section. </li> <li>Click New Entry and select Footer items model from the dropdown list to create new footer content. </li> <li>On the new page, add the content for the footer.</li> <li>Click + Column to add columns to the footer. </li> <li> <p>Click + Link to add links to the footer.</p> <p></p> </li> </ol>"},{"location":"integrations/builder-io/footer-integration/#fetch-content-from-builderio-and-display-in-vue-b2b-theme","title":"Fetch Content from Builder.io and Display in vue-b2b-theme","text":"<p>To fetch content from Builder.io and display it in the vue-b2b-theme, go to the vue-b2b-theme and edit the vc-footer component. Remove hard-coded columns and change it to the fetched ones.</p> <p>The final <code>vc-footer</code> component will look as follows:</p> TemplateScript <pre><code>&lt;template&gt;\n    &lt;footer aria-label=\"Footer\"&gt;\n        &lt;!-- Top footer --&gt;\n        &lt;div\n        v-if=\"!compact\"\n        class=\"hidden bg-[color:var(--color-footer-top-bg)] text-[color:var(--color-footer-top-text)] md:block print:!hidden\"\n        &gt;\n        &lt;div class=\"container mx-auto grid grid-cols-2 gap-4 p-12 lg:grid-cols-4 xl:grid-cols-5\"&gt;\n            &lt;!-- Logo column --&gt;\n            &lt;div class=\"hidden xl:block\"&gt;\n            &lt;VcImage :src=\"$cfg.logo_inverted_image\" :alt=\"$context.storeName\" class=\"h-9\" lazy /&gt;\n            &lt;/div&gt;\n\n            &lt;div v-for=\"(col, index) in columns\" :key=\"index\"&gt;\n            &lt;div v-t=\"col.title\" class=\"mb-3 text-base font-extrabold uppercase text-white\"&gt;&lt;/div&gt;\n            &lt;div class=\"flex flex-col space-y-1\"&gt;\n                &lt;FooterLink\n                v-for=\"(link, linkIndex) in col.links\"\n                :key=\"`link_${linkIndex}`\"\n                v-t=\"link.title\"\n                :to=\"link.link\"\n                &gt;&lt;/FooterLink&gt;\n            &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;!-- Bottom footer --&gt;\n        &lt;!-- ... --&gt;\n    &lt;/footer&gt;\n&lt;/template&gt;\n</code></pre> client-app/shared/layout/components/footer/vc-footer.vue<pre><code>import { getContent } from \"@builder.io/sdk-vue/vue3\";\nimport pkg from \"../../../../../package.json\";\nimport FooterLink from \"./_internal/footer-link.vue\";\nimport { onMounted, ref } from \"vue\";\n\ninterface IProps {\n    compact?: boolean;\n}\n\ndefineProps&lt;IProps&gt;();\n\nconst { version } = pkg;\n\nconst columns = ref([]);\n\nonMounted(async () =&gt; {\n    try {\n        const result = await getContent({\n            model: \"footer-items\",\n            apiKey: \"121744b9a9944bae8c35aeef88a87ba0\",\n        });\n\n        columns.value = result.data.columns;\n    } catch (e) {\n        console.error(e);\n    }\n});\n</code></pre> <p>After making the changes, the footer will now be fetched from Builder.io and displayed in the vue-b2b-theme.</p> <p>Now you can publish the changes in Builder.io and see the updated footer in the vue-b2b-theme.</p>"},{"location":"integrations/builder-io/index-page-integration/","title":"Overview","text":"<p>In this article, we will integrate Builder.io CMS into the index page of the Virto Commerce vue-b2b-theme. The integration will allow you to create and manage content in Builder.io CMS and display it in the Virto Commerce vue-b2b-theme.</p> <p>To use Builder.io CMS with the page:</p> <ol> <li>Create page model for the index page. The page model defines the properties of the index page and how it is rendered in the Builder.io CMS.</li> <li>Add Builder.io to the page component in the Virto Commerce vue-b2b-theme. This allows you to fetch content from Builder.io and display it in the index page.</li> <li>Create content. Add components to your page model and fill them with content.</li> </ol>"},{"location":"integrations/builder-io/index-page-integration/#create-page-model-in-builderio","title":"Create Page Model in Builder.io","text":"<ol> <li>Go to the Models menu and click Create Model in the top right corner. </li> <li>Select the model type from the dropdown list. We select Page. </li> <li>Enter the name of the component and its description. We enter main page.</li> <li> <p>Change preview URL to http://localhost:YOUR_PORT where YOUR_PORT is the port of your Virto Commerce vue-b2b-theme application.</p> <p></p> </li> <li> <p>Use this model to create the content for our index page. Go to Content menu and click on the main page in Page models section. </p> </li> <li> <p>Click New Entry and select main page model from the dropdown list to create a new page:</p> <p></p> </li> </ol>"},{"location":"integrations/builder-io/index-page-integration/#add-builderio-to-the-page-component","title":"Add Builder.io to the Page Component","text":"<p>To add Builder.io to the page component you need to add <code>RenderContent</code> into your template. As we want totally replace the content of the page with the content from Builder.io, we will use <code>v-if</code> directive to show <code>RenderContent</code> only when content is loaded.</p> TemplateScript client-app/pages/index.vue<pre><code>&lt;template&gt;\n     &lt;div v-if=\"canShowContent\"&gt;\n        &lt;RenderContent model=\"main-page\" :content=\"content\" :api-key=\"apiKey\" :custom-components=\"registeredComponents\" /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre> <p>As you can see we are using <code>main-page</code> as a content ID to fetch the content from Builder.io.</p> client-app/pages/index.vue<pre><code>import { ref, shallowRef } from \"vue\";\nimport { useI18n } from \"vue-i18n\";\nimport { usePageHead } from \"@/core/composables\";\nimport { getContent, RenderContent, isPreviewing } from \"@builder.io/sdk-vue/vue3\";\nimport { useBuilder } from \"@/shared/builder-io/composables/useBuilder\";\n\nconst { t } = useI18n();\nconst { registeredComponents } = useBuilder();\n\nconst canShowContent = shallowRef(true);\n\nconst content = shallowRef(null);\nconst pageNotFound = shallowRef(false);\n\nusePageHead({\n    title: t(\"pages.home.meta.title\"),\n    meta: {\n        keywords: t(\"pages.home.meta.keywords\"),\n        description: t(\"pages.home.meta.description\"),\n    },\n});\n\nonMounted(async () =&gt; {\n    try {\n        const result = await getContent({\n            model: \"main-page\",\n            apiKey: \"121744b9a9944bae8c35aeef88a87ba0\",\n            userAttributes: {\n                urlPath: url,\n            },\n        });\n\n        content.value = result;\n        canShowContent.value = !!content.value || isPreviewing();\n    } catch (e) {\n        pageNotFound.value = true;\n    }\n});\n</code></pre> <p>Now you can preview the index page in the Builder.io and start creating content for it.</p>"},{"location":"integrations/builder-io/index-page-integration/#create-content","title":"Create content","text":"<p>After adding Builder.io to the page component, you can start creating content in the Builder.io CMS. You can create content by adding components to your page model and filling them with content.</p> <p>If you have already added custom components to Builder.io, you can use them to create content for the page. </p> <p> Registering Custom Components</p> <p>As a result, you will get integration of Builder.io CMS with the index page of Virto Commerce vue-b2b-theme:</p> <p></p>"},{"location":"integrations/builder-io/overview/","title":"Builder.io Integration","text":"<p>Builder.io is a headless CMS that provides a visual editor for creating and managing content. The integration with Builder.io allows you to create and manage content in Builder.io and display it in the Virto Commerce Frontend Application. The integration is achieved through the use of the Builder.io API, which allows you to fetch content from Builder.io and display it in the Frontend Application. The integration also provides a way to manage content in Builder.io and update it in the Frontend Application. </p> <p>As long as Virto Frontend Application has native integration with Builder.io, you can start using it right away.</p> <p> Enabling Builder.io</p> <p> Integrating custom components with Builder.io</p> <p> </p> \u2190 Enhancing SEO with Prerender.io  Storyblok  \u2192"},{"location":"integrations/builder-io/overview_outdated/","title":"Builder.io Integration","text":"<p>Builder.io is a headless CMS that provides a visual editor for creating and managing content. The integration with Builder.io allows you to create and manage content in Builder.io and display it in the Virto Commerce vue-b2b-theme. The integration is achieved through the use of the Builder.io API, which allows you to fetch content from Builder.io and display it in the vue-b2b-theme. The integration also provides a way to manage content in Builder.io and update it in the vue-b2b-theme. </p> <p>This guide explores how to integrate Builder.io with the Virto Commerce vue-b2b-theme and provides a practical example of the integration.</p>"},{"location":"integrations/builder-io/overview_outdated/#integrate-with-virto-commerce-vue-b2b-theme","title":"Integrate with Virto Commerce vue-b2b-theme","text":"<p>To integrate with the Virto Commerce vue-b2b-theme:</p> <ol> <li>Create a Builder.io account. Sign up for a free account on the Builder.io website.</li> <li>Create a space in Builder.io. A space is a container for your content, and it allows you to organize and manage your content in Builder.io.</li> <li>Create custom components in Builder.io. This allows you to add existing components from the Virto Commerce vue-b2b-theme to Builder.io and use them to create content.</li> <li>Create content in Builder.io by adding components to your space and filling them with content.</li> <li>Fetch content in the vue-b2b-theme using the Builder.io API. The Builder.io API provides a way to fetch content from Builder.io and display it in the vue-b2b-theme. You can fetch content using Builder.io composable, where you should pass content ID. The Builder.io API returns the content as JSON, which you can then display in the vue-b2b-theme.</li> </ol> <p> Builder.io Documentation</p>"},{"location":"integrations/builder-io/overview_outdated/#connect-builderio-with-virto-commerce-vue-b2b-theme","title":"Connect Builder.io with Virto Commerce vue-b2b-theme","text":"<p>To connect Builder.io with VC vue-b2b-theme:</p> <ol> <li> <p>Install <code>@builder.io/sdk-vue</code>, Builder.io SDK for Vue 3. We use <code>@builder.io/sdk-vue</code> version 0.3.1, as it is more stable and has better compatibility with the Virto Commerce vue-b2b-theme.</p> <pre><code>yarn add @builder.io/sdk-vue@^0.3.1\n</code></pre> </li> <li> <p>Get your Builder.io API token from the Builder.io dashboard (Your space \u2192 Settings \u2192 Public API Key). You will use this key to authenticate your requests to the Builder.io API.</p> </li> <li> <p>To facilitate registration of the custom components, create a composable <code>useBuilder</code>:</p> shared/builder-io/composables/useBuilder.ts<pre><code>const registeredComponents = [];\n\nexport const useBuilder = () =&gt; {\n\n  function registerCustomComponents(components) {\n    for (const [, component] of Object.entries(components)) {\n      registeredComponents.push(component);\n    }\n  }\n\n  return {\n    registeredComponents,\n    registerCustomComponents,\n  };\n};\n</code></pre> </li> </ol>"},{"location":"integrations/builder-io/overview_outdated/#next-steps","title":"Next Steps","text":"<ul> <li>Catalog Menu Integration</li> <li>Category Page Integration</li> <li>Footer Integration</li> <li>Index Page Integration</li> </ul>"},{"location":"integrations/builder-io/registering-custom-components/","title":"Overview","text":"<p>In this article, we will explore how to register any custom component in the Builder.io CMS. The registration of custom components allows you to use any UI components like <code>Slider</code> in the Builder.io CMS when creating content.</p>"},{"location":"integrations/builder-io/registering-custom-components/#register-custom-components","title":"Register Custom Components","text":"<p>To register a custom component in the Builder.io CMS:</p> <ol> <li>Create a reference for the custom component you want to register. The wrapper component should be a .ts file. It describes the inputs\u2014or the props\u2014that should be editable in the Visual Editor.</li> <li>Register the reference using the <code>useBuilder</code> composable which we created here. This will make the custom component available for use in the Builder.io CMS.</li> <li>Provide a list of components to the <code>RenderContent</code> component. This allows you to use the custom components in the Builder.io CMS.</li> </ol>"},{"location":"integrations/builder-io/registering-custom-components/#example-slider-component-registration","title":"Example. Slider Component Registration","text":"<p>In this example, we will show how to register a <code>Slider</code> component in the Builder.io CMS:</p> <ol> <li> <p>Create a reference for the <code>Slider</code> component:</p> @/shared/builder-io/components/custom/slider.ts<pre><code>import Slider from \"../../../static-content/components/slider.vue\";\n\nexport const slider = {\n  component: Slider,\n  name: \"Slider\",\n  inputs: [\n    {\n      name: \"slides\",\n      type: \"list\",\n      defaultValue: [],\n      subFields: [\n        {\n          name: \"image\",\n          type: \"string\",\n        },\n      ],\n    },\n  ],\n};\n</code></pre> </li> <li> <p>Register the <code>slider</code> component with the <code>useBuilder</code> composable:</p> client-app/app-runner.ts<pre><code>import { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport * as builderSharedComponents from \"@/shared/builder-io/components/custom\";\n\nexport default async () =&gt; {\n    // ...\n    const app = createApp(App);\n\n    const { registerCustomComponents } = useBuilder();\n\n    registerCustomComponents(builderSharedComponents);\n\n    app.mount('#app');\n}\n</code></pre> </li> <li> <p>Provide this list of components to the <code>RenderContent</code> component:</p> <pre><code>&lt;template&gt;\n    &lt;RenderContent :custom-components=\"registeredComponents\" /&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { RenderContent } from \"@builder.io/sdk-vue/vue3\";\nimport { useBuilder } from \"@/shared/builder-io/composables/useBuilder\";\n\nconst { registeredComponents } = useBuilder();\n</code></pre> </li> </ol> <p>The Slider component is now registered and available for use in the Builder.io CMS. You can now use the Slider component when creating content in the Builder.io CMS:</p> <p></p>"},{"location":"integrations/google-analytics/ga-events/","title":"Google Analytics Events","text":"<p>Google Analytics is used in the Virto Commerce Frontend Application to track user interactions and provide insights into user behavior. To make these insights more accessible for marketers, several preconfigured events are automatically sent to Google Analytics. You can view and analyze these events through Google Tag Manager (GTM).</p> <p> GA integration</p> <p> Google Tag Manager setup for GA4</p>"},{"location":"integrations/google-analytics/ga-events/#tracked-sales-funnel-events","title":"Tracked sales funnel events","text":"<p>Sales funnel (checkout) events represent sequential steps that guide the customer from the shopping cart to completing the payment. These events help you understand where customers drop off and how efficiently your checkout flow works.</p> <p>After the customer proceeds to checkout, the following events are tracked in the specified order:</p> GA event Action (trigger) Checkout step begin_checkout Click Proceed to checkout. add_shipping_info Click Proceed to billing after specifying the shipping address and delivery method. Shipping. add_payment_info Click Review order after specifying the billing address and the payment method. Billing. place_order Click Place order after reviewing the order. Order review. purchase Click Pay now after selecting the payment method. Payment (unless manual payment was select at the previous step). <p>Note</p> <p>For a single-step checkout, only <code>begin_checkout</code> and <code>place_order</code> are tracked. Other events can be added at the client's request.</p>"},{"location":"integrations/google-analytics/ga-events/#events-beyond-the-checkout-funnel","title":"Events beyond the checkout funnel","text":"<p>Outside the checkout flow, Virto Commerce tracks various interaction events that describe how users search, browse, and interact with products. Unlike sales funnel events, these do not follow a specific order. Instead, they capture actions wherever the user is on the Frontend.</p>"},{"location":"integrations/google-analytics/ga-events/#search-events","title":"Search events","text":"<p>When a user types a query into the search bar and submits it (presses Enter, clicks the magnifying glass icon, or selects View all results), several search-related events are triggered automatically. These events help you analyze:</p> <ul> <li>What users search for.</li> <li>How many results they see.</li> <li>How many items are visible in the suggestions dropdown.</li> <li>Which product lists users view immediately after searching.</li> </ul> <p></p>"},{"location":"integrations/google-analytics/ga-events/#other-frontend-interactions","title":"Other Frontend interactions","text":"<p>The table below shows additional events that track user actions across the Frontend:</p> GA event Action (trigger) Result Location login Submit login form with valid credentials. User is logged into the storefront. Login page.Popup login form. sign_up Submit registration form. User account is created. Registration page.Registration popup. view_item_list Type query into the search bar. Dropdown list appears. Wherever search bar is present. Open product page \u2192 View related products (e.g. Products related to this item, Customers bought together). Related products widgets appear on product page. Related products widget on product page. Open product page \u2192 View variations. Product variations appear on product page. Product variations widget on product page. Open cart \u2192 View recently browsed products. Recently browsed products widget appears on cart page. Recently browsed products widget on cart page. Open product comparison page \u2192 View compared products. The list of products added for comparison appears on product comparison page. Product comparison page. Open catalog \u2192 View products in the catalog. The products from the catalog appear. Catalog. Open lists. The products lists appear. Lists. view_item Open product page. Product page opens. Product page. select_item Go to Catalog \u2192 Select any item from it Product page opens. Catalog Type query into the search bar \u2192 Select product from the dropdown Product page opens. Product page. Go to product page \u2192 Select item from the recommended products Product page opens. Recommended products widgets on product page. Go to product page \u2192 Select item from the related products. Product page opens. Related products widget on product page. Go to cart \u2192 Select item from the recently browsed products. Product page opens. Recently browsed products on cart page. Go to cart page \u2192 Select item from the products list. Product page opens. Product list on cart page. Go to lists \u2192 Select item from the list. Product page opens. Lists. Go to compare page \u2192 Select item from the compared products list. Product page opens. Product comparison page. view_cart Go to Catalog \u2192 Add products to cart \u2192 Open cart. Cart with product opens. Cart. add_to_cart Add products to cart. Products are added to the cart. Cart. remove_from_cart Remove item from cart. Products are removed from cart. Cart clear_cart Click Clear cart. The cart is empty. Cart update_cart_item Change product quantity or options in the cart. Updated item quantity or configuration. Cart. add_to_wishlist Add product to wishlist. The product is added to list. Category page.Product page. view_search_results Submit a search query and open the full search results page. Search results page with matching products appears. Search results page. <p> </p> \u2190 Authentication types  Enhancing SEO with Prerender.io  \u2192"},{"location":"integrations/storyblok/catalog-menu-integration/","title":"Integrate Catalog Menu","text":"<p>In this article, we will integrate Catalog Menu with the Storyblok CMS. The integration will allow you to create and manage catalog navigation links in the Storyblok CMS and display them in the <code>Virto Commerce vue-b2b-theme</code>.</p> <p>With this guide, we will:</p> <ol> <li>Set up and create global component.</li> <li>Create catalog menu block.</li> <li>Create catalog menu content.</li> <li>Fetch content from Storyblok.</li> </ol>"},{"location":"integrations/storyblok/catalog-menu-integration/#set-up-global-component","title":"Set up global component","text":"<p>To set up a folder in Storyblok:</p> <ol> <li> <p>Define a content type for the folder. Let's name it global as it will hold our global components. We should also ensure that the content type in the global folder cannot be changed, so that we only have entries of that type. Additionally, we should select the default content type option so that global is already chosen.</p> <p></p> <p>If you don't have a global content type, create it by clicking on the New content type button.</p> <p></p> </li> <li> <p>Create our first entry within the folder. When creating the entry, ensure that the content type is set to global as we have disabled the ability to change the content type for the folder. You can choose any name for the entry, but make sure it accurately describes the content of the global component to your editors. Since we are creating a Catalog Menu, which is in fact a megamenu, we will name the entry Megamenu.</p> <p></p> </li> <li> <p>Set up the actual field in the entry that holds our component. We will click Define and add a new field called global of the Blocks type.</p> <p></p> </li> </ol>"},{"location":"integrations/storyblok/catalog-menu-integration/#create-catalog-menu-block","title":"Create catalog menu block","text":"<p>To create a new block called megamenu:</p> <ol> <li>Go to the Block Library menu and click New Block in the top right corner. </li> <li>Enter the name of the component. We will enter Megamenu. </li> <li>Add a new field called items of type Blocks.</li> <li> <p>Click Save.</p> <p></p> </li> <li> <p>Since components in Storyblok have a block structure, we need to create blocks for each menu item and each menu link in the same way. For this, we will create the Megamenu-item block and the Megamenu-link-item block of the Nestable block type. The Megamenu-item block structure can be as follows:</p> <p></p> <p>The Megamenu-link-item block structure can be as follows:</p> <p></p> </li> <li> <p>Link all the blocks together to restrict the selection of external blocks that are not related to the megamenu:</p> <ol> <li>Go to the settings of each block to find the entry with the type Blocks in the General section and in the Edit field section.</li> <li>Check Allow only specific components to be inserted.</li> <li> <p>Choose the component that can be nested in this block. In our example, the nesting looks as follows:</p> <pre><code>Megamenu\n    \u2514\u2500\u2500 Megamenu-item\n            \u2514\u2500\u2500 Megamenu-link-item\n</code></pre> <p>Megamenu block configuration can be as follows:</p> <p></p> </li> </ol> </li> </ol> <p>The blocks have been created and their nesting has been configured.</p>"},{"location":"integrations/storyblok/catalog-menu-integration/#create-catalog-menu-content","title":"Create catalog menu content","text":"<p>To create the content for our Catalog Menu:</p> <ol> <li>Go to the Content menu and click on the Megamenu entry we created earlier. </li> <li> <p>Click on the Add Block button and select the Megamenu block.</p> <p></p> </li> <li> <p>Add the Megamenu-item block.</p> </li> <li>Add the Megamenu-link-item block. </li> <li>Fill in the necessary fields for each block.</li> <li>Click Save to save the changes.</li> </ol>"},{"location":"integrations/storyblok/catalog-menu-integration/#fetch-content-from-storyblok-and-display-in-vue-b2b-theme","title":"Fetch content from Storyblok and display in vue-b2b-theme","text":"<p>To fetch content from Storyblok and display it in the vue-b2b-theme:</p> <ol> <li>Go to the vue-b2b-theme and edit the <code>useNavigations</code> composable. Change the <code>fetchCatalogMenu</code> method to fetch the Catalog Menu from Storyblok. </li> <li>Replace the <code>getMenu</code> method call with the <code>useStoryblok</code> method call.</li> <li> <p>Pass the path to our menu.</p> client-app/core/composables/useNavigations.ts<pre><code>export function useNavigations() {\n    // ...\n    async function fetchCatalogMenu() {\n    // ...\n\n    try {\n    if (catalog_menu_link_list_name) {\n\n        // Commented out the old method of fetching the catalog menu\n        // catalogMenuItems.value = (await getMenu(catalog_menu_link_list_name)).map((item) =&gt;\n        //   convertToExtendedMenuLink(item, true),\n        // );\n\n        // Get catalog menu from Storyblok\n        catalogMenuItems.value = (\n        await useStoryblok(\"global/megamenu\", { version: \"draft\" })\n        ).value.content.global.find((x: any) =&gt; x.component === \"Megamenu\")?.items;\n\n    } else {\n        // ...\n    }\n    }\n    // ...\n}\n// ...\n}\n</code></pre> </li> </ol> <p>The Catalog Menu is now fetched from Storyblok and displayed in the vue-b2b-theme:</p> <p></p> <p>You can publish the changes and see the Catalog Menu in the vue-b2b-theme.</p> <p> </p> \u2190 Storyblok overview  Category page integration  \u2192"},{"location":"integrations/storyblok/category-page-integration/","title":"Integrate Category Page","text":"<p>In this article, we will integrate Storyblok CMS into the category page of the Virto Commerce vue-b2b-theme. The integration will allow you to create and manage content in Storyblok CMS and display it in the Virto Commerce vue-b2b-theme.</p> <p>To use Storyblok CMS with the page:</p> <ol> <li>Create page model in the Storyblok CMS for the category page. The page model defines the properties of the category page and how it is rendered in the Storyblok CMS.</li> <li>Add Storyblok to the page component in Virto Commerce vue-b2b-theme. This allows you to fetch content from Storyblok and display it in the category page.</li> <li>Create content in the Storyblok CMS. Add components to your page model and fill them with content.</li> </ol>"},{"location":"integrations/storyblok/category-page-integration/#create-page-model-in-storyblok","title":"Create Page Model in Storyblok","text":"<p>To create Page Model in Storyblok:</p> <ol> <li>Go to the Block Library menu and click New Block in the top right corner. </li> <li>Enter the name of the component. We enter Catalog as the name. </li> <li>Add a new field called body of type Blocks and showSidebar of type Boolean. This will allow you to hide the sidebar if needed. </li> <li> <p>Click Save to save the changes.</p> <p></p> </li> <li> <p>Use this block to create the content for our category page: Go to the Content menu and click on the Create new to create new Story with previously created Catalog block:</p> <p></p> </li> </ol>"},{"location":"integrations/storyblok/category-page-integration/#add-storyblok-to-page-component","title":"Add Storyblok to Page Component","text":"<p>To integrate Storyblok with the category page:</p> <ol> <li> <p>Create new landing-page.vue component in the client-app/shared folder:</p> TemplateScript client-app/shared/landing-page.vue<pre><code>&lt;template&gt;\n    &lt;div&gt;\n        &lt;template v-if=\"story\"&gt;\n            &lt;StoryblokComponent v-for=\"blok in story?.content?.body\" :key=\"blok._uid\" :blok=\"blok\" /&gt;\n        &lt;/template&gt;\n        &lt;slot v-bind=\"story?.content\" key=\"catalog\"&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre> client-app/shared/landing-page.vue<pre><code>import { useStoryblok } from \"@storyblok/vue\";\nimport { onBeforeMount, ref, toValue } from \"vue\";\nimport { onBeforeRouteUpdate } from \"vue-router\";\n\nconst story = ref({});\n\nonBeforeMount(async () =&gt; {\n    await tryLoadContent(window.location.pathname);\n});\n\nonBeforeRouteUpdate(async (to) =&gt; {\n    await tryLoadContent(to.fullPath);\n});\n\nasync function tryLoadContent(urlPath: string) {\n    story.value = toValue(await useStoryblok(urlPath, { version: \"draft\" }));\n}\n</code></pre> </li> <li> <p>Add the landing-page.vue component to the matcher.vue component as a wrapper and pass slot props <code>storyblokProps</code> to <code>Category</code> component:</p> client-app/pages/matcher.vue<pre><code>&lt;template&gt;\n&lt;LandingPage&gt;\n    &lt;template #default=\"storyblokProps\"&gt;\n    &lt;component\n        :is=\"Category\"\n        v-if=\"seoInfo?.entity?.objectType === 'Category'\"\n        :category-id=\"seoInfo?.entity?.objectId\"\n        v-bind=\"storyblokProps\"\n    /&gt;\n    &lt;component\n        :is=\"Product\"\n        v-else-if=\"seoInfo?.entity?.objectType === 'CatalogProduct'\"\n        :product-id=\"seoInfo?.entity?.objectId\"\n    /&gt;\n\n    &lt;component :is=\"StaticPage\" v-else-if=\"seoInfo?.page\" /&gt;\n\n    &lt;NotFound v-else-if=\"!loading\" /&gt;\n    &lt;/template&gt;\n&lt;/LandingPage&gt;\n&lt;/template&gt;\n</code></pre> </li> <li> <p>As we want to use <code>showSidebar</code> property to control sidebar visibility, we change the <code>category.vue</code> component to use props from <code>matcher.vue</code> and add <code>v-if</code> condition on <code>sidebar</code> section.</p> client-app/shared/catalog/components/category.vue<pre><code>&lt;template&gt;\n    &lt;!-- Sidebar --&gt;\n    &lt;div class=\"flex items-stretch lg:gap-6\"&gt;\n        &lt;template v-if=\"showSidebar\"&gt;\n\n        &lt;!-- Sidebar template --&gt;\n\n        &lt;/template&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre> client-app/shared/catalog/components/category.vue<pre><code>interface IProps {\ncategoryId?: string;\nisSearchPage?: boolean;\nshowSidebar?: boolean;\n}\n\nconst props = withDefaults(defineProps&lt;IProps&gt;(), {\nshowSidebar: true,\n});\n</code></pre> </li> </ol> <p>Now you can preview the category page in the Storyblok and start creating content for it.</p>"},{"location":"integrations/storyblok/category-page-integration/#create-content","title":"Create content","text":"<p>After adding Storyblok to the category page component, start creating content in the Storyblok CMS. Add components to your page model and fill them with content.</p> <p>If you have already added custom components to Storyblok, use them to create content for the page. </p> <p> Registering Custom Components</p> <p>As a result, you will get integration of Storyblok CMS with the category page of Virto Commerce vue-b2b-theme:</p> <p></p> <p> </p> \u2190 Catalog menu integration  Footer integration  \u2192"},{"location":"integrations/storyblok/footer-integration/","title":"Overview","text":"<p>In this article, we will integrate footer with the Storyblok CMS. The integration will allow you to create and manage footer sections and navigation links in the Storyblok CMS and display them in the Virto Commerce vue-b2b-theme.</p> <p>With this guide, we will:</p> <ol> <li>Set up and create global component.</li> <li>Create footer block.</li> <li>Create footer content.</li> <li>Fetch Content from Storyblok.</li> </ol>"},{"location":"integrations/storyblok/footer-integration/#set-up-global-component","title":"Set up global component","text":"<p>To set up a folder in Storyblok:</p> <ol> <li> <p>Define a content type for the folder. Let's name it global as it will hold our global components. We should also ensure that the content type in the global folder cannot be changed, so that we only have entries of that type. Additionally, we should select the default content type option so that global is already chosen.</p> <p></p> <p>If you don't have a global content type, create it by clicking on the New content type button.</p> <p></p> </li> <li> <p>Create our first entry within the folder. When creating the entry, ensure that the content type is set to global as we have disabled the ability to change the content type for the folder. You can choose any name for the entry, but make sure it accurately describes the content of the global component to your editors. Since we are creating a footer, we will name the entry Footer.</p> <p></p> </li> <li> <p>Set up the actual field in the entry that holds our component. We will click Define and add a new field called global of the Blocks type.</p> <p></p> </li> </ol>"},{"location":"integrations/storyblok/footer-integration/#create-footer-block","title":"Create footer block","text":"<p>To create a new block called footer:</p> <ol> <li>Go to the Block Library menu and click New Block in the top right corner. </li> <li>Enter the name of the component. We will enter Footer. </li> <li>Add a new field called items of type Blocks.</li> <li> <p>Click Save.</p> <p></p> </li> <li> <p>Since components in Storyblok have a block structure, we need to create blocks for each menu item and each menu link in the same way. For this, we will create the footer_item block and the footer_item_link block of the Nestable block type. The footer_item block structure can be as follows:</p> <p></p> <p>The footer_item_link block structure can be as follows:</p> <p></p> </li> <li> <p>Link all the blocks together to restrict the selection of external blocks that are not related to the footer:</p> <ol> <li>Go to the settings of each block to find the entry with the type Blocks in the General section and in the Edit field section.</li> <li>Check Allow only specific components to be inserted.</li> <li> <p>Choose the component that can be nested in this block. In our example, the nesting looks as follows:</p> <pre><code>Footer\n    \u2514\u2500\u2500 footer_item\n            \u2514\u2500\u2500 footer_item_link\n</code></pre> <p>Footer block configuration can be as follows:</p> <p></p> </li> </ol> </li> </ol> <p>The blocks have been created and their nesting has been configured.</p>"},{"location":"integrations/storyblok/footer-integration/#create-footer-content","title":"Create footer content","text":"<p>To create the content for our Footer:</p> <ol> <li>Go to the Content menu and click on the Footer entry we created earlier. </li> <li> <p>Click on the Add Block button and select the Footer block.</p> <p></p> </li> <li> <p>Add the footer_item block.</p> </li> <li>Add the footer_item_link block. </li> <li>Fill in the necessary fields for each block.</li> <li>Click Save to save the changes.</li> </ol>"},{"location":"integrations/storyblok/footer-integration/#fetch-content-from-storyblok-and-display-in-vue-b2b-theme","title":"Fetch content from Storyblok and display in vue-b2b-theme","text":"<p>To fetch content from Storyblok and display it in the vue-b2b-theme, go to the vue-b2b-theme and edit the vc-footer component. Remove hard-coded columns and change it to the fetched ones.</p> <p>The final vc-footer component looks as follows:</p> TemplateScript <pre><code>&lt;template&gt;\n    &lt;footer aria-label=\"Footer\"&gt;\n        &lt;!-- Top footer --&gt;\n        &lt;div\n        v-if=\"!compact\"\n        class=\"hidden bg-[color:var(--color-footer-top-bg)] text-[color:var(--color-footer-top-text)] md:block print:!hidden\"\n        &gt;\n        &lt;div class=\"container mx-auto grid grid-cols-2 gap-4 p-12 lg:grid-cols-4 xl:grid-cols-5\"&gt;\n            &lt;!-- Logo column --&gt;\n            &lt;div class=\"hidden xl:block\"&gt;\n            &lt;VcImage :src=\"$cfg.logo_inverted_image\" :alt=\"$context.storeName\" class=\"h-9\" lazy /&gt;\n            &lt;/div&gt;\n\n            &lt;div v-for=\"(col, index) in columns\" :key=\"index\"&gt;\n            &lt;div v-t=\"col.title\" class=\"mb-3 text-base font-extrabold uppercase text-white\"&gt;&lt;/div&gt;\n            &lt;div class=\"flex flex-col space-y-1\"&gt;\n                &lt;FooterLink\n                v-for=\"(link, linkIndex) in col.links\"\n                :key=\"`link_${linkIndex}`\"\n                v-t=\"link.title\"\n                :to=\"link.link\"\n                &gt;&lt;/FooterLink&gt;\n            &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;!-- Bottom footer --&gt;\n        &lt;!-- ... --&gt;\n    &lt;/footer&gt;\n&lt;/template&gt;\n</code></pre> client-app/shared/layout/components/footer/vc-footer.vue<pre><code>import { useStoryblok } from \"@storyblok/vue\";\nimport pkg from \"../../../../../package.json\";\nimport FooterLink from \"./_internal/footer-link.vue\";\nimport { onMounted, ref } from \"vue\";\n\ninterface IProps {\n    compact?: boolean;\n}\n\ndefineProps&lt;IProps&gt;();\n\nconst { version } = pkg;\n\nconst columns = ref([]);\n\nonMounted(async () =&gt; {\n    columns.value =\n        (await useStoryblok(\"global/footer\", { version: \"draft\" })).value.content.global.find(\n        (x: any) =&gt; x.component === \"Footer\",\n        )?.items ?? [];\n});\n</code></pre> <p>After making the changes, the footer will now be fetched from Storyblok and displayed in the vue-b2b-theme:</p> <p></p> <p>Now you can publish the changes in Storyblok and see the updated footer in the vue-b2b-theme.</p> <p> </p> \u2190 Category page integration  Index page integration  \u2192"},{"location":"integrations/storyblok/index-page-integration/","title":"Integrate Index Page","text":"<p>In this article, we will integrate Storyblok CMS into the index page of the Virto Commerce vue-b2b-theme. The integration will allow you to create and manage content in Storyblok CMS and display it in the Virto Commerce vue-b2b-theme.</p> <p>To use Storyblok CMS with the page:</p> <ol> <li>Create page model in the Storyblok CMS for the index page. The page model defines the properties of the index page and how it is rendered in the Storyblok CMS.</li> <li>Add Storyblok to the page component in Virto Commerce vue-b2b-theme. This allows you to fetch content from Storyblok and display it in the index page.</li> <li>Create content. Add components to your page model and fill them with content.</li> </ol>"},{"location":"integrations/storyblok/index-page-integration/#create-page-model-in-storyblok","title":"Create page model in Storyblok","text":"<p>To create Page Model in Storyblok:</p> <ol> <li>Go to the Block Library menu and click New Block in the top right corner. </li> <li>Enter the name of the component. We enter Main_page as the name. </li> <li>Add a new field called body of type Blocks. </li> <li> <p>Click Save to save the changes.</p> <p></p> </li> <li> <p>Use this block to create the content for our category page: Go to the Content menu and click on the Create new to create new Story with previously created Catalog block:</p> <p></p> </li> </ol>"},{"location":"integrations/storyblok/index-page-integration/#add-storyblok-to-page-component","title":"Add Storyblok to Page Component","text":"<p>To add Storyblok to the page component, add <code>StoryblokComponent</code> into your template. As long as we want replace the content of the page with the content from Storyblok, we use <code>v-if</code> directive to show <code>StoryblokComponent</code> only when <code>story</code> is loaded.</p> TemplateScript client-app/pages/index.vue<pre><code>&lt;template&gt;\n    &lt;div v-if=\"story\"&gt;\n        &lt;StoryblokComponent v-for=\"(blok, index) in story?.content?.body\" :blok=\"blok\" :key=\"blok._uid\" /&gt;\n    &lt;/div&gt;\n    &lt;div v-else-if=\"loading\" class=\"min-h-[80vh]\"&gt;\n        &lt;VcLoaderOverlay /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre> <p>As you can see we are using <code>main-page</code> as a content ID to fetch the content from Storyblok.</p> client-app/pages/index.vue<pre><code>import { ref, toValue } from \"vue\";\nimport { useI18n } from \"vue-i18n\";\nimport { usePageHead } from \"@/core/composables\";\nimport { useStoryblok } from \"@storyblok/vue\";\n\nconst { t } = useI18n();\n\nusePageHead({\n    title: t(\"pages.home.meta.title\"),\n    meta: {\n        keywords: t(\"pages.home.meta.keywords\"),\n        description: t(\"pages.home.meta.description\"),\n    },\n});\n\nconst story = ref({});\n\nonBeforeMount(async () =&gt; {\ntry {\n    loading.value = true;\n    story.value = toValue(await useStoryblok(\"main-page\", { version: \"draft\" }));\n} finally {\n    loading.value = false;\n}\n});\n</code></pre> <p>Now you can preview the index page in the Storyblok and start creating content for it.</p>"},{"location":"integrations/storyblok/index-page-integration/#create-content","title":"Create content","text":"<p>After adding Storyblok to the page component, start creating content in the Storyblok CMS. Add components to your page model and fill them with content.</p> <p>Note</p> <p>Since the index page uses the path <code>/</code>, and Storyblok uses its own slugs for previews, you need to change the Real path in the space settings to <code>/</code>.</p> <p></p> <p>If you have already added custom components to Storyblok, use them to create content for the page. </p> <p> Registering Custom Components</p> <p>As a result, you will get integration of Storyblok CMS with the index page of Virto Commerce vue-b2b-theme:</p> <p></p> <p> </p> \u2190 Footer integration  Registering custom components  \u2192"},{"location":"integrations/storyblok/overview/","title":"Storyblok Integration","text":"<p>Storyblok is a headless CMS that provides a visual editor for creating and managing content. The integration with Storyblok allows you to create and manage content in Storyblok and display it in the Frontend Application.</p> <p></p> <p>The integration is achieved through the use of the Storyblok API, which allows you to fetch content from Storyblok and display it in the Frontend Application. The integration also provides a way to manage content in Storyblok and update it in the Frontend Application. This guide explores how to integrate Storyblok with the Virto Commerce Frontend Application and provides a practical example of the integration.</p>"},{"location":"integrations/storyblok/overview/#integrate-with-virto-commerce-frontend-application","title":"Integrate with Virto Commerce Frontend Application","text":"<p>To integrate with Virto Commerce Frontend Application:</p> <ol> <li>Create a Storyblok account. Sign up for a free account on the Storyblok website.</li> <li>Create a space in Storyblok. A space is a container for your content, and it allows you to organize and manage your content in Storyblok.</li> <li>Create custom components in Storyblok. This allows you to add existing components from the Frontend Application to Storyblok and use them to create content.</li> <li>Create content in Storyblok. Add components to your space and fill them with content.</li> <li>Fetch content in the Frontend Application using the Storyblok API. The Storyblok API provides a way to fetch content from Storyblok and display it in the Frontend Application. You can fetch content using Storyblok composable, where you should pass content ID. The Storyblok API returns the content as JSON, which you can then display in the Frontend Application.</li> </ol> <p> Storyblok documentation</p>"},{"location":"integrations/storyblok/overview/#connect-storyblok-with-virto-commerce-frontend-application","title":"Connect Storyblok with Virto Commerce Frontend Application","text":"<ol> <li> <p>Install <code>@storyblok/vue</code>, Storyblok SDK for Vue 3:</p> <pre><code>yarn add @storyblok/vue\n</code></pre> </li> <li> <p>Get your Storyblok API token from the Storyblok dashboard ( Your space \u2192 Settings \u2192 Access Tokens).</p> </li> <li> <p>Use the API token in <code>client-app/app-runner.ts</code> as follows:</p> client-app/app-runner.ts<pre><code>import { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport { StoryblokVue, apiPlugin } from \"@storyblok/vue\";\n\nexport default async () =&gt; {\n    // ...\n    const app = createApp(App);\n\n    app.use(StoryblokVue, {\n        accessToken: \"27ZV5dT9mXG6tEbHraoJSwtt\",\n        use: [apiPlugin],\n    });\n\n    app.mount('#app');\n}\n</code></pre> </li> </ol> <p> Add a headless CMS to VueJS in 5 minutes</p> <p> </p> \u2190 Builder.io  Catalog menu integration  \u2192"},{"location":"integrations/storyblok/registering-custom-components/","title":"Register Custom Components","text":"<p>In this article, we will explore how to register any custom component in the Storyblok CMS. The registration of custom components allows you to use any UI components like Slider in the Storyblok CMS when creating content.</p> <p>To register a custom component in the Storyblok CMS:</p> <ol> <li>Create a wrapper component for the custom component you want to register. The wrapper component should be a Vue component that renders the custom component.</li> <li>Register the component as a global component in your application. This will make the custom component available for use in the Storyblok CMS.</li> <li>Create component model in Storyblok for the custom component. The component model should define the properties of the custom component and how it should be rendered in the Storyblok CMS.</li> </ol>"},{"location":"integrations/storyblok/registering-custom-components/#example-slider-component-registration","title":"Example. Slider component registration","text":"<p>In this example, we will show how to register a <code>Slider</code> component in the Storyblok CMS:</p> <ol> <li> <p>Create a wrapper component for the <code>Slider</code> component:</p> StorySlider.vue<pre><code>&lt;template&gt;\n&lt;template v-if=\"blok\"&gt;\n    &lt;Slider :id=\"blok?.id\" v-editable=\"blok\" :slides=\"blok?.slides ?? []\"&gt;&lt;/Slider&gt;\n&lt;/template&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { default as Slider } from \"@/shared/static-content/components/slider.vue\";\n\ndefineProps({ blok: Object });\n&lt;/script&gt;\n</code></pre> </li> <li> <p>Register the <code>StorySlider</code> component as a global component in your application:</p> client-app/app-runner.ts<pre><code>import { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport { StoryblokVue, apiPlugin } from \"@storyblok/vue\";\n\nexport default async () =&gt; {\n    // ...\n    const app = createApp(App);\n\n    app.use(StoryblokVue, {\n        accessToken: \"27ZV5dT9mXG6tEbHraoJSwtt\",\n        use: [apiPlugin],\n    });\n\n    // Register your wrapper component\n    app.component(\"StorySlider\", StorySlider);\n\n    app.mount('#app');\n}\n</code></pre> </li> </ol>"},{"location":"integrations/storyblok/registering-custom-components/#create-component-model-in-storyblok","title":"Create component model in Storyblok","text":"<p>To create component model in Storyblok:</p> <ol> <li>Go to the Block Library menu and click New Block in the top right corner. </li> <li>Enter the name of the component. We will enter StorySlider. </li> <li>Add a new field called slides of type Blocks.</li> <li> <p>Click Save.</p> <p></p> </li> <li> <p>Since components in Storyblok have a block structure, we need to create blocks for each single slide the same way. For this, we will create the slide block of the Nestable block type. The slide block structure can be as follows:</p> <p></p> </li> <li> <p>Link all the blocks together to restrict the selection of external blocks that are not related to the StorySlider:</p> <ol> <li>Go to the settings of the StorySlider to find the entry slides with the type Blocks in the General section and in the Edit field section.</li> <li>Check Allow only specific components to be inserted.</li> <li> <p>Choose the component that can be nested in this block - slide. In our example, the nesting looks as follows:</p> <pre><code>StorySlider\n    \u2514\u2500\u2500 slide\n</code></pre> <p>StorySlider block configuration can be as follows:</p> <p></p> </li> </ol> </li> </ol> <p>Now you can add it to the Content page to create a new StorySlider block!</p> <p> </p> \u2190 Index page integration"},{"location":"modules-architecture/modules-architecture/","title":"Modules Architecture","text":"<p>This document provides an overview of the Virto Commerce Frontend modules architecture. The modular approach provides:</p> <ul> <li>Scalability: Easily add new features without affecting existing ones.  </li> <li>Maintainability: Isolated codebases simplify management and debugging.  </li> <li>Modularity: Modules in the /modules folder can be removed without affecting the Core.  </li> <li>Control: Decision-makers have clear oversight.  </li> </ul>"},{"location":"modules-architecture/modules-architecture/#key-concepts","title":"Key concepts","text":"<p>The key concepts of modules architecture are as follows:</p> Concept Description Core The main application that includes the API, router, builder, and other systems. Module An additional functionality developed with minimal impact on the Core. It is a self-contained feature area within the application. Each module encapsulates its own components, services, APIs, and other related code. Extensions Extension points that belong to the Core, also called holes or sockets.  Existing extensions:  - client-app/shared/common/composables/useCustomProductComponents.ts  - client-app/shared/layout/composables/useCustomAccountLinkComponents.ts  - client-app/shared/layout/composables/useCustomMobileMenuLinkComponents.ts  - client-app/shared/layout/composables/useCustomHeaderLinkComponents.ts  - client-app/shared/layout/composables/useCustomMobileHeaderComponents.ts Module management system A decision-making point and business logic handler. It is represented as settings_data.json at the bundle level and as an array of modules in the getStore request at the store level. It can be considered a form of Feature flags. Type generation system Handles the generation of types and constants for GraphQL API. <p></p>"},{"location":"modules-architecture/modules-architecture/#module-folder-structure","title":"Module folder structure","text":"<p>A well-structured module ensures clarity and ease of maintenance. Below is the recommended module structure:</p> <pre><code>your-module/\n\u251c\u2500\u2500 api/                    // All API-related code, including GraphQL schemas and generated types. \n\u2502   \u251c\u2500\u2500 graphql/\n\u2502   \u2502   \u2514\u2500\u2500 types.ts\n\u251c\u2500\u2500 components/             // Vue components specific to the module.\n\u2502   \u2514\u2500\u2500 YourComponent.vue\n\u251c\u2500\u2500 composables/            // Vue composables (hooks) for shared logic within the module\n\u2502   \u2514\u2500\u2500 useYourFeature.ts\n\u251c\u2500\u2500 pages/                  // Module-specific pages that integrate with the application's routing.\n\u2502   \u251c\u2500\u2500 YourModulePage.vue\n\u2502   \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 localization/           // Localization files for supporting multiple languages.\n\u2502   \u251c\u2500\u2500 en.json\n\u2502   \u2514\u2500\u2500 de.json\n\u251c\u2500\u2500 types/                  // TypeScript interfaces and types for the module.\n\u2502   \u2514\u2500\u2500 index.ts\n\u2514\u2500\u2500 index.ts                // Entry point exporting public APIs (mainly init function).\n</code></pre>"},{"location":"modules-architecture/modules-architecture/#type-generation-system","title":"Type generation system","text":"<p>Each module typically includes its own GraphQL types, often defined in a types.ts file within an api/graphql folder. These types are generated using the following npm command:</p> <pre><code>yarn generate:graphql-types\n</code></pre> <p>This command triggers the execution of the generator.ts script, which is responsible for generating the types.ts files for both the core application and the independent modules.</p> <p>The scripts/graphql-codegen/generator.ts file also plays a crucial role in handling standalone GraphQL schemas. It includes an array called independentModules, where each object represents a separate GraphQL schema that needs to be generated independently:</p> <pre><code>{\n    name: \"YourModule\",\n    apiPath: \"client-app/modules/your-module/api/graphql\",\n    schemaPath: `${process.env.APP_BACKEND_URL}/graphql/your-module`,\n},\n</code></pre>"},{"location":"modules-architecture/modules-architecture/#routes-registration","title":"Routes registration","text":"<p>Modules register their routes through the init function within the module. This function is called during the application's initialization phase, typically in the app-runner.ts.</p> <p>Each module should export an init function that accepts the router and other necessary dependencies (e.g., i18n).</p> <pre><code>// modules/your-module/index.ts\nimport { Router } from \"vue-router\";\nimport { I18n } from \"@/i18n\";\n\n// Define your components\nconst YourModulePage = () =&gt; import(\"./pages/YourModulePage.vue\");\n// By using () =&gt; import('./pages/YourModulePage.vue'), you ensure that Vue Router can handle the component as a lazy-loaded route, which is the intended usage pattern.\n\nexport async function init(router: Router, i18n: I18n): Promise&lt;void&gt; {\n  const route = {\n    path: \"/your-module\",\n    name: \"YourModule\",\n    component: YourModulePage,\n    beforeEnter(to: any, from: any, next: Function) {\n      // Add any route guards or logic here\n      next();\n    },\n  };\n\n  router.addRoute(route);\n}\n</code></pre> Example of initialization function usage <p>To integrate a module into the main application, you need to import the module's init function and call it within the app's runner. Below is an example of how to do this:</p> <pre><code>// client-app/app-runner.ts\n\n// Import the module's init function\nimport { init as initYourModule } from \"@/modules/your-module\";\n\n...\n\ninitYourModule(router, i18n);\n</code></pre>"},{"location":"modules-architecture/modules-architecture/#best-practices","title":"Best practices","text":"<p>To ensure consistency and high quality across all modules, follow these best practices:</p> <ul> <li> <p>Consistent structure:</p> <ul> <li>Adhere to the recommended folder structure.</li> <li>Keep related files grouped together.</li> </ul> </li> <li> <p>Isolate module logic:</p> <ul> <li>Avoid cross-module dependencies unless necessary.</li> <li>Use the module's composables for shared logic.</li> </ul> </li> <li> <p>Type safety:</p> <ul> <li>Define clear TypeScript types in the types/ directory.</li> <li>Ensure all API interactions use generated GraphQL types.</li> </ul> </li> <li> <p>Documentation:</p> <ul> <li>Document public APIs, components, and composables.</li> <li>Keep the README.md updated with relevant information.</li> </ul> </li> <li> <p>Naming conventions:</p> <ul> <li>Use clear and descriptive names for files and functions.</li> <li>Follow the project's naming guidelines.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Write unit and integration tests for module functionalities.</li> <li>Ensure tests are located alongside the code they test.</li> </ul> </li> </ul> <p>Happy coding! \ud83d\ude80</p> <p> </p> \u2190 Frontend application architecture SPA architecture for SEO and 404 handling \u2192"},{"location":"vue-js-starter-theme/getting-started/","title":"Getting Started","text":"<p>In this guide, we will explore the necessary steps to get started with the Virto Commerce platform.</p>"},{"location":"vue-js-starter-theme/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Install latest version of vc-platform 3.x. </p> <ul> <li>On Windows</li> <li>On macOS</li> <li>On Linux</li> </ul> </li> <li> <p>Install the xAPI module.</p> </li> <li>Install the Profile xAPI module module.</li> <li>Install Node v.16.X</li> <li>Install yarn package manager.</li> </ul> <pre><code>npm install --global yarn\n</code></pre> <p>Warning</p> <p>Node.js and Yarn have been recently updated. If you wish to upgrade:</p> <ol> <li>Install Node.js v20.</li> <li> <p>Enable corepack (run from administrator on Windows):</p> <pre><code>corepack enable\n</code></pre> </li> </ol> <p>If you have installed <code>yarn</code> globally, uninstall it:</p> <ol> <li> <p>Using npm:</p> <pre><code>npm uninstall --global yarn\n</code></pre> </li> <li> <p>Or using your native Operation System installation tools.</p> </li> </ol>"},{"location":"vue-js-starter-theme/getting-started/#install-vc-storefront","title":"Install vc-storefront","text":"<p>To install vc-storefront:</p> <ol> <li>Clone vc-storefront to a local folder.</li> <li>Open the appsettings.json file in a text editor.</li> <li> <p>In the Endpoint section, replace Url, UserName, Password with correct path and credentials for Virto Commerce Platform:</p> <pre><code>...\n    \"Endpoint\": {\n        \"Url\": \"https://localhost:5001\",\n        \"UserName\": \"admin\",\n        \"Password\": \"store\",\n...\n</code></pre> </li> </ol>"},{"location":"vue-js-starter-theme/getting-started/#run-vc-storefront","title":"Run vc-storefront","text":"<p>To run the vc-storefront application, execute the following commands:</p> <pre><code># change the current directory\ncd C:\\vc-storefront\\VirtoCommerce.Storefront\n# build and run storefront application\ndotnet run\n# In future, if you don't need to rebuild you can use that\ndotnet run --no-build\n</code></pre>"},{"location":"vue-js-starter-theme/getting-started/#setup-urrent-theme","title":"Setup \u0421urrent Theme","text":"<p>To set up the current theme for your storefront, execute the following commands:</p> <pre><code># Clone repo into the folder where storefront is installed\n# `store-code` can be found in the platform running locally. More -&gt; Shops -&gt; Shop Name -&gt; Code\ngit clone https://github.com/VirtoCommerce/vc-theme-b2b-vue.git \"C:\\vc-storefront\\VirtoCommerce.Storefront\\wwwroot\\cms-content\\themes\\{store-code}\\default\"\n# Change the current directory\ncd C:\\vc-storefront\\VirtoCommerce.Storefront\\VirtoCommerce.Storefront\\wwwroot\\cms-content\\themes\\{store-code}\\default\n# install dependencies\nyarn install\n</code></pre>"},{"location":"vue-js-starter-theme/getting-started/#for-visual-studio-code-users","title":"For Visual Studio Code Users","text":"<p>If you're using Visual Studio Code:</p> <ol> <li>Setup recommended extensions.</li> <li>Configure Volar Takeover mode.</li> </ol>"},{"location":"vue-js-starter-theme/getting-started/#development-workflow","title":"Development Workflow","text":"<p>Let's explore the development workflow and various commands you can use during development.</p>"},{"location":"vue-js-starter-theme/getting-started/#compile-and-hot-reload-for-development","title":"Compile and Hot-Reload for Development","text":"<ol> <li>Open the .env file in a text editor.</li> <li> <p>Change APP_BACKEND_URL to the correct endpoint to <code>vc-storefront</code>:</p> <pre><code># .env file\nAPP_BACKEND_URL=https://localhost:2083\n</code></pre> </li> <li> <p>Run command: <code>yarn dev</code> or <code>yarn dev-expose</code>.</p> </li> <li>Follow the link in the terminal</li> </ol>"},{"location":"vue-js-starter-theme/getting-started/#type-check-compile-and-minify-for-production","title":"Type-Check, Compile, and Minify for Production","text":"<pre><code>yarn build\n</code></pre>"},{"location":"vue-js-starter-theme/getting-started/#compile-and-minify-in-development-mode","title":"Compile and Minify in Development mode","text":"<pre><code>yarn build:dev\n</code></pre>"},{"location":"vue-js-starter-theme/getting-started/#compile-and-minify-in-development-mode-with-change-tracking","title":"Compile and Minify in Development mode with change tracking","text":"<pre><code>yarn build:watch\n</code></pre>"},{"location":"vue-js-starter-theme/getting-started/#compile-to-get-the-artifact-to-install","title":"Compile to get the artifact to install","text":"<pre><code>yarn compress\n</code></pre>"},{"location":"vue-js-starter-theme/overview/","title":"Overview","text":"<p>vc-theme-b2b-vue is a fresh look in the field of ecommerce solutions. This is a place where common B2B and B2C scenarios are combined with the most bleeding edge technologies to deliver blazing fast and fully functional solutions.</p> <p>This theme represents the VC Team's opinionated starting point for new projects. It strives to include up-to-date best practices and solutions that we have deemed needed for the majority of projects we build. It is a reflection of what is possible when building a theme.</p> <p>Our Vue.js Starter Theme has an adaptive design that allows it to look smooth and natural on both desktop and mobile:</p> <p></p>"},{"location":"vue-js-starter-theme/overview/#technologies-and-frameworks-used","title":"Technologies and Frameworks Used","text":"<ul> <li> <p>Vue3: Progressive frontend framework with its key features allowing one to build fast applications.</p> </li> <li> <p>TypeScript: All components and composables have type definitions, so that IDE could help you build clean and working code.</p> </li> <li> <p>TailwindCSS: The most popular and growing CSS framework providing wonderful flexible structure to speed up styling.</p> </li> <li> <p>Husky + ESLint + Prettier: Autoformat, check, and fix your code and prevent ugly code style within repository.</p> </li> <li> <p>Vite: Faster than Webpack, it is used to develop code with HMR benefits and build for production.</p> </li> <li> <p>GraphQL : Use flexible GraphQL queries and mutations to safely work with back end.</p> </li> </ul>"},{"location":"vue-js-starter-theme/overview/#key-non-functional-capabilities","title":"Key Non-functional Capabilities","text":"<ul> <li> <p>Development performance: Thanks to maximum reusing of exciting developer experience, such as server side functionality, web components and views, and ready made theme architecture, the risk of wrong design decisions for new projects is drastically reduced.</p> </li> <li> <p>Client performance: We are supposed to reach and hold green metrics provided by Google PageSpeed Insights.</p> </li> <li> <p>Decoupled structure: Presentation layer is decoupled from back end. Shared logic is decoupled from visual components. As a developer, you can concentrate on a single task without the need of massive code manipulations.</p> </li> <li> <p>Atomic Design Pattern: Theme UI is based on atoms, molecules, and organisms, combined within pages and shared components. This provides a high level of code reusability.</p> </li> <li> <p>Simple styling and theme customization: We use TailwindCSS to provide the easiest and most convenient way of CSS usage. Write as less code as possible and reuse the existing highly customizable framework features.</p> </li> <li> <p>Fully aligned with Virto Commerce platform: This theme is just a visual representation, we are fully aligned with the platform to provide all common B2B and B2C scenarios Virto Commerce platform provides.</p> </li> <li> <p>Fully responsive: We made our theme work on a number of devices, including desktop and mobile, being focused both on UI and UX.</p> </li> <li> <p>Ultimate starting point for all new themes</p> </li> </ul>"},{"location":"vue-js-starter-theme/overview/#key-functionalities","title":"Key Functionalities","text":"<p>The key functionalities include:</p> <ul> <li>Registration and signing in.</li> <li>Password management.</li> <li>Managing personal and corporate accounts.</li> <li>Managing quote requests.</li> <li>Managing lists.</li> <li>Access assignment.</li> <li>Product comparison.</li> <li>Bulk orders.</li> <li>Intuitive navigation.</li> <li>Buying digital and physical products. </li> <li>Searching and filtering products.</li> </ul>"},{"location":"vue-js-starter-theme/overview/#working-with-vc-theme-b2b-vue","title":"Working with vc-theme-b2b-vue","text":"<p>As a developer, you will be using vc-theme-b2b-vue as your ultimate starting point for a new theme. It contains numerous out-of-the-box features that are typical for B2B and B2C ecommerce projects. Along with ready made theme architecture and huge set of reusable components, it can significantly speed up your development process. To start developing a new theme, you just need to clone (fork) the theme project, and then you will be able to do any customization according to your needs.</p> <p></p>"}]}