{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VirtoCommerce Marketplace Developer Documentation","text":"<p>TODO</p>"},{"location":"state-machine-module/data-structure/","title":"Data Structure","text":"<p>The State Machine module uses several core data classes to model and manage state machine workflows. Understanding these data structures is essential for implementing custom logic and integrating with the state machine system.</p>"},{"location":"state-machine-module/data-structure/#core-data-classes","title":"Core data classes","text":"<p>The following core classes define the building blocks of a state machine. Each class serves a distinct purpose, from modeling workflow definitions to managing runtime instances and supporting localization. Together, they provide the foundation for designing, executing, and extending state-driven business processes.</p>"},{"location":"state-machine-module/data-structure/#statemachinedefinition","title":"StateMachineDefinition","text":"<p>The <code>StateMachineDefinition</code> class represents the blueprint for a state machine workflow. It defines the structure, states, and transitions for a specific entity type.</p> <pre><code>public class StateMachineDefinition : AuditableEntity, ICloneable\n{\n    public string Version { get; set; }\n    public string EntityType { get; set; }\n    public string Name { get; set; }\n    public bool IsActive { get; set; }\n    public IList&lt;StateMachineState&gt; States { get; set; }\n}\n</code></pre> Property Description Version Version identifier for the state machine definition. EntityType The type of business entity this state machine applies to (e.g., \"Product\", \"Order\"). Name Human-readable name for the workflow. IsActive Indicates if this definition is currently active. States Collection of states that make up the workflow."},{"location":"state-machine-module/data-structure/#statemachineinstance","title":"StateMachineInstance","text":"<p>The <code>StateMachineInstance</code> class represents a runtime instance of a state machine bound to a specific business entity.</p> <pre><code>public class StateMachineInstance : AuditableEntity, ICloneable\n{\n    public string EntityId { get; set; }\n    public string EntityType { get; set; }\n    public string StateMachineDefinitionId { get; set; }\n    public StateMachineDefinition StateMachineDefinition { get; set; }\n    public string CurrentStateName { get; set; }\n    public StateMachineState CurrentState { get; set; }\n    public IEnumerable&lt;string&gt; PermittedTriggers { get; set; }\n    public bool IsActive { get; set; }\n    public bool IsStopped { get; set; }\n}\n</code></pre> Property Description EntityId Unique identifier of the business entity. EntityType Type of the business entity. StateMachineDefinitionId Reference to the state machine definition. CurrentStateName Name of the current state. CurrentState Full state object with all properties. PermittedTriggers List of triggers that can be executed from the current state. IsActive Indicates if the instance is active (not stopped and not in final state). IsStopped Manual stop flag for the state machine."},{"location":"state-machine-module/data-structure/#statemachinelocalization","title":"StateMachineLocalization","text":"<p>The <code>StateMachineLocalization</code> class provides multi-language support for state machines.</p> <pre><code>public class StateMachineLocalization : AuditableEntity, ICloneable\n{\n    public string DefinitionId { get; set; }\n    public string Item { get; set; }\n    public string Locale { get; set; }\n    public string Value { get; set; }\n}\n</code></pre> Property Description DefinitionId Reference to the state machine definition. Item The item being localized (state name, transition trigger, etc.). Locale Language/culture code (e.g., \"en-US\", \"fr-FR\"). Value Localized text value."},{"location":"state-machine-module/data-structure/#statemachinestate","title":"StateMachineState","text":"<p>The <code>StateMachineState</code> class defines individual states within a state machine.</p> <pre><code>public class StateMachineState : ValueObject\n{\n    public string Name { get; set; }\n    public string Type { get; set; }\n    public string Description { get; set; }\n    public bool IsInitial { get; set; }\n    public bool IsFinal { get; set; }\n    public bool IsSuccess { get; set; }\n    public bool IsFailed { get; set; }\n    public object StateData { get; set; }\n    public string LocalizedValue { get; set; }\n    public IList&lt;StateMachineTransition&gt; Transitions { get; set; }\n}\n</code></pre> Property Description Name Name of the state. Type Type of the state (defines its role or category). Description Human-readable description of the state. IsInitial Indicates if this is the initial state of the workflow. IsFinal Indicates if this is the final state of the workflow. IsSuccess Marks the state as a successful completion state. IsFailed Marks the state as a failed completion state. StateData Additional data associated with the state. LocalizedValue Localized display value for the state. Transitions List of transitions available from this state."},{"location":"state-machine-module/data-structure/#state-attributes","title":"State attributes","text":"State Attribute Description IsInitial <ul><li>Purpose: Marks the starting state for new entities</li><li>Usage: \"Started\" state should have <code>IsInitial = true</code></li><li>Example: \"Draft\" state for new products, \"New\" state for orders</li></ul> IsFinal <ul><li>Purpose: Indicates the workflow has completed</li><li>Usage: Entities in final states cannot transition to other states</li><li>Example: \"Completed\", \"Cancelled\", \"Archived\"</li></ul> IsSuccess <ul><li>Purpose: Marks successful completion of the workflow</li><li>Usage: Used with <code>IsFinal = true</code> to indicate positive outcomes</li><li>Example: \"Approved\", \"Delivered\", \"Published\"</li><li>Business logic: Often used for reporting and analytics</li></ul> IsFailed <ul><li>Purpose: Marks failed completion of the workflow</li><li>Usage: Used with <code>IsFinal = true</code> to indicate negative outcomes</li><li>Example: \"Rejected\", \"Cancelled\", \"Failed\"</li><li>Business logic: Triggers error handling and notification processes</li></ul>"},{"location":"state-machine-module/data-structure/#data-relationships","title":"Data relationships","text":"<pre><code>erDiagram\n    StateMachineDefinition {\n        string Id PK\n        string Version\n        string EntityType\n        string Name\n        bool IsActive\n        string StatesGraph\n        string StatesCapture\n        datetime CreatedDate\n        string CreatedBy\n        datetime ModifiedDate\n        string ModifiedBy\n    }\n\n    StateMachineInstance {\n        string Id PK\n        string EntityId\n        string EntityType\n        string StateMachineDefinitionId FK\n        bool IsStopped\n        datetime CreatedDate\n        string CreatedBy\n        datetime ModifiedDate\n        string ModifiedBy\n    }\n\n    StateMachineLocalization {\n        string Id PK\n        string DefinitionId FK\n        string Item\n        string Locale\n        string Value\n        datetime CreatedDate\n        string CreatedBy\n        datetime ModifiedDate\n        string ModifiedBy\n    }\n\n    StateMachineState {\n        string Name\n        string Type\n        string Description\n        bool IsInitial\n        bool IsFinal\n        bool IsSuccess\n        bool IsFailed\n        object StateData\n        string LocalizedValue\n    }\n\n    StateMachineTransition {\n        string Trigger\n        string ToState\n        string FromState\n        object Condition\n    }\n\n    StateMachineDefinition ||--o{ StateMachineInstance : \"defines\"\n    StateMachineDefinition ||--o{ StateMachineLocalization : \"localizes\"\n    StateMachineDefinition ||--o{ StateMachineState : \"contains\"\n    StateMachineState ||--o{ StateMachineTransition : \"has\"</code></pre>"},{"location":"state-machine-module/data-structure/#usage-examples","title":"Usage examples","text":""},{"location":"state-machine-module/data-structure/#product-approval-workflow","title":"Product approval workflow","text":"<pre><code>{\n  \"name\": \"Product Approval\",\n  \"entityType\": \"Product\",\n  \"isActive\": true,\n  \"states\": [\n    {\n      \"name\": \"Draft\",\n      \"isInitial\": true,\n      \"isFinal\": false,\n      \"isSuccess\": false,\n      \"isFailed\": false,\n      \"transitions\": [\n        {\n          \"trigger\": \"Submit\",\n          \"toState\": \"PendingReview\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PendingReview\",\n      \"isInitial\": false,\n      \"isFinal\": false,\n      \"isSuccess\": false,\n      \"isFailed\": false,\n      \"transitions\": [\n        {\n          \"trigger\": \"Approve\",\n          \"toState\": \"Approved\"\n        },\n        {\n          \"trigger\": \"Reject\",\n          \"toState\": \"Rejected\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Approved\",\n      \"isInitial\": false,\n      \"isFinal\": true,\n      \"isSuccess\": true,\n      \"isFailed\": false\n    },\n    {\n      \"name\": \"Rejected\",\n      \"isInitial\": false,\n      \"isFinal\": true,\n      \"isSuccess\": false,\n      \"isFailed\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"state-machine-module/data-structure/#using-issuccess-and-isfailed","title":"Using IsSuccess and IsFailed","text":"<p>The <code>IsSuccess</code> and <code>IsFailed</code> attributes are particularly useful for:</p> <ul> <li> <p>Reporting and analytics:     <pre><code>// Get success rate for product approvals\nvar totalProducts = instances.Count();\nvar successfulProducts = instances.Count(i =&gt; i.CurrentState.IsSuccess);\nvar failedProducts = instances.Count(i =&gt; i.CurrentState.IsFailed);\nvar successRate = (double)successfulProducts / totalProducts * 100;\n</code></pre></p> </li> <li> <p>Conditional business logic:     <pre><code>// Trigger different actions based on outcome\nif (currentState.IsSuccess)\n{\n    // Send success notification\n    // Update product status to \"Active\"\n    // Trigger marketing campaigns\n}\nelse if (currentState.IsFailed)\n{\n    // Send rejection notification\n    // Log failure reason\n    // Trigger review process\n}\n</code></pre></p> </li> <li> <p>Dashboard widgets:     <pre><code>// Display workflow statistics\nvar stats = new WorkflowStats\n{\n    InProgress = instances.Count(i =&gt; !i.CurrentState.IsFinal),\n    Successful = instances.Count(i =&gt; i.CurrentState.IsSuccess),\n    Failed = instances.Count(i =&gt; i.CurrentState.IsFailed),\n    Total = instances.Count()\n};\n</code></pre></p> </li> </ul>"},{"location":"state-machine-module/data-structure/#best-practices","title":"Best practices","text":"Area Description State Design <ul><li>Keep states simple: Each state should represent a clear, distinct condition</li><li>Use meaningful names: State names should be self-explanatory</li><li>Plan for localization: Consider how state names will translate to other languages</li></ul> Transition Design <ul><li>Minimize complexity: Avoid too many transitions from a single state</li><li>Use clear triggers: Trigger names should indicate the action being performed</li><li>Document conditions: Complex transition conditions should be well-documented</li></ul> Data Management <ul><li>Version control: Use the Version field to track state machine changes</li><li>Audit trails: Leverage the AuditableEntity base class for change tracking</li><li>Performance: Consider indexing frequently queried fields like EntityType and EntityId. </li></ul> \u2190 State Machine module overview Entity types \u2192"},{"location":"state-machine-module/entity-types/","title":"Entity Types","text":"<p>Entity types are the foundation of the State Machine module, allowing you to bind state machine workflows to any business entity in your system. This document explains how to register entity types, create custom actions, and integrate state machines with your business logic.</p> <p>An entity type represents a category of business objects that can be managed by state machines:</p> <p></p>"},{"location":"state-machine-module/entity-types/#registration-services","title":"Registration services","text":"<p>The module provides two key services for entity type management:</p> <ul> <li>stateMachineTypes.js</li> <li>stateMachineRegistrar.js</li> </ul>"},{"location":"state-machine-module/entity-types/#statemachinetypesjs","title":"stateMachineTypes.js","text":"<p>This service manages the registry of available entity types:</p> <pre><code>angular.module('virtoCommerce.stateMachineModule')\n    .factory('virtoCommerce.stateMachineModule.stateMachineTypes', [function () {\n        var registeredTypes = [];\n\n        return {\n            addType: function (entityType) {\n                registeredTypes.push(entityType);\n            },\n            getAllTypes: function () {\n                return registeredTypes;\n            },\n            getTypeInfo: function (type) {\n                return registeredTypes.find(x =&gt; x.value === type);\n            }\n        };\n    }]);\n</code></pre>"},{"location":"state-machine-module/entity-types/#statemachineregistrarjs","title":"stateMachineRegistrar.js","text":"<p>This service manages Operator Portal custom state actions:</p> <pre><code>angular.module('virtoCommerce.stateMachineModule')\n    .factory('virtoCommerce.stateMachineModule.stateMachineRegistrar', [function () {\n        var registeredStates = {};\n\n        return {\n            registerStateAction: function (stateName, action) {\n                registeredStates[stateName] = action;\n            },\n            getStateAction: function (stateName) {\n                return registeredStates[stateName];\n            }\n        };\n    }]);\n</code></pre>"},{"location":"state-machine-module/entity-types/#register-entities-and-frontend-actions","title":"Register entities and frontend actions","text":"<ol> <li> <p>Register your entity type in your module's main JavaScript file as follows:</p> <pre><code>// Example from vc-module-marketplace-registration\nangular.module('virtoCommerce.marketplaceRegistrationModule')\n    .run(['virtoCommerce.stateMachineModule.stateMachineTypes', function (stateMachineTypes) {\n        // Register the RegistrationRequest entity type\n        stateMachineTypes.addType({\n            caption: 'marketplaceRegistration.state-machine-entity-types.registration-request',\n            value: 'VirtoCommerce.MarketplaceRegistrationModule.Core.Models.RegistrationRequest'\n\n        });\n    }]);\n</code></pre> </li> <li> <p>Create custom Operator Portal frontend actions. They allow you to implement specific business logic when state transitions occur. To register custom actions:</p> <pre><code>// Example from vc-module-marketplace-registration\nangular.module('virtoCommerce.marketplaceRegistrationModule')\n    .run(['virtoCommerce.stateMachineModule.stateMachineRegistrar', function (stateMachineRegistrar) {\n        stateMachineRegistrar.registerStateAction('CompleteRegistrationRequest', {\n            callbackFn: function (blade, successCallback) {\n                var foundMetaFields = metaFormsService.getMetaFields('SellerAdd');\n                var createSellerCommand = {\n                    sellerName: blade.currentEntity.organizationName,\n                    ownerDetails: {\n                        firstName: blade.currentEntity.firstName,\n                        lastName: blade.currentEntity.lastName,\n                        email: blade.currentEntity.contactEmail\n                    }\n                };\n                var newBlade = {\n                    id: 'registrationRequestComplete',\n                    command: createSellerCommand,\n                    title: 'marketplace.blades.seller-add.title',\n                    subtitle: 'marketplace.blades.seller-add.subtitle',\n                    controller: 'virtoCommerce.marketplaceModule.sellerAddController',\n                    template: 'Modules/$(VirtoCommerce.MarketplaceVendor)/Scripts/blades/seller-add.tpl.html',\n                    metaFields: foundMetaFields,\n                    successCallback: successCallback\n                };\n                blade.childBlade = newBlade;\n                bladeNavigationService.showBlade(newBlade, blade);\n            }\n        });\n    }]);\n</code></pre> </li> </ol>"},{"location":"state-machine-module/entity-types/#best-practices","title":"Best practices","text":"<ul> <li> <p>Naming conventions:</p> <ul> <li>Use PascalCase for entity type values: <code>RegistrationRequest</code>, <code>ProductApproval</code>.</li> <li>Use descriptive display names: \"Vendor Registration Request\", \"Product Approval Workflow\".</li> <li>Keep trigger names consistent: <code>SubmitTrigger</code>, <code>ApproveTrigger</code>, <code>RejectTrigger</code>, <code>CancelTrigger</code>.</li> </ul> </li> <li> <p>Error handling:     <pre><code>$scope.executeAction = function(trigger) {\n    $scope.loading = true;\n\n    stateMachineApi.fireTrigger({\n        instanceId: $scope.stateMachineInstance.id,\n        trigger: trigger\n    }).$promise.then(function(result) {\n        // Success handling\n        notificationService.success('Action completed successfully');\n        $scope.loadStateMachine();\n    }).catch(function(error) {\n        // Error handling\n        notificationService.error('Action failed: ' + error.data.message);\n    }).finally(function() {\n        $scope.loading = false;\n    });\n};\n</code></pre></p> </li> <li> <p>Performance optimization:</p> <ul> <li>Cache state machine instances when possible.</li> <li>Use lazy loading for entity lists with state information.</li> <li>Implement pagination for large datasets.</li> </ul> </li> <li> <p>Security considerations:</p> <ul> <li>Always validate permissions before executing actions.</li> <li>Sanitize user input in custom actions.</li> <li>Use HTTPS for all state machine API calls.</li> </ul> </li> </ul>"},{"location":"state-machine-module/entity-types/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <p>Common issues:</p> Issue Troubleshooting Entity type not appearing Ensure the registration code runs after the state machine module is loaded. Actions not working Check that permissions are correctly configured. State not updating Verify that the entity ID and type match exactly. </li> <li> <p>Debugging tips:</p> <pre><code>// Enable debug logging\nangular.module('yourModule')\n    .run(['$log', function($log) {\n        $log.debug('Registering entity type: YourEntityType');\n    }]);\n\n// Check registered types\nconsole.log(stateMachineTypes.getAllTypes());\n\n// Verify action registration\nconsole.log(stateMachineRegistrar.getStateAction('YourState'));\n</code></pre> </li> </ul> <p> </p> \u2190 Data structure Transition conditions \u2192"},{"location":"state-machine-module/operator-portal-actions/","title":"State Machine Actions in Operator Portal","text":"<p>The Operator Portal provides comprehensive state machine management capabilities for administrators and operators. This guide explains how to integrate state machine actions into the Operator interface and manage entity life cycles through the administrative portal.  </p> <p>The following example shows how state machine actions are implemented for a Product Publication Request. The controller defines toolbar commands, adds available state machine actions dynamically, and executes triggers through the backend API:</p> <pre><code>angular.module('virtoCommerce.marketplaceModule')\n    .controller('virtoCommerce.marketplaceModule.sellerProductDetailsController',\n        ['$scope', ...\n        function ($scope, ...) {\n          ...\n          // Step 1: Initialize the blade and set up commands\n          function initializeBlade(data) {\n            ...\n              fillTollbarCommands();\n            ...\n          }\n\n          // Step 2: Populate toolbar commands, including state machine actions\n          function fillTollbarCommands() {\n              blade.toolbarCommands = [];\n\n              // Add regular tool buttons first\n              ...\n\n              // Add state machine actions dynamically\n              if (blade.stateMachineInstance\n                  &amp;&amp; blade.stateMachineInstance.currentState\n                  &amp;&amp; blade.stateMachineInstance.currentState.transitions\n                  &amp;&amp; blade.stateMachineInstance.permittedTriggers\n              ) {\n                  blade.stateMachineInstance.currentState.transitions.forEach((element, index) =&gt; {\n                      if (blade.stateMachineInstance.permittedTriggers.includes(element.trigger)) {\n                          var command = {\n                              id: 'command' + element.trigger,\n                              name: element.localizedValue || element.trigger,\n                              title: element.description,\n                              icon: element.icon,\n                              executeMethod: function () {\n                                  doAction(element.trigger);\n                              }\n                          };\n                          if (!blade.toolbarCommands.find(x =&gt; x.id === \"command\" + element.trigger)) {\n                              blade.toolbarCommands.splice(index, 0, command);\n                              addedButtonsCount++;\n                          }\n                      }\n                  });\n              }\n\n              // Add more tool buttons after state machine actions if needed\n          }\n\n          // Step 3: Execute a state machine action\n          function doAction(trigger) {\n              blade.isLoading = true;\n              var stateMachineAction = stateMachineRegistrar.getStateAction(trigger);\n\n              // Call registered action if exists, then fire backend trigger\n              if (stateMachineAction &amp;&amp; stateMachineAction.callbackFn &amp;&amp; typeof stateMachineAction.callbackFn === \"function\") {\n                  function successCallback() {\n                      doStateMachineStep(trigger);\n                  };\n                  stateMachineAction.callbackFn(blade, successCallback);\n              } else {\n                  doStateMachineStep(trigger);\n              }\n\n              blade.isLoading = false;\n          }\n\n          // Step 4: Fire the backend state machine trigger\n          function doStateMachineStep(trigger) {\n              stateMachineApi.fireStateMachineInstanceTrigger({\n                  stateMachineInstanceId: blade.stateMachineInstance.id,\n                  trigger: trigger,\n                  entityId: publicationRequestId\n              },\n              function (data) {\n                  // Refresh the blade to reflect state changes\n                  blade.refresh(true);\n              });\n          }\n\n          ...\n          // Other blade logic\n}]);\n</code></pre> <p>In the Operator Portal, the applied modifications look as follows:</p> <p></p> <p> </p> \u2190 Transition conditions Vendor Portal actions \u2192"},{"location":"state-machine-module/overview/","title":"Overview","text":"<p>The Virto Commerce State Machine module provides a comprehensive framework for modeling and managing complex business processes through configurable finite state machines. This module enables organizations to define, visualize, and control the lifecycle of any business entity by establishing clear states, transitions, and business rules.</p> <p>A state machine (also known as a finite state machine or FSM) is a computational model used to design algorithms and model complex behaviors. In business contexts, state machines help manage the lifecycle of entities by defining:</p> <ul> <li>States.</li> <li>Transitions and triggers.</li> <li>Conditions.</li> </ul>"},{"location":"state-machine-module/overview/#states","title":"States","text":"<p>States represent the current condition of an entity. For example, an e-commerce order moves through the following states:</p> State Description New Customer places order. Paid Payment is processed. Shipped Order is dispatched. Delivered Customer receives order. Completed Process finished. <p>Each transition has rules (e.g., \"can only ship after payment\") and may trigger actions (e.g., \"send notification email\").</p> <p>Each state has several attributes:</p> Attribute Description Name Human-readable identifier. IsInitial Marks the starting state for new entities. IsFinal Indicates the workflow has completed. IsSuccess Marks successful completion (for final states). IsFailed Marks failed completion (for final states)."},{"location":"state-machine-module/overview/#transitions-and-triggers","title":"Transitions and triggers","text":"<p>Transitions define how entities move between states:</p> Component Description Trigger The event name that initiates the transition. From State Source state. To State Destination state. Conditions Optional business rules that must be satisfied."},{"location":"state-machine-module/overview/#conditions","title":"Conditions","text":"<p>Conditions are business rules that determine if a transition can occur:</p> Condition Description Built-in conditions Pre-defined rules for common scenarios. Custom conditions User-defined logic specific to business needs. Expression-based Use simple expressions or complex code."},{"location":"state-machine-module/overview/#module-architecture","title":"Module architecture","text":"<p>The State Machine module follows the Virto Commerce's modular architecture:</p> <p></p>"},{"location":"state-machine-module/overview/#key-benefits","title":"Key benefits","text":"<ul> <li> <p>Business process clarity:</p> <ul> <li>Visual representation of complex workflows.</li> <li>Clear documentation of business rules.</li> <li>Consistent process execution across the organization.</li> </ul> </li> <li> <p>Flexibility and maintainability:</p> <ul> <li>No-code/low-code workflow design.</li> <li>Easy modification of business rules.</li> </ul> </li> <li> <p>Integration ready:</p> <ul> <li>RESTful API for external system integration.</li> <li>Event-driven architecture for real-time updates.</li> <li>Webhook support for process notifications.</li> </ul> </li> <li> <p>Audit and compliance:</p> <ul> <li>User tracking for all transitions.</li> <li>Configurable approval workflows.</li> </ul> </li> <li> <p>Multi-language support:</p> <ul> <li>Localized state and transition names.</li> <li>Cultural adaptation of workflows.</li> </ul> </li> </ul>"},{"location":"state-machine-module/overview/#core-mechanisms","title":"Core mechanisms","text":"<p>The workflow system is powered by several core mechanisms that define how states, transitions, and rules are managed:</p> <ul> <li> <p>State machine engine. The engine is built on the Stateless library, providing:</p> <ul> <li>Thread-safe state management.</li> <li>Hierarchical state machines.</li> <li>Guard conditions and entry/exit actions.</li> </ul> </li> <li> <p>Condition. The extensible condition system supports:</p> <ul> <li>Role conditions: Check user permissions.</li> <li>Custom conditions: Domain-specific logic.</li> </ul> </li> </ul>"},{"location":"state-machine-module/overview/#use-cases","title":"Use cases","text":"Field Description eCommerce Order processing workflows, product approval processes, customer onboarding, return/refund management. B2B marketplaces Vendor registration approval, product catalog management, contract negotiation workflows, supplier onboarding. Content management Content approval workflows, publication processes, review and moderation, multi-stage content lifecycle. Healthcare Patient care pathways, treatment approval processes, medical device certification, regulatory compliance workflows."},{"location":"state-machine-module/overview/#getting-started","title":"Getting started","text":"<ol> <li>Define your process: Identify states and transitions for your business entity.</li> <li>Register entity type: Bind your entity to the state machine system.</li> <li>Create state machine: Use the visual editor to design your workflow.</li> <li>Configure conditions: Set up business rules and validation logic.</li> <li>Integrate Frontend: Implement state actions in your user interfaces.</li> <li>Test and deploy: Validate your workflow with real data.</li> </ol> Data structure \u2192"},{"location":"state-machine-module/transition-conditions/","title":"Transition Conditions","text":"<p>Transition conditions are the business rules that determine when a state machine can move from one state to another. They provide the logic layer that enforces business constraints, validates data, checks permissions, and ensures that workflows follow proper procedures. This document covers built-in conditions, custom condition development, and best practices for implementing complex business logic.</p> <p>Transition conditions are boolean expressions that must evaluate to <code>true</code> for a transition to be allowed. They act as gatekeepers, ensuring:</p> <ul> <li>Security: Users have appropriate permissions.</li> <li>Business rules: Only valid business operations are performed.</li> </ul>"},{"location":"state-machine-module/transition-conditions/#built-in-condition-types","title":"Built-in condition types","text":"<p>The State Machine module provides several built-in condition types that control when transitions are allowed:</p> <ul> <li>Security conditions.</li> <li>Field conditions.</li> </ul>"},{"location":"state-machine-module/transition-conditions/#security-conditions","title":"Security conditions","text":"<p>Security conditions check user permissions.</p> <p>Example. Permission-based condition:</p> <pre><code>{\n  \"id\": \"StateMachineConditionHasPermission\",\n  \"permissions\": [\n    \"operator:product:approve\"\n  ]\n}\n</code></pre>"},{"location":"state-machine-module/transition-conditions/#field-conditions","title":"Field conditions","text":"<p>Field conditions compare entity properties against specific values or patterns. This condition model is based on standard Virto Commerce conditions engine:</p> <p>Example. Basic field comparison:</p> <pre><code>{\n\"id\": \"PublicationRequestConditionApprovalPolicyIs\",\n\"approvalPolicy\": \"Auto\"\n}\n</code></pre> <p>The supported operators include:</p> Operator Description equals Exact match comparison notEquals Not equal comparison contains String contains substring startsWith String starts with value endsWith String ends with value greaterThan Numeric greater than lessThan Numeric less than greaterThanOrEqual Numeric greater than or equal lessThanOrEqual Numeric less than or equal in Value is in a list notIn Value is not in a list isEmpty Field is null or empty isNotEmpty Field has a value <p>Example. Complex field conditions:</p> <pre><code>{\n  \"id\": \"FieldCondition\",\n  \"fieldName\": \"price\",\n  \"operator\": \"greaterThan\",\n  \"value\": 100\n}\n</code></pre>"},{"location":"state-machine-module/transition-conditions/#creating-custom-conditions","title":"Creating custom conditions","text":"<p>Custom conditions allow you to extend the state machine with domain-specific rules and behaviors tailored to your business logic. You can define:</p> <ul> <li>Backend conditions.</li> <li>Frontend conditions.</li> </ul>"},{"location":"state-machine-module/transition-conditions/#backend-conditions","title":"Backend conditions","text":"<p>Backend conditions define the logic that evaluates whether a state transition is allowed:</p> <ol> <li> <p>Implement <code>IConditionTree</code> rule:</p> <pre><code>public class PublicationRequestConditionApprovalPolicyIs : ConditionTree\n{\n    public string ApprovalPolicy { get; set; }\n\n    public override bool IsSatisfiedBy(IEvaluationContext context)\n    {\n        if (context is StateMachineTriggerContext stateMachineTriggerContext\n            &amp;&amp; stateMachineTriggerContext.ContextObject is ProductPublicationRequest productPublicationRequest)\n        {\n            return productPublicationRequest.ApprovalPolicy == ApprovalPolicy;\n        }\n\n        return false;\n    }\n}\n</code></pre> </li> <li> <p>Composite custom rules in blocks, if necessary:</p> <pre><code>public class PublicationRequestConditionTreePrototype : ConditionTree\n{\n    public PublicationRequestConditionTreePrototype()\n    {\n        WithAvailConditions(\n            new PublicationRequestCondition().WithAvailConditions(\n                new StateMachineConditionHasPermission(),\n                new PublicationRequestConditionApprovalPolicyIs()\n            )\n        );\n        Children = AvailableChildren.ToList();\n    }\n}\n</code></pre> </li> <li> <p>Register the condition:</p> <pre><code>// In your module's PostInitialize method\npublic void PostInitialize(IApplicationBuilder appBuilder)\n{\n    ...\n        foreach (var conditionTree in AbstractTypeFactory&lt;PublicationRequestConditionTreePrototype&gt;.TryCreateInstance().Traverse&lt;IConditionTree&gt;(x =&gt; x.AvailableChildren))\n        {\n            AbstractTypeFactory&lt;IConditionTree&gt;.RegisterType(conditionTree.GetType());\n        }\n    ...\n}\n</code></pre> </li> <li> <p>Use in State Machine Definition:</p> <pre><code>{\n  \"trigger\": \"OperatorApproveTrigger\",\n  \"icon\": \"fa fa-cogs\",\n  \"toState\": \"Approved\",\n  \"condition\": {\n    \"all\": false,\n    \"not\": false,\n    \"id\": \"PublicationRequestCondition\",\n    \"children\": [\n      {\n        \"all\": false,\n        \"not\": false,\n        \"id\": \"PublicationRequestCondition\",\n        \"children\": [\n          {\n            \"notHas\": false,\n            \"permissions\": [\n            \"operator:product:approve\"\n            ],\n            \"id\": \"StateMachineConditionHasPermission\"\n          },\n          {\n            \"approvalPolicy\": \"Auto\",\n            \"id\": \"PublicationRequestConditionApprovalPolicyIs\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> </li> </ol>"},{"location":"state-machine-module/transition-conditions/#frontend-conditions","title":"Frontend conditions","text":"<p>Frontend configuration provides UI templates for users to manage conditions visually in the Operator Portal. It typically involves two steps: </p> <ol> <li> <p>Define the HTML template for displaying and editing a condition:</p> <pre><code>&lt;!-- example template for ConditionHasPermission  --&gt;\n&lt;script type=\"text/ng-template\" id=\"StateMachineConditionHasPermission.html\"&gt;\n&lt;a class=\"__link\" left-click-menu data-target=\"notMenu\"&gt;{{element1.notHas | boolToValue:'Has no':'Has'}}&lt;/a&gt; permission\n&lt;ul class=\"menu __context\" role=\"menu\" id=\"notMenu\"&gt;\n    &lt;li class=\"menu-item\" ng-click='element1.notHas=false;'&gt;Has&lt;/li&gt;\n    &lt;li class=\"menu-item\" ng-click='element1.notHas=true;'&gt;Has no&lt;/li&gt;\n&lt;/ul&gt;\n&lt;div class=\"form-input\"&gt;\n    &lt;ui-select multiple ng-model=\"element1.permissions\" ng-controller=\"virtoCommerce.stateMachineModule.permissionConditionController\"&gt;\n    &lt;ui-select-match placeholder=\"Select...\"&gt;{{$item|json}}&lt;/ui-select-match&gt;\n    &lt;ui-select-choices repeat=\"x in permissions | filter: $select.search\"&gt;\n        &lt;span ng-bind-html=\"x | highlight: $select.search\"&gt;&lt;/span&gt;\n    &lt;/ui-select-choices&gt;\n    &lt;/ui-select&gt;\n&lt;/div&gt;\n&lt;/script&gt;\n</code></pre> </li> <li> <p>Implement a controller (e.g., Permission Condition Controller) to supply data and bind it to the template:</p> <pre><code>angular.module('virtoCommerce.stateMachineModule')\n    .controller('virtoCommerce.stateMachineModule.permissionConditionController',\n        ['$scope', 'platformWebApp.roles',\n            function ($scope, roles) {\n                roles.queryPermissions({ take: 10000 }, function (result) {\n                    $scope.permissions = result.map(x =&gt; x.name);\n                });\n            }\n        ]\n    );\n</code></pre> </li> </ol>"},{"location":"state-machine-module/transition-conditions/#condition-context-and-data","title":"Condition context and data","text":"<p>The condition context provides the runtime information that conditions use to evaluate state transitions, including details about the state machine instance, the current user, and the target entity.  </p>"},{"location":"state-machine-module/transition-conditions/#statemachinetriggercontext","title":"StateMachineTriggerContext","text":"<p>StateMachineTriggerContext extends EvaluationContextBase. The ContextObject provides access to all relevant data for condition evaluation:</p> <pre><code>public class StateMachineTriggerContext : EvaluationContextBase\n{\n    public StateMachineInstance StateMachineInstance { get; set; }\n    public ClaimsPrincipal Principal { get; set; }\n    public string EntityId { get; set; }\n}\n</code></pre>"},{"location":"state-machine-module/transition-conditions/#accessing-entity-data","title":"Accessing entity data","text":"<pre><code>// Example of using from PublicationRequestConditionApprovalPolicyIs\npublic override bool IsSatisfiedBy(IEvaluationContext context)\n{\n    if (context is StateMachineTriggerContext stateMachineTriggerContext\n        &amp;&amp; stateMachineTriggerContext.ContextObject is ProductPublicationRequest productPublicationRequest)\n    {\n        return productPublicationRequest.ApprovalPolicy == ApprovalPolicy;\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"state-machine-module/transition-conditions/#best-practices","title":"Best practices","text":"<ul> <li>Each condition should check one specific business rule.</li> <li>Avoid complex conditions that validate multiple unrelated aspects.</li> <li>Use composite conditions to combine simple conditions.</li> </ul> \u2190 Entity types Operator portal actions \u2192"},{"location":"state-machine-module/vendor-portal-actions/","title":"State Machine Actions in Vendor Portal","text":"<p>The Vendor Portal provides vendor-facing state machine functionality, allowing vendors and external users to interact with workflows through a modern, responsive interface. This document explains how to integrate state machine actions into customer portals, implement permitted triggers, and create intuitive user experiences for workflow management.</p> <p>The following example demonstrates how to implement state machine actions for product details in the Vendor Portal. It covers querying the state machine instance, refreshing the toolbar with permitted triggers, and handling trigger execution with real-time UI updates:</p> <pre><code>...\n// import classes and composables\nimport {\n  StateMachineClient,\n  GetStateMachineInstanceForEntityQuery,\n  StateMachineInstance,\n} from \"@vcmp-vendor-portal/api/statemachine\";\n\nimport { useStateMachines } from \"../../../state-machines/composables\";\n...\nexport interface ProductDetailsScope extends DetailsBaseBladeScope {\n...\n  // define toolbar overrides\n  toolbarOverrides: {\n    ...\n    stateMachineComputed: ComputedRef&lt;IBladeToolbar[]&gt;;\n  };\n}\n...\nconst { getApiClient: getStateMachineApiClient } = useApiClient(StateMachineClient);\n...\nexport function useProductDetails(...) {\n...\n  const stateMachineInstance = ref&lt;StateMachineInstance&gt;();\n  const stateMachineLoading = ref(false);\n  const toolbar = ref([]) as Ref&lt;IBladeToolbar[]&gt;;\n  const { fireTrigger } = useStateMachines();\n\n  // on load product - query state machine and call refresh toolbar\n  const detailsFactory = useDetailsFactory&lt;ISellerProduct &amp; IProductDetails&gt;({\n    load: async (item) =&gt; {\n      if (item?.id) {\n        const resItem = await (await getApiClient()).getProductById(item.id);\n        const resModel = await createModel(resItem);\n\n        const publicationrequestId: string = resModel.publicationRequests[0].id!;\n          stateMachineInstance.value = await (\n            await getStateMachineApiClient()\n          ).getStateMachineForEntity(\n            new GetStateMachineInstanceForEntityQuery({\n              entityId: publicationrequestId,\n              entityType: \"VirtoCommerce.MarketplaceVendorModule.Core.Domains.ProductPublicationRequest\",\n              locale: currentLocale.value,\n            }),\n          );\n          refreshToolbar(stateMachineInstance.value ?? {});\n        }\n        return resModel;\n      }\n    },\n    ...\n  });\n\n  // refresh toolbar\n  const refreshToolbar = (sm: StateMachineInstance) =&gt; {\n    toolbar.value.splice(0);\n\n    sm?.currentState?.transitions?.forEach((transition, index) =&gt; {\n      if (sm?.permittedTriggers?.includes(transition.trigger!)) {\n        toolbar.value.push({\n          id: transition.trigger,\n          title: transition.localizedValue ?? transition.trigger,\n          icon: transition.icon ?? \"grading\",\n          disabled: computed(() =&gt; stateMachineLoading.value),\n          separator: index === 0 ? \"left\" : undefined,\n          async clickHandler() {\n            try {\n              stateMachineLoading.value = true;\n              const currentStateMachine = await fireTrigger(sm.id!, transition.trigger!, sm.entityId!);\n              args.emit(\"parent:call\", {\n                method: \"reload\",\n              });\n              //item.value!.status = transition.toState;\n              validationState.value.resetModified(item.value, true);\n              refreshToolbar(currentStateMachine);\n            } catch (error) {\n              console.error(error);\n            } finally {\n              stateMachineLoading.value = false;\n            }\n          },\n        });\n      }\n    });\n  };\n\n  // override toolbar in scope\n  const scope: ProductDetailsScope = {\n    ...\n    toolbarOverrides: {\n      // other toolbar buttons\n      ...\n      // state machine buttons\n      stateMachineComputed: computed(() =&gt; toolbar.value),\n    },\n  };\n\n  // other part of blade logic\n  ...\n</code></pre>"},{"location":"state-machine-module/vendor-portal-actions/#page-implementation","title":"Page implementation","text":"<p>The page component uses the <code>DynamicDetailsSchema</code> to configure the product details blade, including toolbar integration:</p> <pre><code>import { DynamicDetailsSchema } from \"@vc-shell/framework\";\n\nexport const details: DynamicDetailsSchema = {\n  settings: {\n    url: \"/product\",\n    id: \"Product\",\n    localizationPrefix: \"Products\",\n    composable: \"useProductDetails\",\n    component: \"DynamicBladeForm\",\n    toolbar: [\n      // other toolbar buttons\n      ...\n      // state machine computed actions\n      {\n        id: \"stateMachineComputed\",\n        method: \"stateMachineComputed\",\n      },\n    ],\n    // other component content\n    ...\n  }\n}\n</code></pre> <p>In the Vendor Portal, the applied modifications look as follows:</p> <p></p> <p> </p> \u2190 Operator Portal actions"}]}