{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Developer Documentation Welcome to Virto Commerce Developer Documentation Center. From here, you can learn how to set up, build, develop, and maintain your Virto solutions. If you are new to Virto, learn how to get started here . Alternatively, you can learn more about our back end architecture or check out our tutorials . If you want to get back to our home page, click here .","title":"Home"},{"location":"#developer-documentation","text":"Welcome to Virto Commerce Developer Documentation Center. From here, you can learn how to set up, build, develop, and maintain your Virto solutions. If you are new to Virto, learn how to get started here . Alternatively, you can learn more about our back end architecture or check out our tutorials . If you want to get back to our home page, click here .","title":"Developer Documentation"},{"location":"Back-End-Architecture/01-tech-stack/","text":"Technology Stack Virto Commerce is a .NET based ecommerce platform that promotes SOLID principles and clean code. Its purpose is to facilitate rapid development in building customized solutions for ecommerce businesses. Virto Commerce uses a set of well known components and libraries: ASP.NET Core 6: A cross-platform high performance open-source framework for building modern cloud-enabled Internet-connected apps. EF Core 6: As an object-relational mapper (O/RM), it enables working with databases using .NET objects. ASP.NET Core Identity: Used for authentication and managing users, passwords, profile data, roles, claims, tokens, email confirmation, and more. OpenIddict: Provides a versatile solution to implement an OpenID Connect server and token validation in any ASP.NET Core application. WebPack: Primary design/runtime bundler and minifier. Swashbuckle.AspNetCore tooling for APIs built with ASP.NET Core: Enables generating neat API documentation, including a UI to explore and test operations directly from your routes, controllers, and models. SignalR Core: Used for push notifications based on web sockets. AngularJS: Progressive web framework for building the Platform Manager web application (legacy). HangFire: Used for performing background processing in .NET and .NET Core applications. StackExchange.Redis; A high performance general purpose Redis client for .NET languages. Scriban: A fast, powerful, safe, and lightweight scripting language and engine for .NET, which was primarily developed for text templating with a compatibility mode for parsing liquid templates. Note You can find the full list of used third party components on our GitHub repository .","title":"Tech Stack"},{"location":"Back-End-Architecture/01-tech-stack/#technology-stack","text":"Virto Commerce is a .NET based ecommerce platform that promotes SOLID principles and clean code. Its purpose is to facilitate rapid development in building customized solutions for ecommerce businesses. Virto Commerce uses a set of well known components and libraries: ASP.NET Core 6: A cross-platform high performance open-source framework for building modern cloud-enabled Internet-connected apps. EF Core 6: As an object-relational mapper (O/RM), it enables working with databases using .NET objects. ASP.NET Core Identity: Used for authentication and managing users, passwords, profile data, roles, claims, tokens, email confirmation, and more. OpenIddict: Provides a versatile solution to implement an OpenID Connect server and token validation in any ASP.NET Core application. WebPack: Primary design/runtime bundler and minifier. Swashbuckle.AspNetCore tooling for APIs built with ASP.NET Core: Enables generating neat API documentation, including a UI to explore and test operations directly from your routes, controllers, and models. SignalR Core: Used for push notifications based on web sockets. AngularJS: Progressive web framework for building the Platform Manager web application (legacy). HangFire: Used for performing background processing in .NET and .NET Core applications. StackExchange.Redis; A high performance general purpose Redis client for .NET languages. Scriban: A fast, powerful, safe, and lightweight scripting language and engine for .NET, which was primarily developed for text templating with a compatibility mode for parsing liquid templates. Note You can find the full list of used third party components on our GitHub repository .","title":"Technology Stack"},{"location":"Back-End-Architecture/02-conceptual-overview-in-progress/","text":"Conceptual Overview This section is an overview of all components in the Virto Commerce platform application. The chart below shows the high level architecture of the platform: The Virto Commerce platform's core components are Platform Manager (SPA), Platform Application (runtime), Modules, and REST and GraphQL APIs. You can find a brief description of each below: Platform manager (SPA) : A web-based user interface packed into an SPA allowing you to manage your application. It also provides back office capabilities that enable master data management, configuring products, prices, inventories, employees, workflows, and other functionality required for ecommerce applications. It works with all data through REST API the platform runtime provides. Platform application (runtime) : An ASP.NET Core application that bootstraps the modules and manager GUI and acts as a host for all platform capabilities. Modules : Each module encapsulates a portion of the application's overall functionality. Multiple modules get organized into independent and interchangeable software packages hosted by the Platform Application . All modules can be divided to three main categories depending on which tasks they target: Business modules: Contain the implementation of business functionality; Integration modules: Implement various kinds of integration with third party services; Custom solution modules: Usually contain an extension of the existing logic other modules have. REST and GraphQL API: A set of APIs used to manage resources. REST API is mainly used to build integration and interact with Virto resources, while GraphQL represents an implementation of the Back End for Front End design pattern and provides a lightweight access to ecommerce capabilities for various storefront applications.","title":"Conceptual Overview"},{"location":"Back-End-Architecture/02-conceptual-overview-in-progress/#conceptual-overview","text":"This section is an overview of all components in the Virto Commerce platform application. The chart below shows the high level architecture of the platform: The Virto Commerce platform's core components are Platform Manager (SPA), Platform Application (runtime), Modules, and REST and GraphQL APIs. You can find a brief description of each below: Platform manager (SPA) : A web-based user interface packed into an SPA allowing you to manage your application. It also provides back office capabilities that enable master data management, configuring products, prices, inventories, employees, workflows, and other functionality required for ecommerce applications. It works with all data through REST API the platform runtime provides. Platform application (runtime) : An ASP.NET Core application that bootstraps the modules and manager GUI and acts as a host for all platform capabilities. Modules : Each module encapsulates a portion of the application's overall functionality. Multiple modules get organized into independent and interchangeable software packages hosted by the Platform Application . All modules can be divided to three main categories depending on which tasks they target: Business modules: Contain the implementation of business functionality; Integration modules: Implement various kinds of integration with third party services; Custom solution modules: Usually contain an extension of the existing logic other modules have. REST and GraphQL API: A set of APIs used to manage resources. REST API is mainly used to build integration and interact with Virto resources, while GraphQL represents an implementation of the Back End for Front End design pattern and provides a lightweight access to ecommerce capabilities for various storefront applications.","title":"Conceptual Overview"},{"location":"Fundamentals/Caching/01-overview-in-progress/","text":"Overview Caching is one of the most effective ways to improve website performance. We at Virto Commerce have so far used a few various ways to cache application data to reduce the load on the external services and database, and minimize the application latency when handling API requests. In this article, we will describe the technical details and the best caching practices we employ in our platform. Cache-Aside Pattern Overview We opted for Cache-Aside as the main pattern for all caching logic, since it is very simple and straightforward for implementation and testing. The pattern enables applications to load data on demand: When we need specific data, we first try to get it from the cache. If the data is not in the cache, we get it from the source, add it to the cache, and return it. Next time, this data will be returned from the cache. This pattern improves performance and also helps maintain consistency between the data held in the cache and data in the underlying storage. Memory vs Distributed Cache We do not use distributed cache in the platform code, because we want to keep the platform configuration flexible and simple and prefer to solve potential scalability issues by other means (see Scaling below). There are three additional cons of using distributed cache that influenced our decision: All cached data must support serialization and deserialization, which is not always possible with distributed cache. Compared to memory cache, distributed cache has somewhat worse performance due to network latency. Using both memory and distributed cache leads to complexity. Cache-Aside Basic Implementation For platform cache, we experimented with IMemoryCache that stores cached data within the memory. A simple Cache-Aside pattern implementation using IMemoryCache looks like this: 1 public objec t Ge t Da ta ById(s tr i n g objec t Id) 2 { 3 objec t da ta ; 4 i f (! t his._memoryCache.TryGe t Value($ \"cache-key-{objectId}\" , ou t da ta )) 5 { 6 da ta = t his.Ge t Objec t FromDa ta base(objec t Id); 7 t his._memoryCache.Se t ($ \"cache-key-{objectId}\" , da ta , ne w TimeSpa n ( 0 , 5 , 0 )); 8 } 9 re turn da ta ; 10 } This code has a few disadvantages: It contains too many lines and must be simplified. It requires manual creation of the cache key, which cannot guarantee its uniqueness. It does not protect against race conditions when multiple streams will try to access the same cache key simultaneously, which may lead to excess data eviction. This may not be an issue, unless your application has a high concurrent load and costly back end requests, or the back end is not designed to handle simultaneous requests. It assumes you would be manually controlling the cached data lifetime. Choosing proper values for the lifetime is a complicated task and reduces developer's productivity. With the relatively new MemoryCache methods, GetOrCreate and GetOrCreateAsync , the above issues are here to stay, which means one cannot use them on an as-is basis either. To see the bigger picture and learn more about the GetOrCreate method, you can refer to this article . What We Did to Improve Code To solve the issues we mentioned above, we defined our own IMemoryCacheExtensions . This implementation ensures that cached delegates (cache misses) are called only once, even if multiple threads are accessing the cache concurrently under race conditions. In addition, this extension provides a more compact syntax for the client code. Here is a variation of the previous code example with a new extension: 1 public objec t Ge t Da ta ById(s tr i n g objec t Id) 2 { 3 objec t da ta ; 4 var cacheKey = CacheKey.Wi t h(Ge t Type() , na meo f (Ge t Da ta ById) , id); 5 var da ta = _memoryCache.Ge t OrCrea te Exclusive(cacheKey , cacheE ntr y => 6 { 7 cacheE ntr y.AddExpira t io n Toke n (MyCacheRegio n .Crea te Cha n geToke n ()); 8 re turn t his.Ge t Objec t FromDa ta base(objec t Id); 9 } ); 10 re turn da ta ; 11 } Now, some notes to the code: Line 4: Cache key generation. A special static class, CacheKey , provides a method for unique string cache key generation according to the arguments and type and method of the information being transferred. Here is an example: CacheKey.With(GetType(), nameof(GetDataById), \"123\"); /* => \"TypeName:GetDataById-123\" */ CacheKey can also be used to generate cache keys for complex object types. Most of the platform types are derived from the Entity or ValueObject classes, each of those implementing the ICacheKey interface that contains the GetCacheKey() method, which can be used for cache key generation. The following code sample shows how to create a cache key for a complex object type: 1 class ComplexValueObjec t : ValueObjec t 2 { 3 public s tr i n g Prop 1 { ge t ; se t ; } 4 public s tr i n g Prop 2 { ge t ; se t ; } 5 } 6 7 var valueObj = ne w ComplexValueObjec t { Prop 1 = \"Prop1Value\" , Prop 2 = \"Prop2Value\" } ; 8 var da ta = CacheKey.Wi t h(valueObj.Ge t CacheKey()); 10 //cacheKey will take the \"Prop1Value-Prop2Value\" value Line 5: Thread-safe caching and avoiding race conditions. The _memoryCache.GetOrCreateExclusive() method calls a thread-safe caching extension that guarantees that the cacheable delegate (cache miss) should run only once in a multiple thread race. An asynchronous version of this extension method, _memoryCache.GetOrCreateExclusiveAsync() , is also available. The following code sample shows how this exclusive access to the cacheable delegate works: 1 public void Ge t OrCrea te Exclusive() 2 { 3 var su t = ne w MemoryCache(); 4 i nt cou nter = 0 ; 5 Parallel.ForEach(E nu merable.Ra n ge( 1 , 10 ) , i => 6 { 7 var i te m = su t .Ge t OrCrea te Exclusive( \"test-key\" , cacheE ntr y => 8 { 9 cacheE ntr y.Slidi n gExpira t io n = TimeSpa n .FromSeco n ds( 10 ); 10 re turn I nterl ocked.I n creme nt (re f cou nter ); 11 } ); 12 Co ns ole.Wri te ($ \"{item} \" ); 13 } ); 14 } This will output the following: 1 1 1 1 1 1 1 1 1 1 Line 7: Cache expiration and eviction. We get a CancellationTokenSource object that is associated with the cache data and a strongly typed cache region, which allows multiple cache entries to be evicted as a group (see ASP.NET Core Memory Cache Dependencies ). Warning We intentionally disable the inheritance for cached entry expiration tokens and time-based expiration settings. When one cache entry is used to create another, the child copies the parent entry expiration settings and cannot get expired by manually removing or updating the parent entry. This leads to unpredictable side effects, and it is hard to maintain and debug such cache dependencies. We avoid manual control of the cached data lifetime in our code. The platform has a special CachingOptions object that contains the settings for Absolute or Sliding lifetimes for all cached data (see below). Thanks to the Clean Architecture and the Bounded contexts, where each boundary controls all read and change operations for the data belonging to the domain, we can always keep the cache updated and evict modified data from it explicitly. Strongly Typed Cache Regions The platform supports a construct called strongly typed cache regions that is used to control a set of cache keys and provides the tools to evict grouped or related data from the cache to keep the latter consistent. To define your own cache region, you need to derive it from CancellableCacheRegion<> . Then, the ExpireRegion method can be used to remove all keys within a single region: 1 //Region definition 2 public s tat ic class MyCacheRegio n : Ca n cellableCacheRegio n <MyCacheRegio n > 3 { 4 } 5 6 //Usage 7 cacheE ntr y.AddExpira t io n Toke n (MyCacheRegio n .Crea te Cha n geToke n ()); 8 9 //Expire all data associated with the region 10 MyCacheRegio n .ExpireRegio n (); There is also a special GlobalCacheRegion that can be used to expire all cached data of the entire application: 1 //Expire all cached data for entire application 2 GlobalCacheRegio n .ExpireRegio n (); Caching Null Values By default, the platform caches null values. If you opt for negative caching, this default behavior can be changed by providing the false value to cacheNullValue in the GetOrCreateExclusive method, e.g.: var da ta = _memoryCache.Ge t OrCrea te Exclusive(cacheKey , cacheE ntr y => {}, cacheNullValue : false ); Cache Settings To learn how to configure cache settings, see this article . Scaling Running multiple platform instances, each with its own local cache, and which in turn must be consistent with the cache of other instances, can be challenging. Without solving this problem, each instance of the application will have inconsistent data, which will definitely dissatisfy Virto Commerce customers. This article by Virto Commerce will explain to you how to configure Redis service as a cache backplane to sync local cache for multiple platform instances. Summary To wrap it up, here are some rules to follow and notes to consider: We only use in-memory cache by default (neither distributed nor mixed). When performing platform scale out configuration, you need to have a Redis server configured as a backplane to sync cached data in memory for multiple platform instances in a consistent state. The IMemoryCacheExtensions extension contains sync and async extension methods that represent a compact version of the Cache-Aside pattern implementation based on the ASP.NET Core IMemoryCache interface and provide exclusive access to the original data under race conditions. In order to avoid issues with stale cached data, always keep your cached data in a consistent state using the strongly typed cache regions that enable evicting groups of data. The platform uses an aggressive caching policy for most DAL services, even when caching large search results. Do not use relative size metrics for cached data, as it may lead to high memory utilization in some production scenarios. Play with the CacheSlidingExpiration and CacheAbsoluteExpiration values to find an optimal balance of memory consumption and application performance. Additional resources To learn more about the things covered by this article, you might also want to check out these sources: Caching in ASP.NET by Microsoft Caching in Azure by Microsoft Cache Configuration by Virto Commerce","title":"Overview"},{"location":"Fundamentals/Caching/01-overview-in-progress/#overview","text":"Caching is one of the most effective ways to improve website performance. We at Virto Commerce have so far used a few various ways to cache application data to reduce the load on the external services and database, and minimize the application latency when handling API requests. In this article, we will describe the technical details and the best caching practices we employ in our platform.","title":"Overview"},{"location":"Fundamentals/Caching/01-overview-in-progress/#cache-aside-pattern-overview","text":"We opted for Cache-Aside as the main pattern for all caching logic, since it is very simple and straightforward for implementation and testing. The pattern enables applications to load data on demand: When we need specific data, we first try to get it from the cache. If the data is not in the cache, we get it from the source, add it to the cache, and return it. Next time, this data will be returned from the cache. This pattern improves performance and also helps maintain consistency between the data held in the cache and data in the underlying storage.","title":"Cache-Aside Pattern Overview"},{"location":"Fundamentals/Caching/01-overview-in-progress/#memory-vs-distributed-cache","text":"We do not use distributed cache in the platform code, because we want to keep the platform configuration flexible and simple and prefer to solve potential scalability issues by other means (see Scaling below). There are three additional cons of using distributed cache that influenced our decision: All cached data must support serialization and deserialization, which is not always possible with distributed cache. Compared to memory cache, distributed cache has somewhat worse performance due to network latency. Using both memory and distributed cache leads to complexity.","title":"Memory vs Distributed Cache"},{"location":"Fundamentals/Caching/01-overview-in-progress/#cache-aside-basic-implementation","text":"For platform cache, we experimented with IMemoryCache that stores cached data within the memory. A simple Cache-Aside pattern implementation using IMemoryCache looks like this: 1 public objec t Ge t Da ta ById(s tr i n g objec t Id) 2 { 3 objec t da ta ; 4 i f (! t his._memoryCache.TryGe t Value($ \"cache-key-{objectId}\" , ou t da ta )) 5 { 6 da ta = t his.Ge t Objec t FromDa ta base(objec t Id); 7 t his._memoryCache.Se t ($ \"cache-key-{objectId}\" , da ta , ne w TimeSpa n ( 0 , 5 , 0 )); 8 } 9 re turn da ta ; 10 } This code has a few disadvantages: It contains too many lines and must be simplified. It requires manual creation of the cache key, which cannot guarantee its uniqueness. It does not protect against race conditions when multiple streams will try to access the same cache key simultaneously, which may lead to excess data eviction. This may not be an issue, unless your application has a high concurrent load and costly back end requests, or the back end is not designed to handle simultaneous requests. It assumes you would be manually controlling the cached data lifetime. Choosing proper values for the lifetime is a complicated task and reduces developer's productivity. With the relatively new MemoryCache methods, GetOrCreate and GetOrCreateAsync , the above issues are here to stay, which means one cannot use them on an as-is basis either. To see the bigger picture and learn more about the GetOrCreate method, you can refer to this article .","title":"Cache-Aside Basic Implementation"},{"location":"Fundamentals/Caching/01-overview-in-progress/#what-we-did-to-improve-code","text":"To solve the issues we mentioned above, we defined our own IMemoryCacheExtensions . This implementation ensures that cached delegates (cache misses) are called only once, even if multiple threads are accessing the cache concurrently under race conditions. In addition, this extension provides a more compact syntax for the client code. Here is a variation of the previous code example with a new extension: 1 public objec t Ge t Da ta ById(s tr i n g objec t Id) 2 { 3 objec t da ta ; 4 var cacheKey = CacheKey.Wi t h(Ge t Type() , na meo f (Ge t Da ta ById) , id); 5 var da ta = _memoryCache.Ge t OrCrea te Exclusive(cacheKey , cacheE ntr y => 6 { 7 cacheE ntr y.AddExpira t io n Toke n (MyCacheRegio n .Crea te Cha n geToke n ()); 8 re turn t his.Ge t Objec t FromDa ta base(objec t Id); 9 } ); 10 re turn da ta ; 11 } Now, some notes to the code: Line 4: Cache key generation. A special static class, CacheKey , provides a method for unique string cache key generation according to the arguments and type and method of the information being transferred. Here is an example: CacheKey.With(GetType(), nameof(GetDataById), \"123\"); /* => \"TypeName:GetDataById-123\" */ CacheKey can also be used to generate cache keys for complex object types. Most of the platform types are derived from the Entity or ValueObject classes, each of those implementing the ICacheKey interface that contains the GetCacheKey() method, which can be used for cache key generation. The following code sample shows how to create a cache key for a complex object type: 1 class ComplexValueObjec t : ValueObjec t 2 { 3 public s tr i n g Prop 1 { ge t ; se t ; } 4 public s tr i n g Prop 2 { ge t ; se t ; } 5 } 6 7 var valueObj = ne w ComplexValueObjec t { Prop 1 = \"Prop1Value\" , Prop 2 = \"Prop2Value\" } ; 8 var da ta = CacheKey.Wi t h(valueObj.Ge t CacheKey()); 10 //cacheKey will take the \"Prop1Value-Prop2Value\" value Line 5: Thread-safe caching and avoiding race conditions. The _memoryCache.GetOrCreateExclusive() method calls a thread-safe caching extension that guarantees that the cacheable delegate (cache miss) should run only once in a multiple thread race. An asynchronous version of this extension method, _memoryCache.GetOrCreateExclusiveAsync() , is also available. The following code sample shows how this exclusive access to the cacheable delegate works: 1 public void Ge t OrCrea te Exclusive() 2 { 3 var su t = ne w MemoryCache(); 4 i nt cou nter = 0 ; 5 Parallel.ForEach(E nu merable.Ra n ge( 1 , 10 ) , i => 6 { 7 var i te m = su t .Ge t OrCrea te Exclusive( \"test-key\" , cacheE ntr y => 8 { 9 cacheE ntr y.Slidi n gExpira t io n = TimeSpa n .FromSeco n ds( 10 ); 10 re turn I nterl ocked.I n creme nt (re f cou nter ); 11 } ); 12 Co ns ole.Wri te ($ \"{item} \" ); 13 } ); 14 } This will output the following: 1 1 1 1 1 1 1 1 1 1 Line 7: Cache expiration and eviction. We get a CancellationTokenSource object that is associated with the cache data and a strongly typed cache region, which allows multiple cache entries to be evicted as a group (see ASP.NET Core Memory Cache Dependencies ). Warning We intentionally disable the inheritance for cached entry expiration tokens and time-based expiration settings. When one cache entry is used to create another, the child copies the parent entry expiration settings and cannot get expired by manually removing or updating the parent entry. This leads to unpredictable side effects, and it is hard to maintain and debug such cache dependencies. We avoid manual control of the cached data lifetime in our code. The platform has a special CachingOptions object that contains the settings for Absolute or Sliding lifetimes for all cached data (see below). Thanks to the Clean Architecture and the Bounded contexts, where each boundary controls all read and change operations for the data belonging to the domain, we can always keep the cache updated and evict modified data from it explicitly.","title":"What We Did to Improve Code"},{"location":"Fundamentals/Caching/01-overview-in-progress/#strongly-typed-cache-regions","text":"The platform supports a construct called strongly typed cache regions that is used to control a set of cache keys and provides the tools to evict grouped or related data from the cache to keep the latter consistent. To define your own cache region, you need to derive it from CancellableCacheRegion<> . Then, the ExpireRegion method can be used to remove all keys within a single region: 1 //Region definition 2 public s tat ic class MyCacheRegio n : Ca n cellableCacheRegio n <MyCacheRegio n > 3 { 4 } 5 6 //Usage 7 cacheE ntr y.AddExpira t io n Toke n (MyCacheRegio n .Crea te Cha n geToke n ()); 8 9 //Expire all data associated with the region 10 MyCacheRegio n .ExpireRegio n (); There is also a special GlobalCacheRegion that can be used to expire all cached data of the entire application: 1 //Expire all cached data for entire application 2 GlobalCacheRegio n .ExpireRegio n ();","title":"Strongly Typed Cache Regions"},{"location":"Fundamentals/Caching/01-overview-in-progress/#caching-null-values","text":"By default, the platform caches null values. If you opt for negative caching, this default behavior can be changed by providing the false value to cacheNullValue in the GetOrCreateExclusive method, e.g.: var da ta = _memoryCache.Ge t OrCrea te Exclusive(cacheKey , cacheE ntr y => {}, cacheNullValue : false );","title":"Caching Null Values"},{"location":"Fundamentals/Caching/01-overview-in-progress/#cache-settings","text":"To learn how to configure cache settings, see this article .","title":"Cache Settings"},{"location":"Fundamentals/Caching/01-overview-in-progress/#scaling","text":"Running multiple platform instances, each with its own local cache, and which in turn must be consistent with the cache of other instances, can be challenging. Without solving this problem, each instance of the application will have inconsistent data, which will definitely dissatisfy Virto Commerce customers. This article by Virto Commerce will explain to you how to configure Redis service as a cache backplane to sync local cache for multiple platform instances.","title":"Scaling"},{"location":"Fundamentals/Caching/01-overview-in-progress/#summary","text":"To wrap it up, here are some rules to follow and notes to consider: We only use in-memory cache by default (neither distributed nor mixed). When performing platform scale out configuration, you need to have a Redis server configured as a backplane to sync cached data in memory for multiple platform instances in a consistent state. The IMemoryCacheExtensions extension contains sync and async extension methods that represent a compact version of the Cache-Aside pattern implementation based on the ASP.NET Core IMemoryCache interface and provide exclusive access to the original data under race conditions. In order to avoid issues with stale cached data, always keep your cached data in a consistent state using the strongly typed cache regions that enable evicting groups of data. The platform uses an aggressive caching policy for most DAL services, even when caching large search results. Do not use relative size metrics for cached data, as it may lead to high memory utilization in some production scenarios. Play with the CacheSlidingExpiration and CacheAbsoluteExpiration values to find an optimal balance of memory consumption and application performance.","title":"Summary"},{"location":"Fundamentals/Caching/01-overview-in-progress/#additional-resources","text":"To learn more about the things covered by this article, you might also want to check out these sources: Caching in ASP.NET by Microsoft Caching in Azure by Microsoft Cache Configuration by Virto Commerce","title":"Additional resources"},{"location":"Fundamentals/Caching/02-cache-configuration/","text":"Configuring Cache Cache configuration is commonly provided by the Caching section of the appsettings.json files: appsettings.json 1 \"Caching\" : { 2 \"CacheEnabled\" : true , 3 \"CacheSlidingExpiration\" : \"0:15:00\" , 4 //\"CacheAbsoluteExpiration\": \"0:15:00\" 5 } Notes: CacheEnabled : Set to false to disable caching of application data for the entire application. CacheSlidingExpiration or CacheAbsoluteExpiration : Sets a sliding or absolute expiration time for all cached application data that does not have a manually configured expiration value.","title":"Cache Configuration"},{"location":"Fundamentals/Caching/02-cache-configuration/#configuring-cache","text":"Cache configuration is commonly provided by the Caching section of the appsettings.json files: appsettings.json 1 \"Caching\" : { 2 \"CacheEnabled\" : true , 3 \"CacheSlidingExpiration\" : \"0:15:00\" , 4 //\"CacheAbsoluteExpiration\": \"0:15:00\" 5 } Notes: CacheEnabled : Set to false to disable caching of application data for the entire application. CacheSlidingExpiration or CacheAbsoluteExpiration : Sets a sliding or absolute expiration time for all cached application data that does not have a manually configured expiration value.","title":"Configuring Cache"},{"location":"Fundamentals/Caching/03-setting-up-Redis/","text":"Setting up Redis Backplane for Scaling out Running multiple instances of your application, all accessing the same distributed cache, can be tricky. This article explains how and when you should use the cache backplane feature provided by Virto Commerce. Multi Level Caching Keeping the cached data in a consistent state is quite simple if you have a single instance application with a local cache storage. You can then easily control cache lifecycle and invalidation when entries are removed or deleted. It is, however, a totally different story when it comes to a scaled out application with multiple instances. The core issue here is how the instances would find out when the data was changed and the local cache data becomes irrelevant. Using distributed cache may be an option; nonetheless, we do not use distributed cache with the Virto platform because the network latency for the cached data degrades performance. Besides, such configuration would require serialization and deserialization support for all cached data, which is also hard to achieve. The point is to use local cache storage for each application instance, all of those being connected to the shared broadcasted service (backplane) and data through receiving invalidation messages. To resolve this task, we need a service, which all application instances would be connected to and which can broadcast messages when cache data becomes invalid. Redis may come in quite handy here, as it is an in-memory key-value storage that supports a messaging system with the publish/subscribe model. Virto's memory caching Redis backplane uses the pub/sub feature to forward messages to other servers. When one platform instance evicts some data from cache, the message for this event is transferred to the backplane. The backplane knows all connected clients and which servers they are on, and sends a message to all clients via their respective servers. The chart below shows how it all works: Implementing Cache Backplane Using Redis Pub/Sub Channel Redis Pub/Sub is used to send messages to the Redis server on any key change, clear cache, clear region, or remove key operation. Every cache instance with the same configuration gets subscribed to the same channel and can react on those messages to keep other cache handles in sync with the master. You can add a Redis cache backplane to the Virto platform at the stage of its configuration by copying the primary connection string ( StackExchange.Redis ) to Configuration : - For local deployment : Save the connection string with [ Secret Manager ]( https : //docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0#secret-manager) or `appsetting.json`. - For Azure based instance : Save the connection string in App Service Configuration or another secure storage . The following example shows you how to set up the Redis backplane for memory cache in appsettings.json : appsettings.json 1 \"ConnectionStrings\" : { 2 ... 3 //Add RedisConnectionString value to start using Redis server as backplane for memory cache synchronization 4 \"RedisConnectionString\" : \"vc.redis.cache.windows.net:6380,password={password}=,ssl=True,abortConnect=False\" 5 ... 6 }, Warning You will have to use the same RedisConnectionString for all platform instances, the local cache instances of which must also be synchronized. How It Works The backplane works with messages. Every time an item gets removed or updated, the platform will send a message to the backplane storing the information needed to update other clients. All other clients will receive those messages asynchronously and will react accordingly. When, for example, an item gets removed by one client, the other client has to remove the same item from all other cache handles but the source (because it was already removed). For the remove operations, this is not that important. Let's assume, however, that a cache item was updated by Client A, while Client B still has the old version in its local in-process cache. With the source being set, the platform can evict the item from all Client B's local in-process cache instances and, upon the next Get the new version request, will retrieve new version from the source. That being said, because of the network traffic generated and the overhead that occurs, the performance of the cache will slightly go down. Besides, the synchronization will not happen on all clients at the same time, which might lead to some delays, although very small ones. Additional Resources For those who want more information on the topic in question, here is a couple of useful links to start with: Redis Overview How to Scale out Platform Based on Azure","title":"Setting Up Redis Backplane for Scaling Out"},{"location":"Fundamentals/Caching/03-setting-up-Redis/#setting-up-redis-backplane-for-scaling-out","text":"Running multiple instances of your application, all accessing the same distributed cache, can be tricky. This article explains how and when you should use the cache backplane feature provided by Virto Commerce.","title":"Setting up Redis Backplane for Scaling out"},{"location":"Fundamentals/Caching/03-setting-up-Redis/#multi-level-caching","text":"Keeping the cached data in a consistent state is quite simple if you have a single instance application with a local cache storage. You can then easily control cache lifecycle and invalidation when entries are removed or deleted. It is, however, a totally different story when it comes to a scaled out application with multiple instances. The core issue here is how the instances would find out when the data was changed and the local cache data becomes irrelevant. Using distributed cache may be an option; nonetheless, we do not use distributed cache with the Virto platform because the network latency for the cached data degrades performance. Besides, such configuration would require serialization and deserialization support for all cached data, which is also hard to achieve. The point is to use local cache storage for each application instance, all of those being connected to the shared broadcasted service (backplane) and data through receiving invalidation messages. To resolve this task, we need a service, which all application instances would be connected to and which can broadcast messages when cache data becomes invalid. Redis may come in quite handy here, as it is an in-memory key-value storage that supports a messaging system with the publish/subscribe model. Virto's memory caching Redis backplane uses the pub/sub feature to forward messages to other servers. When one platform instance evicts some data from cache, the message for this event is transferred to the backplane. The backplane knows all connected clients and which servers they are on, and sends a message to all clients via their respective servers. The chart below shows how it all works:","title":"Multi Level Caching"},{"location":"Fundamentals/Caching/03-setting-up-Redis/#implementing-cache-backplane-using-redis-pubsub-channel","text":"Redis Pub/Sub is used to send messages to the Redis server on any key change, clear cache, clear region, or remove key operation. Every cache instance with the same configuration gets subscribed to the same channel and can react on those messages to keep other cache handles in sync with the master. You can add a Redis cache backplane to the Virto platform at the stage of its configuration by copying the primary connection string ( StackExchange.Redis ) to Configuration : - For local deployment : Save the connection string with [ Secret Manager ]( https : //docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0#secret-manager) or `appsetting.json`. - For Azure based instance : Save the connection string in App Service Configuration or another secure storage . The following example shows you how to set up the Redis backplane for memory cache in appsettings.json : appsettings.json 1 \"ConnectionStrings\" : { 2 ... 3 //Add RedisConnectionString value to start using Redis server as backplane for memory cache synchronization 4 \"RedisConnectionString\" : \"vc.redis.cache.windows.net:6380,password={password}=,ssl=True,abortConnect=False\" 5 ... 6 }, Warning You will have to use the same RedisConnectionString for all platform instances, the local cache instances of which must also be synchronized.","title":"Implementing Cache Backplane Using Redis Pub/Sub Channel"},{"location":"Fundamentals/Caching/03-setting-up-Redis/#how-it-works","text":"The backplane works with messages. Every time an item gets removed or updated, the platform will send a message to the backplane storing the information needed to update other clients. All other clients will receive those messages asynchronously and will react accordingly. When, for example, an item gets removed by one client, the other client has to remove the same item from all other cache handles but the source (because it was already removed). For the remove operations, this is not that important. Let's assume, however, that a cache item was updated by Client A, while Client B still has the old version in its local in-process cache. With the source being set, the platform can evict the item from all Client B's local in-process cache instances and, upon the next Get the new version request, will retrieve new version from the source. That being said, because of the network traffic generated and the overhead that occurs, the performance of the cache will slightly go down. Besides, the synchronization will not happen on all clients at the same time, which might lead to some delays, although very small ones.","title":"How It Works"},{"location":"Fundamentals/Caching/03-setting-up-Redis/#additional-resources","text":"For those who want more information on the topic in question, here is a couple of useful links to start with: Redis Overview How to Scale out Platform Based on Azure","title":"Additional Resources"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/","text":"Appsettings.json As Virto Commerce Platform (VC Platform) is an ASP.NET Core based application, it can be configured as described in this Microsoft article . Configuration Settings The configuration keys are hierarchic, and the most convenient way to manage them is working with the appsettings.json file. The sections below, broken down by configuration nodes, show the overall file structure, provide default values, and explain what each key is about. Note All settings listed below are optional unless marked Required . ConnectionStrings These required settings represent connection strings for VC Platform and modules. Node Default or Sample Value Description VirtoCommerce E.g., Data Source=(local);Initial Catalog=VirtoCommerce3;Persist Security Info=True;User ID=virto;Password=virto; MultipleActiveResultSets=True;Connect Timeout=30 This required setting is for providing VC Platform system connection string to the SQL Server database. VC modules would revert to this connection string in case no specific connection string was defined. E.g., VirtoCommerce.Catalog E.g., Data Source=(local);Initial Catalog=VirtoCommerceCatalog;Persist Security Info=True;User ID=virto;Password=virto; MultipleActiveResultSets=True;Connect Timeout=30 Other module-specific connection string(s). E.g., Virto Commerce Catalog module would use VirtoCommerce.Catalog connection string in case it is defined. RedisConnectionString E.g., \"localhost\" StackExchange.Redis Configuration string. Check Redis Configuration for details. VirtoCommerce This configuration node defines VC Platform system settings. Node Default or Sample Value Description CountriesFilePath \"localization/common/countries.json\" Local path for the country list, which, by default, includes all countries of the world. CountryRegionsFilePath \"localization/common/countriesRegions.json\" Local path for state/province list. By default, includes the US states and Canada's provinces. LicenseActivationUrl \"https://virtocommerce.com/admin/api/licenses/activate/\" VC Platform license activation service URL LicenseFilePath \"App_Data/VirtoCommerce.lic\" VC Platform license file location LocalUploadFolderPath \"App_Data/Uploads\" The Uploads folder location SampleDataUrl E.g., \"http://virtocommerce.azureedge.net/sample-data\" URL to download sample data upon the initial Platform setup DiscoveryPath \"./Modules\" Relative or absolute folder location where the platform will discover the installed modules from AllowInsecureHttp false Manages how the OpenID Connect server (ASOS) handles the incoming requests: whether those arriving to non-HTTPS endpoints should be rejected or not. By default, this property is set to false to help mitigate the man-in-the-middle attacks. Hangfire Background processing library (Hangfire) configuration. JobStorageType : Current job storage. Supported values: Memory , SqlServer . UseHangfireServer : Enables or disables Hangfire for this app instance. AutomaticRetryCount : Maximum number of automatic retry attempts. SqlServerStorageOptions : Hangfire.SqlServer.SqlServerStorageOptions. Check Hangfire's SQL Server Configuration documentation for details. Swagger Allows you to disable Swagger initialization upon platform startup to prevent access to Swagger UI and documents. FileExtensionsBlackList This setting is used together with the VirtoCommerce.Platform.Security.FileExtensionsBlackList setting (admin UI) to set the extensions of the files the platform does not permit to upload to the server. The FileExtensionsBlackList is not accessible from the admin UI. An administrator may provide an additional list of extensions through the UI that may be used with FileExtensionsBlackList . Examples Example settings for the Hangfire node: \"Hangfire\" : { \"JobStorageType\" : \"Memory\" , \"UseHangfireServer\" : true , \"AutomaticRetryCount\" : 1 , \"SqlServerStorageOptions\" : { \"CommandBatchMaxTimeout\" : \"00:05:00\" , \"SlidingInvisibilityTimeout\" : \"00:05:00\" , \"QueuePollInterval\" : \"00:00:00\" , \"UseRecommendedIsolationLevel\" : true , \"UsePageLocksOnDequeue\" : true , \"DisableGlobalLocks\" : true , \"EnableHeavyMigrations\" : true } } Example settings for the Swagger node: \"Swagger\" : { \"Disable\" : true } Example settings for the FileExtensionsBlackList node: \"FileExtensionsBlackList\" : [ \".pdf\" , \".json\" ] Assets This required setting determines how VC Platform will be working with assets, i.e. files. Node Default or Sample Value Description Provider \"FileSystem\" Current asset provider. Supported values: FileSystem, AzureBlobStorage. FileSystem File system based asset provider configuration. Used when the Provider setting has the FileSystem value. AzureBlobStorage Azure Blob Storage based asset provider configuration. Used when the Provider setting has the AzureBlobStorage value. Examples Example settings for the FileSystem node: \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"http://localhost:10645/assets/\" } Example settings for the AzureBlobStorage node: \"AzureBlobStorage\" : { \"ConnectionString\" : \"\" , \"CdnUrl\" : \"\" } IdentityOptions There are options to configure the ASP.NET Core Identity system. You might want to check out this guide for details. Node Description Password.PasswordHistory The number of recent user passwords to check during password validation. An old password cannot be reused for this number of cycles. If the value is set to 0 or not defined, the password history will be disabled. Password.RepeatedResetPasswordTimeLimit The time limit after which a user can request password reset. User.MaxPasswordAge The time span defining the maximum user password age until it expires. The user is forced to change the expired password upon login to the Platform Manager UI. If the value is set to 0 or not defined, password expiration will be disabled. User.RemindPasswordExpiryInDays Number of days to start showing password expiry warning in the Platform Manager UI. Used only when password expiration is enabled. ExternalModules This node configures external sources, from which modules are being installed. Node Default or Sample Value Description IncludePrerelease false Shows module versions marked as Prerelease if value is true . ModulesManifestUrl E.g., \"https://raw.githubusercontent.com/VirtoCommerce/vc-modules/master/modules_v3.json\" URL to the .json file that contains module manifests. AuthorizationToken The authorization token to access ModulesManifestUrl , added to the Authorization header, if specified. AutoInstallModuleBundles [\"commerce\"] Group(s) of modules to install automatically during the initial Platform setup. If you do not need to install anything here, provide an empty array. Caching This node manages caching configuration. Node Default or Sample Value Description Redis Redis configuration, which includes the message channel to use and number of times to retry. CacheEnabled true If set to true , cache entries are retained based on the expiration settings . Otherwise, cache entries will expire immediately. Used if ConnectionStrings:RedisConnectionString is not specified. CacheSlidingExpiration E.g., \"0:15:00\" Cache entry will expire if it has not been accessed in a set amount of time. Used in case CacheAbsoluteExpiration was not defined. CacheAbsoluteExpiration E.g., \"0:5:00\" Cache entry will expire after a set amount of time. Used in case RedisConnectionString was not specified. Examples Example settings for the Redis node: \"Redis\" : { \"ChannelName\" : \"VirtoCommerceChannel\" , \"BusRetryCount\" : 3 } Notifications This enables notification configuration for the VirtoCommerce.Notifications module. Node Default or Sample Value Description Gateway E.g., \"SendGrid\" The current notification sending gateway. The out of the box implemented and supported values are Smtp , SendGrid . DefaultSender E.g., \"noreply@gmail.com\" This required setting provides sender identification used by the current notification sending gateway. Smtp SMTP gateway configuration. Used if the Gateway setting has the Smtp value. SendGrid SendGrid gateway configuration. Used when the Gateway setting has the SendGrid value. Examples Example settings for the Smtp node: \"Smtp\" : { \"SmtpServer\" : \"http://smtp.gmail.com\" , \"Port\" : 587 , \"Login\" : \"my-login\" , \"Password\" : \"my-password\" } Example settings for the SendGrid node: \"SendGrid\" : { \"ApiKey\" : \"my-SendGrid-Api-Key\" } Search This configures full text search for the VirtoCommerce.Search module. Node Default or Sample Value Description Provider E.g., \"Lucene\" This required setting specifies the current search provider. The supported values are Lucene , AzureSearch , and ElasticSearch . Scope E.g., \"default\" This setting determines the scope to use and is required . Lucene Lucene provider configuration for the VirtoCommerce.LuceneSearch module. Used when the Provider setting has the Lucene vaue. AzureSearch AzureSearch provider configuration for the VirtoCommerce.AzureSearch module. Used when the Provider setting has the AzureSearch value. ElasticSearch Elasticsearch provider configuration for the VirtoCommerce.ElasticSearch module. Used when the Provider setting has the ElasticSearch value. Examples Example settings for the Lucene node: \"Lucene\" : { \"Path\" : \"App_Data/Lucene\" } Example settings for the AzureSearch node: \"AzureSearch\" : { \"SearchServiceName\" : \"my-ServiceName\" , \"Key\" : \"my-AccessKey\" } Example settings for the ElasticSearch node: \"ElasticSearch\" : { \"Server\" : \"localhost:9200\" , \"User\" : \"elastic\" , \"Key\" : \"\" , \"EnableHttpCompression\" : \"\" } Content This required setting is used for static content configuration (including themes) for the VirtoCommerce.Content module. Node Default or Sample Value Description Provider \"FileSystem\" Current content (file) provider. The supported values are FileSystem and AzureBlobStorage . FileSystem File system based content provider configuration. This is the default provider used unless AzureBlobStorage is set as the current provider. AzureBlobStorage Azure Blob Storage based content provider configuration. Used when the Provider setting has AzureBlobStorage as value. Examples Example settings for the FileSystem node: \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"http://localhost:10645/cms-content/\" } Example settings for the AzureBlobStorage node: \"AzureBlobStorage\" : { \"ConnectionString\" : \"\" , \"CdnUrl\" : \"\" } AzureAd This node is used for authentication with Azure Active Directory. Check how to enable authentication with Azure Active Directory for details. Node Default or Sample Value Description Enabled false Enables authentication with Azure Active Directory. By default, this value is false , i.e. the authentication is deisabled. UsePreferredUsername false If set to true , the system will check the preffered_username in case the upn claim returns empty. Priority 0 Configures the priority of the Azure Active Directory login popup on the Login page. The lowest value means the highest priority. PasswordLogin This node enables authentication with username and password. Node Default or Sample Value Description Enabled true Always enabled by default. Setting to false will disable logging in with username and password. Priority 0 Configures the priority of the password login popup on the Login page. The lowest value means the highest priority. LoginPageUI This node is used for configuration of the background screen and background pattern of the Login page. Node Default or Sample Value Description BackgroundUrl Login page background URI. If set, takes priority over the preset. PatternUrl Login page background pattern URI. If set, takes priority over the preset. Preset demo Login page background preset name. If set, searches the preset from the preset list and applies BackgroundUrl and PatternUrl from it. Presets A list of background presets. Examples Example settings for the Presets node: [ { \"Name\" : \"demo\" , \"BackgroundUrl\" : \"images/login_background.png\" , \"PatternUrl\" : \"/images/pattern-demo.svg\" }, { \"Name\" : \"prod\" , \"BackgroundUrl\" : \"\" , \"PatternUrl\" : \"/images/pattern-live.svg\" } ] Hierarchic Keys and Separators When working with keys, one should follow these rules: Within the Configuration API, a colon separator ( : ) works on all platforms. In environment variables, a colon separator may not work on all platforms. A double underscore, __ , is supported by all platforms and is automatically converted into a colon : . In Azure Key Vault, hierarchic keys use double hyphen -- as a separator. The Azure Key Vault configuration provider automatically replaces -- with a : when the secrets are loaded into the app configuration. The images below show some examples of using the above rules: Configuring ElasticSearch on localhost in the appsettings.json file Configuring VirtoCommerce ConnectionString and other settings through environment variables in the docker-compose.yml file Configuring AzureSearch and other settings trough the Application settings in Azure You can find more details in this ASP.NET configuration guide .","title":"Appsettings.json"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#appsettingsjson","text":"As Virto Commerce Platform (VC Platform) is an ASP.NET Core based application, it can be configured as described in this Microsoft article .","title":"Appsettings.json"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#configuration-settings","text":"The configuration keys are hierarchic, and the most convenient way to manage them is working with the appsettings.json file. The sections below, broken down by configuration nodes, show the overall file structure, provide default values, and explain what each key is about. Note All settings listed below are optional unless marked Required .","title":"Configuration Settings"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#connectionstrings","text":"These required settings represent connection strings for VC Platform and modules. Node Default or Sample Value Description VirtoCommerce E.g., Data Source=(local);Initial Catalog=VirtoCommerce3;Persist Security Info=True;User ID=virto;Password=virto; MultipleActiveResultSets=True;Connect Timeout=30 This required setting is for providing VC Platform system connection string to the SQL Server database. VC modules would revert to this connection string in case no specific connection string was defined. E.g., VirtoCommerce.Catalog E.g., Data Source=(local);Initial Catalog=VirtoCommerceCatalog;Persist Security Info=True;User ID=virto;Password=virto; MultipleActiveResultSets=True;Connect Timeout=30 Other module-specific connection string(s). E.g., Virto Commerce Catalog module would use VirtoCommerce.Catalog connection string in case it is defined. RedisConnectionString E.g., \"localhost\" StackExchange.Redis Configuration string. Check Redis Configuration for details.","title":"ConnectionStrings"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#virtocommerce","text":"This configuration node defines VC Platform system settings. Node Default or Sample Value Description CountriesFilePath \"localization/common/countries.json\" Local path for the country list, which, by default, includes all countries of the world. CountryRegionsFilePath \"localization/common/countriesRegions.json\" Local path for state/province list. By default, includes the US states and Canada's provinces. LicenseActivationUrl \"https://virtocommerce.com/admin/api/licenses/activate/\" VC Platform license activation service URL LicenseFilePath \"App_Data/VirtoCommerce.lic\" VC Platform license file location LocalUploadFolderPath \"App_Data/Uploads\" The Uploads folder location SampleDataUrl E.g., \"http://virtocommerce.azureedge.net/sample-data\" URL to download sample data upon the initial Platform setup DiscoveryPath \"./Modules\" Relative or absolute folder location where the platform will discover the installed modules from AllowInsecureHttp false Manages how the OpenID Connect server (ASOS) handles the incoming requests: whether those arriving to non-HTTPS endpoints should be rejected or not. By default, this property is set to false to help mitigate the man-in-the-middle attacks. Hangfire Background processing library (Hangfire) configuration. JobStorageType : Current job storage. Supported values: Memory , SqlServer . UseHangfireServer : Enables or disables Hangfire for this app instance. AutomaticRetryCount : Maximum number of automatic retry attempts. SqlServerStorageOptions : Hangfire.SqlServer.SqlServerStorageOptions. Check Hangfire's SQL Server Configuration documentation for details. Swagger Allows you to disable Swagger initialization upon platform startup to prevent access to Swagger UI and documents. FileExtensionsBlackList This setting is used together with the VirtoCommerce.Platform.Security.FileExtensionsBlackList setting (admin UI) to set the extensions of the files the platform does not permit to upload to the server. The FileExtensionsBlackList is not accessible from the admin UI. An administrator may provide an additional list of extensions through the UI that may be used with FileExtensionsBlackList .","title":"VirtoCommerce"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#examples","text":"Example settings for the Hangfire node: \"Hangfire\" : { \"JobStorageType\" : \"Memory\" , \"UseHangfireServer\" : true , \"AutomaticRetryCount\" : 1 , \"SqlServerStorageOptions\" : { \"CommandBatchMaxTimeout\" : \"00:05:00\" , \"SlidingInvisibilityTimeout\" : \"00:05:00\" , \"QueuePollInterval\" : \"00:00:00\" , \"UseRecommendedIsolationLevel\" : true , \"UsePageLocksOnDequeue\" : true , \"DisableGlobalLocks\" : true , \"EnableHeavyMigrations\" : true } } Example settings for the Swagger node: \"Swagger\" : { \"Disable\" : true } Example settings for the FileExtensionsBlackList node: \"FileExtensionsBlackList\" : [ \".pdf\" , \".json\" ]","title":"Examples"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#assets","text":"This required setting determines how VC Platform will be working with assets, i.e. files. Node Default or Sample Value Description Provider \"FileSystem\" Current asset provider. Supported values: FileSystem, AzureBlobStorage. FileSystem File system based asset provider configuration. Used when the Provider setting has the FileSystem value. AzureBlobStorage Azure Blob Storage based asset provider configuration. Used when the Provider setting has the AzureBlobStorage value.","title":"Assets"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#examples_1","text":"Example settings for the FileSystem node: \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"http://localhost:10645/assets/\" } Example settings for the AzureBlobStorage node: \"AzureBlobStorage\" : { \"ConnectionString\" : \"\" , \"CdnUrl\" : \"\" }","title":"Examples"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#identityoptions","text":"There are options to configure the ASP.NET Core Identity system. You might want to check out this guide for details. Node Description Password.PasswordHistory The number of recent user passwords to check during password validation. An old password cannot be reused for this number of cycles. If the value is set to 0 or not defined, the password history will be disabled. Password.RepeatedResetPasswordTimeLimit The time limit after which a user can request password reset. User.MaxPasswordAge The time span defining the maximum user password age until it expires. The user is forced to change the expired password upon login to the Platform Manager UI. If the value is set to 0 or not defined, password expiration will be disabled. User.RemindPasswordExpiryInDays Number of days to start showing password expiry warning in the Platform Manager UI. Used only when password expiration is enabled.","title":"IdentityOptions"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#externalmodules","text":"This node configures external sources, from which modules are being installed. Node Default or Sample Value Description IncludePrerelease false Shows module versions marked as Prerelease if value is true . ModulesManifestUrl E.g., \"https://raw.githubusercontent.com/VirtoCommerce/vc-modules/master/modules_v3.json\" URL to the .json file that contains module manifests. AuthorizationToken The authorization token to access ModulesManifestUrl , added to the Authorization header, if specified. AutoInstallModuleBundles [\"commerce\"] Group(s) of modules to install automatically during the initial Platform setup. If you do not need to install anything here, provide an empty array.","title":"ExternalModules"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#caching","text":"This node manages caching configuration. Node Default or Sample Value Description Redis Redis configuration, which includes the message channel to use and number of times to retry. CacheEnabled true If set to true , cache entries are retained based on the expiration settings . Otherwise, cache entries will expire immediately. Used if ConnectionStrings:RedisConnectionString is not specified. CacheSlidingExpiration E.g., \"0:15:00\" Cache entry will expire if it has not been accessed in a set amount of time. Used in case CacheAbsoluteExpiration was not defined. CacheAbsoluteExpiration E.g., \"0:5:00\" Cache entry will expire after a set amount of time. Used in case RedisConnectionString was not specified.","title":"Caching"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#examples_2","text":"Example settings for the Redis node: \"Redis\" : { \"ChannelName\" : \"VirtoCommerceChannel\" , \"BusRetryCount\" : 3 }","title":"Examples"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#notifications","text":"This enables notification configuration for the VirtoCommerce.Notifications module. Node Default or Sample Value Description Gateway E.g., \"SendGrid\" The current notification sending gateway. The out of the box implemented and supported values are Smtp , SendGrid . DefaultSender E.g., \"noreply@gmail.com\" This required setting provides sender identification used by the current notification sending gateway. Smtp SMTP gateway configuration. Used if the Gateway setting has the Smtp value. SendGrid SendGrid gateway configuration. Used when the Gateway setting has the SendGrid value.","title":"Notifications"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#examples_3","text":"Example settings for the Smtp node: \"Smtp\" : { \"SmtpServer\" : \"http://smtp.gmail.com\" , \"Port\" : 587 , \"Login\" : \"my-login\" , \"Password\" : \"my-password\" } Example settings for the SendGrid node: \"SendGrid\" : { \"ApiKey\" : \"my-SendGrid-Api-Key\" }","title":"Examples"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#search","text":"This configures full text search for the VirtoCommerce.Search module. Node Default or Sample Value Description Provider E.g., \"Lucene\" This required setting specifies the current search provider. The supported values are Lucene , AzureSearch , and ElasticSearch . Scope E.g., \"default\" This setting determines the scope to use and is required . Lucene Lucene provider configuration for the VirtoCommerce.LuceneSearch module. Used when the Provider setting has the Lucene vaue. AzureSearch AzureSearch provider configuration for the VirtoCommerce.AzureSearch module. Used when the Provider setting has the AzureSearch value. ElasticSearch Elasticsearch provider configuration for the VirtoCommerce.ElasticSearch module. Used when the Provider setting has the ElasticSearch value.","title":"Search"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#examples_4","text":"Example settings for the Lucene node: \"Lucene\" : { \"Path\" : \"App_Data/Lucene\" } Example settings for the AzureSearch node: \"AzureSearch\" : { \"SearchServiceName\" : \"my-ServiceName\" , \"Key\" : \"my-AccessKey\" } Example settings for the ElasticSearch node: \"ElasticSearch\" : { \"Server\" : \"localhost:9200\" , \"User\" : \"elastic\" , \"Key\" : \"\" , \"EnableHttpCompression\" : \"\" }","title":"Examples"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#content","text":"This required setting is used for static content configuration (including themes) for the VirtoCommerce.Content module. Node Default or Sample Value Description Provider \"FileSystem\" Current content (file) provider. The supported values are FileSystem and AzureBlobStorage . FileSystem File system based content provider configuration. This is the default provider used unless AzureBlobStorage is set as the current provider. AzureBlobStorage Azure Blob Storage based content provider configuration. Used when the Provider setting has AzureBlobStorage as value.","title":"Content"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#examples_5","text":"Example settings for the FileSystem node: \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"http://localhost:10645/cms-content/\" } Example settings for the AzureBlobStorage node: \"AzureBlobStorage\" : { \"ConnectionString\" : \"\" , \"CdnUrl\" : \"\" }","title":"Examples"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#azuread","text":"This node is used for authentication with Azure Active Directory. Check how to enable authentication with Azure Active Directory for details. Node Default or Sample Value Description Enabled false Enables authentication with Azure Active Directory. By default, this value is false , i.e. the authentication is deisabled. UsePreferredUsername false If set to true , the system will check the preffered_username in case the upn claim returns empty. Priority 0 Configures the priority of the Azure Active Directory login popup on the Login page. The lowest value means the highest priority.","title":"AzureAd"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#passwordlogin","text":"This node enables authentication with username and password. Node Default or Sample Value Description Enabled true Always enabled by default. Setting to false will disable logging in with username and password. Priority 0 Configures the priority of the password login popup on the Login page. The lowest value means the highest priority.","title":"PasswordLogin"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#loginpageui","text":"This node is used for configuration of the background screen and background pattern of the Login page. Node Default or Sample Value Description BackgroundUrl Login page background URI. If set, takes priority over the preset. PatternUrl Login page background pattern URI. If set, takes priority over the preset. Preset demo Login page background preset name. If set, searches the preset from the preset list and applies BackgroundUrl and PatternUrl from it. Presets A list of background presets.","title":"LoginPageUI"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#examples_6","text":"Example settings for the Presets node: [ { \"Name\" : \"demo\" , \"BackgroundUrl\" : \"images/login_background.png\" , \"PatternUrl\" : \"/images/pattern-demo.svg\" }, { \"Name\" : \"prod\" , \"BackgroundUrl\" : \"\" , \"PatternUrl\" : \"/images/pattern-live.svg\" } ]","title":"Examples"},{"location":"Fundamentals/Configuration-Reference/appsettingsjson/#hierarchic-keys-and-separators","text":"When working with keys, one should follow these rules: Within the Configuration API, a colon separator ( : ) works on all platforms. In environment variables, a colon separator may not work on all platforms. A double underscore, __ , is supported by all platforms and is automatically converted into a colon : . In Azure Key Vault, hierarchic keys use double hyphen -- as a separator. The Azure Key Vault configuration provider automatically replaces -- with a : when the secrets are loaded into the app configuration. The images below show some examples of using the above rules: Configuring ElasticSearch on localhost in the appsettings.json file Configuring VirtoCommerce ConnectionString and other settings through environment variables in the docker-compose.yml file Configuring AzureSearch and other settings trough the Application settings in Azure You can find more details in this ASP.NET configuration guide .","title":"Hierarchic Keys and Separators"},{"location":"Fundamentals/Data-Import/01-main-concept/","text":"Main Concept This article explains the architecture and behavior of Virto Commerce Import Framework, which allows you to easily import your data, such as product information, customers, categories, and much more, into the Virto Commerce platform. Overview VC Data Import allows you to define what kind of data you want to import into your application using custom configurable Import profiles where one determines what types of data to import and from which data sources. When using VC Data Import, you can leverage its key advantages: Manage user defined import profiles directly from the platform manager UI See the import history with detailed logs Work with an extensibility model that enables extending the existing built-in importers with new data types and sources Core Structure The chart below shows VC Data Import's high level logical structure: As you can clearly see, VC Data Import is based on three main objects: Import job : An object for a task that imports data according to ImportProfile ; you can run it both manually on-demand or regularly based on a schedule. Import profile : A user-defined entity with a unique name acting as its ID. Each profile must be associated with a certain Importer and also can be configured through the runtime parameters in Settings that Importer might provide. Importer : A piece of code that reads data from a specific data source file (CSV, XLS, etc.) and writes an object of a specific data type (products, prices, etc.) to the target system. Each Importer consists of the three main objects: DataReader , which reads data from a file (CSV, XSLS, YML, etc.) or another type of external source (a database, a web service, etc.); DataWriter that writes the imported objects into the system; and Settings , which provides settings that can be used to configure ImportProfile linked to the importer in question. Note You can also create your own data importers, which we explain here .","title":"Main Concept"},{"location":"Fundamentals/Data-Import/01-main-concept/#main-concept","text":"This article explains the architecture and behavior of Virto Commerce Import Framework, which allows you to easily import your data, such as product information, customers, categories, and much more, into the Virto Commerce platform.","title":"Main Concept"},{"location":"Fundamentals/Data-Import/01-main-concept/#overview","text":"VC Data Import allows you to define what kind of data you want to import into your application using custom configurable Import profiles where one determines what types of data to import and from which data sources. When using VC Data Import, you can leverage its key advantages: Manage user defined import profiles directly from the platform manager UI See the import history with detailed logs Work with an extensibility model that enables extending the existing built-in importers with new data types and sources","title":"Overview"},{"location":"Fundamentals/Data-Import/01-main-concept/#core-structure","text":"The chart below shows VC Data Import's high level logical structure: As you can clearly see, VC Data Import is based on three main objects: Import job : An object for a task that imports data according to ImportProfile ; you can run it both manually on-demand or regularly based on a schedule. Import profile : A user-defined entity with a unique name acting as its ID. Each profile must be associated with a certain Importer and also can be configured through the runtime parameters in Settings that Importer might provide. Importer : A piece of code that reads data from a specific data source file (CSV, XLS, etc.) and writes an object of a specific data type (products, prices, etc.) to the target system. Each Importer consists of the three main objects: DataReader , which reads data from a file (CSV, XSLS, YML, etc.) or another type of external source (a database, a web service, etc.); DataWriter that writes the imported objects into the system; and Settings , which provides settings that can be used to configure ImportProfile linked to the importer in question. Note You can also create your own data importers, which we explain here .","title":"Core Structure"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/","text":"Building Custom Data Importer This section will guide you through building your own data importer of a specific type. All steps described below are based on a real example of importing product images from a CSV file. Note Currently, we only support CSV for out-of-the-box import. You can, however, create your own file reader if you want to use a different format. Prerequisites Before you start creating your custom data importer, you need to check which components it should include. The chart below shows the essential components that need to be implemented into a new importer: Let's assume you have a CSV file to import your data from with two columns: productId and img_url . To enable importing multiple images per single product, you will need to use multiple rows with the same product ID. Now that you know which data your import file should include, you can proceed with the first step of creating a data importer. Since only the .csv format is currently supported for out-of-the-box import, you either need to create a .csv file in any preferred editor or can use this sample: productId, img_url 1, https://i.picsum.photos/id/537/200/300.jpg?hmac=LG3kZs5AdrMmsgeVOdrfP0C5KT3WmP-q5TauEZdR4vk 1, https://i.picsum.photos/id/514/200/300.jpg?hmac=2SFAKrM0w5MkU7I_tQM9mq1m6POUDSPrTYu5tb5Sqlg Custom CSV Mapping to Use with Default CsvDataReader Since we are going to use built-in CsvDataReader to read the data from the CSV file, and it uses the CsvHelper library for read and parse data, we do not need to define any new custom reader. Rather than that, we will define ClassMap (read more here ). For that purpose, you need to create a new file, CsvProductImageClassMap , with the following content: CsvProductImageClassMap.cs 1 public class CsvProductImageClassMap : ClassMap < ProductImage > 2 { 3 public CsvProductImageClassMap () 4 { 5 Map ( m => m . ProductId ); 6 Map ( m => m . ImageUrl ); 7 } 8 } This will map the class properties to the column headers of the CSV file. This example is identical to not using any class mapping at all when the headers match the property names. Defining Settings for Custom Importer Each importer might provide a set of settings that can be changed by user for any certain import profile instance. At this stage, we actually define the settings that will be used by our importer in the ProductImageImporterSettings.cs file: ProductImageImporterSettings.cs 1 public class ProductImageImporterSettings 2 { 3 public static SettingDescriptor DebugSetting { get ; } = new SettingDescriptor 4 { 5 Name = \"Vcmp.Import.ProductImage.Debug\" , 6 ValueType = SettingValueType . Boolean , 7 GroupName = \"Import\" , 8 DefaultValue = false 9 }; 10 11 public static IEnumerable < SettingDescriptor > AllSettings 12 { 13 get 14 { 15 yield return DebugSetting ; 16 } 17 } 18 } Creating DataWriter At this step, we will create a new class, naming it CsvProductImageWriter , with the following content: CsvProductImageWriter.cs 1 public sealed class CsvProductImageWriter : IImportDataWriter 2 { 3 private readonly bool _debug ; 4 public CsvProductImageWriter ( ImportContext context ) 5 { 6 _debug = Convert . ToBoolean ( context . ImportProfile . Settings . FirstOrDefault ( x => x . Name == ProductImageImporterSettings . DebugSetting . Name )?. Value ?? false ); 7 } 8 public Task WriteAsync ( object [] items , ImportContext context ) 9 { 10 var index = 0 ; 11 try 12 { 13 foreach ( var image in items . OfType < ProductImage >()) 14 { 15 var line = context . ProgressInfo . ProcessedCount + index ; 16 //TODO: Add code for adding image to product 17 if ( _debug ) 18 { 19 Debug . WriteLine ( $\"Line {line}: {image.ImageUrl} is added to product #{image.ProductId}\" ); 20 } 21 index ++; 22 } 23 } 24 catch ( Exception ex ) 25 { 26 var errorInfo = new ErrorInfo 27 { 28 ErrorLine = context . ProgressInfo . ProcessedCount + index , 29 ErrorMessage = ex . Message , 30 }; 31 context . ErrorCallback ( errorInfo ); 32 } 33 return Task . CompletedTask ; 34 } 35 36 public void Dispose () 37 { 38 //nothing to dispose 39 } 40 } Note Line 6: Getting a value for setting from the profile. This setting value can be provided by user for the particular import profile instance. Line 13: Creating a loop between passed objects of the ProductImage type. Inside this loop, you can add a piece of code that saves the passed object within the system. *Line 31: This line notifies the one who runs the importer about any possible error when writing the data being imported through context.ErrorCallback . Creating Custom Importer This is the central object in the DataImport extension system, as the object of this type is called by the system for all import operations. In order to define new importer, we will create a new class, CsvProductImageImporter , with the following content: CsvProductImageImporter.cs 1 public sealed class CsvProductImageImporter : IDataImporter 2 { 3 private readonly IBlobStorageProvider _blobStorageProvider ; 4 public CsvProductImageImporter ( IBlobStorageProvider blobStorageProvider ) 5 { 6 _blobStorageProvider = blobStorageProvider ; 7 } 8 /// <summary> 9 /// Descrimiator 10 /// </summary> 11 public string TypeName { get ; } = nameof ( CsvProductImageImporter ); 12 13 /// <summary> 14 /// Uses to pass some extra data fror importer to outside 15 /// </summary> 16 public Dictionary < string , string > Metadata { get ; private set ; } 17 18 /// <summary> 19 /// Avail settings that importer exposes and allows to edit by users 20 /// </summary> 21 public SettingDescriptor [] AvailSettings { get ; set ; } 22 23 public IImportDataReader OpenReader ( ImportContext context ) 24 { 25 if ( string . IsNullOrEmpty ( context . ImportProfile . ImportFileUrl )) 26 { 27 throw new OperationCanceledException ( $\"Import file must be set\" ); 28 } 29 var importStream = _blobStorageProvider . OpenRead ( context . ImportProfile . ImportFileUrl ); 30 31 return new CsvDataReader < ProductImage , CsvProductImageClassMap >( importStream , context ); 32 } 33 34 public IImportDataWriter OpenWriter ( ImportContext context ) 35 { 36 return new CsvProductImageWriter ( context ); 37 } 38 public object Clone () 39 { 40 var result = MemberwiseClone () as CsvProductImageImporter ; 41 return result ; 42 } 43 44 } Note Lines 23 and 34: Factory methods that return both the reader and writer and get executed by the import process manager. Registering Data Importer Now that we have everything at hand to wire up our new CsvProductImageImporter and run it, we add the following content to the module.cs file: module.cs 1 public void Initialize ( IServiceCollection serviceCollection ) 2 { 3 serviceCollection . AddTransient < CsvProductImageImporter >(); 4 } 5 public void PostInitialize ( IApplicationBuilder appBuilder ) 6 { 7 var importerRegistrar = appBuilder . ApplicationServices . GetService < IDataImporterRegistrar >(); 8 importerRegistrar . Register < CsvProductImageImporter >(() => appBuilder . ApplicationServices . GetService < CsvProductImageImporter >()) 9 . WithSettings ( CsvSettings . AllSettings ) 10 . WithSettings ( ProductImageImporterSettings . AllSettings ); 11 } Note Line 3: Registering CsvProductImageImporter in the DI Line 8: Registering CsvProductImageImporter in the global importer registry, so that the new importer may become available for import profile creation and for running the import process. Running Data Importer You can choose either of the following options to run your newly created data importer: Directly from UI as ImportProfile that has an assigned CsvProductImageImporter (TBA) Using code (TBA)","title":"Building Custom Importer"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#building-custom-data-importer","text":"This section will guide you through building your own data importer of a specific type. All steps described below are based on a real example of importing product images from a CSV file. Note Currently, we only support CSV for out-of-the-box import. You can, however, create your own file reader if you want to use a different format.","title":"Building Custom Data Importer"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#prerequisites","text":"Before you start creating your custom data importer, you need to check which components it should include. The chart below shows the essential components that need to be implemented into a new importer: Let's assume you have a CSV file to import your data from with two columns: productId and img_url . To enable importing multiple images per single product, you will need to use multiple rows with the same product ID. Now that you know which data your import file should include, you can proceed with the first step of creating a data importer. Since only the .csv format is currently supported for out-of-the-box import, you either need to create a .csv file in any preferred editor or can use this sample: productId, img_url 1, https://i.picsum.photos/id/537/200/300.jpg?hmac=LG3kZs5AdrMmsgeVOdrfP0C5KT3WmP-q5TauEZdR4vk 1, https://i.picsum.photos/id/514/200/300.jpg?hmac=2SFAKrM0w5MkU7I_tQM9mq1m6POUDSPrTYu5tb5Sqlg","title":"Prerequisites"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#custom-csv-mapping-to-use-with-default-csvdatareader","text":"Since we are going to use built-in CsvDataReader to read the data from the CSV file, and it uses the CsvHelper library for read and parse data, we do not need to define any new custom reader. Rather than that, we will define ClassMap (read more here ). For that purpose, you need to create a new file, CsvProductImageClassMap , with the following content: CsvProductImageClassMap.cs 1 public class CsvProductImageClassMap : ClassMap < ProductImage > 2 { 3 public CsvProductImageClassMap () 4 { 5 Map ( m => m . ProductId ); 6 Map ( m => m . ImageUrl ); 7 } 8 } This will map the class properties to the column headers of the CSV file. This example is identical to not using any class mapping at all when the headers match the property names.","title":"Custom CSV Mapping to Use with Default CsvDataReader"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#defining-settings-for-custom-importer","text":"Each importer might provide a set of settings that can be changed by user for any certain import profile instance. At this stage, we actually define the settings that will be used by our importer in the ProductImageImporterSettings.cs file: ProductImageImporterSettings.cs 1 public class ProductImageImporterSettings 2 { 3 public static SettingDescriptor DebugSetting { get ; } = new SettingDescriptor 4 { 5 Name = \"Vcmp.Import.ProductImage.Debug\" , 6 ValueType = SettingValueType . Boolean , 7 GroupName = \"Import\" , 8 DefaultValue = false 9 }; 10 11 public static IEnumerable < SettingDescriptor > AllSettings 12 { 13 get 14 { 15 yield return DebugSetting ; 16 } 17 } 18 }","title":"Defining Settings for Custom Importer"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#creating-datawriter","text":"At this step, we will create a new class, naming it CsvProductImageWriter , with the following content: CsvProductImageWriter.cs 1 public sealed class CsvProductImageWriter : IImportDataWriter 2 { 3 private readonly bool _debug ; 4 public CsvProductImageWriter ( ImportContext context ) 5 { 6 _debug = Convert . ToBoolean ( context . ImportProfile . Settings . FirstOrDefault ( x => x . Name == ProductImageImporterSettings . DebugSetting . Name )?. Value ?? false ); 7 } 8 public Task WriteAsync ( object [] items , ImportContext context ) 9 { 10 var index = 0 ; 11 try 12 { 13 foreach ( var image in items . OfType < ProductImage >()) 14 { 15 var line = context . ProgressInfo . ProcessedCount + index ; 16 //TODO: Add code for adding image to product 17 if ( _debug ) 18 { 19 Debug . WriteLine ( $\"Line {line}: {image.ImageUrl} is added to product #{image.ProductId}\" ); 20 } 21 index ++; 22 } 23 } 24 catch ( Exception ex ) 25 { 26 var errorInfo = new ErrorInfo 27 { 28 ErrorLine = context . ProgressInfo . ProcessedCount + index , 29 ErrorMessage = ex . Message , 30 }; 31 context . ErrorCallback ( errorInfo ); 32 } 33 return Task . CompletedTask ; 34 } 35 36 public void Dispose () 37 { 38 //nothing to dispose 39 } 40 } Note Line 6: Getting a value for setting from the profile. This setting value can be provided by user for the particular import profile instance. Line 13: Creating a loop between passed objects of the ProductImage type. Inside this loop, you can add a piece of code that saves the passed object within the system. *Line 31: This line notifies the one who runs the importer about any possible error when writing the data being imported through context.ErrorCallback .","title":"Creating DataWriter"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#creating-custom-importer","text":"This is the central object in the DataImport extension system, as the object of this type is called by the system for all import operations. In order to define new importer, we will create a new class, CsvProductImageImporter , with the following content: CsvProductImageImporter.cs 1 public sealed class CsvProductImageImporter : IDataImporter 2 { 3 private readonly IBlobStorageProvider _blobStorageProvider ; 4 public CsvProductImageImporter ( IBlobStorageProvider blobStorageProvider ) 5 { 6 _blobStorageProvider = blobStorageProvider ; 7 } 8 /// <summary> 9 /// Descrimiator 10 /// </summary> 11 public string TypeName { get ; } = nameof ( CsvProductImageImporter ); 12 13 /// <summary> 14 /// Uses to pass some extra data fror importer to outside 15 /// </summary> 16 public Dictionary < string , string > Metadata { get ; private set ; } 17 18 /// <summary> 19 /// Avail settings that importer exposes and allows to edit by users 20 /// </summary> 21 public SettingDescriptor [] AvailSettings { get ; set ; } 22 23 public IImportDataReader OpenReader ( ImportContext context ) 24 { 25 if ( string . IsNullOrEmpty ( context . ImportProfile . ImportFileUrl )) 26 { 27 throw new OperationCanceledException ( $\"Import file must be set\" ); 28 } 29 var importStream = _blobStorageProvider . OpenRead ( context . ImportProfile . ImportFileUrl ); 30 31 return new CsvDataReader < ProductImage , CsvProductImageClassMap >( importStream , context ); 32 } 33 34 public IImportDataWriter OpenWriter ( ImportContext context ) 35 { 36 return new CsvProductImageWriter ( context ); 37 } 38 public object Clone () 39 { 40 var result = MemberwiseClone () as CsvProductImageImporter ; 41 return result ; 42 } 43 44 } Note Lines 23 and 34: Factory methods that return both the reader and writer and get executed by the import process manager.","title":"Creating Custom Importer"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#registering-data-importer","text":"Now that we have everything at hand to wire up our new CsvProductImageImporter and run it, we add the following content to the module.cs file: module.cs 1 public void Initialize ( IServiceCollection serviceCollection ) 2 { 3 serviceCollection . AddTransient < CsvProductImageImporter >(); 4 } 5 public void PostInitialize ( IApplicationBuilder appBuilder ) 6 { 7 var importerRegistrar = appBuilder . ApplicationServices . GetService < IDataImporterRegistrar >(); 8 importerRegistrar . Register < CsvProductImageImporter >(() => appBuilder . ApplicationServices . GetService < CsvProductImageImporter >()) 9 . WithSettings ( CsvSettings . AllSettings ) 10 . WithSettings ( ProductImageImporterSettings . AllSettings ); 11 } Note Line 3: Registering CsvProductImageImporter in the DI Line 8: Registering CsvProductImageImporter in the global importer registry, so that the new importer may become available for import profile creation and for running the import process.","title":"Registering Data Importer"},{"location":"Fundamentals/Data-Import/02-building-custom-importer/#running-data-importer","text":"You can choose either of the following options to run your newly created data importer: Directly from UI as ImportProfile that has an assigned CsvProductImageImporter (TBA) Using code (TBA)","title":"Running Data Importer"},{"location":"Fundamentals/Dynamic-Properties/overview/","text":"VirtoCommerce Platform enables adding new properties to entities at runtime. Adding New Dynamic Property for Existing Type from UI In the left toolbar menu, click More > Dynamic Properties and select one of the available objects: Select the required object: Click the Create button: Enter the new property name, select value type and other options. You can also define the property name for each of the registered languages: Required: Does not allow any empty property values when editing object values. Multivalue: Allows to enter more than one value for the property when editing object values. Multilingual: Allows to define different values for each registered language when editing object values. Dictionary: Allows to select one of the predefined values when editing object values. The value type for dictionaries can be short text only. You can add dictionary items after creating the property. Editing Object Values Open the object details and click the Dynamic Properties widget: In the new blade, you will see the list of available properties with input controls for entering values:","title":"Overview"},{"location":"Fundamentals/Dynamic-Properties/overview/#adding-new-dynamic-property-for-existing-type-from-ui","text":"In the left toolbar menu, click More > Dynamic Properties and select one of the available objects: Select the required object: Click the Create button: Enter the new property name, select value type and other options. You can also define the property name for each of the registered languages: Required: Does not allow any empty property values when editing object values. Multivalue: Allows to enter more than one value for the property when editing object values. Multilingual: Allows to define different values for each registered language when editing object values. Dictionary: Allows to select one of the predefined values when editing object values. The value type for dictionaries can be short text only. You can add dictionary items after creating the property.","title":"Adding New Dynamic Property for Existing Type from UI"},{"location":"Fundamentals/Dynamic-Properties/overview/#editing-object-values","text":"Open the object details and click the Dynamic Properties widget: In the new blade, you will see the list of available properties with input controls for entering values:","title":"Editing Object Values"},{"location":"Fundamentals/Event-Driven-Development/using-domain-events/","text":"Using Domain Events As its name soggests, a domain event is something that happened in a particular domain, and something you want other parts of the same domain to be aware of and potentially react to (the in-process principle). An important benefit of domain events is that any side effects of something happening in a domain can be expressed explicitly and not implicitly. Those side effects must be consistent, i.e. either all operations related to the task happen, or none. In addition, domain events enable a better separation of concerns among classes within the same domain. How to Define Domain Events A domain event is just a simple POCO type that represents an interesting occurence in the domain: public class CustomDomainEvent : DomainEvent { public Customer Customer { get ; set ; } } How to Define New Event Handler Defining a new event handler works in the following way: public class CutomDomainEventHandler : IEventHandler < CustomDomainEvent > { public async Task Handle ( CustomDomainEventmessage ) { //Some logic here } } How to Register Event Handler and Subscribe to Domain Event To register an event handler or subscribe to a domain event, use the following code: void Initialize ( IServiceCollection serviceCollection ) { ... serviceCollection . AddTransient < CustomDomainEventHandler >(); ... } void PostInitialize ( IApplicationBuilder appBuilder ) { ... var eventHandlerRegistrar = appBuilder . ApplicationServices . GetService < IHandlerRegistrar >(); eventHandlerRegistrar . RegisterHandler < CustomDomainEvent >(( message , token ) => appBuilder . ApplicationServices . GetService < CustomDomainEventHandler >(). Handle ( message )); ... } How to Raise Domain Events In your domain entities, when any significant status change happens, you may want to raise your domain events like this: var eventPublisher = _container.Resolve<IEventPublisher>(); eventPublisher.Publish(new CustomDomainEvent())); How to Override Existing Event Handler with New Derived Type This option may be also of use in some cases, and it is done this way: //Derive a new handler from an overrided handler class public class CustomDomainEventHandler2 : CustomDomainEventHandler { .... } //Override in DI container void Initialize ( IServiceCollection serviceCollection ) { ... serviceCollection . AddTransient < CustomDomainEventHandler , CustomDomainEventHandler2 >(); ... }","title":"Using Domain Events"},{"location":"Fundamentals/Event-Driven-Development/using-domain-events/#using-domain-events","text":"As its name soggests, a domain event is something that happened in a particular domain, and something you want other parts of the same domain to be aware of and potentially react to (the in-process principle). An important benefit of domain events is that any side effects of something happening in a domain can be expressed explicitly and not implicitly. Those side effects must be consistent, i.e. either all operations related to the task happen, or none. In addition, domain events enable a better separation of concerns among classes within the same domain.","title":"Using Domain Events"},{"location":"Fundamentals/Event-Driven-Development/using-domain-events/#how-to-define-domain-events","text":"A domain event is just a simple POCO type that represents an interesting occurence in the domain: public class CustomDomainEvent : DomainEvent { public Customer Customer { get ; set ; } }","title":"How to Define Domain Events"},{"location":"Fundamentals/Event-Driven-Development/using-domain-events/#how-to-define-new-event-handler","text":"Defining a new event handler works in the following way: public class CutomDomainEventHandler : IEventHandler < CustomDomainEvent > { public async Task Handle ( CustomDomainEventmessage ) { //Some logic here } }","title":"How to Define New Event Handler"},{"location":"Fundamentals/Event-Driven-Development/using-domain-events/#how-to-register-event-handler-and-subscribe-to-domain-event","text":"To register an event handler or subscribe to a domain event, use the following code: void Initialize ( IServiceCollection serviceCollection ) { ... serviceCollection . AddTransient < CustomDomainEventHandler >(); ... } void PostInitialize ( IApplicationBuilder appBuilder ) { ... var eventHandlerRegistrar = appBuilder . ApplicationServices . GetService < IHandlerRegistrar >(); eventHandlerRegistrar . RegisterHandler < CustomDomainEvent >(( message , token ) => appBuilder . ApplicationServices . GetService < CustomDomainEventHandler >(). Handle ( message )); ... }","title":"How to Register Event Handler and Subscribe to Domain Event"},{"location":"Fundamentals/Event-Driven-Development/using-domain-events/#how-to-raise-domain-events","text":"In your domain entities, when any significant status change happens, you may want to raise your domain events like this: var eventPublisher = _container.Resolve<IEventPublisher>(); eventPublisher.Publish(new CustomDomainEvent()));","title":"How to Raise Domain Events"},{"location":"Fundamentals/Event-Driven-Development/using-domain-events/#how-to-override-existing-event-handler-with-new-derived-type","text":"This option may be also of use in some cases, and it is done this way: //Derive a new handler from an overrided handler class public class CustomDomainEventHandler2 : CustomDomainEventHandler { .... } //Override in DI container void Initialize ( IServiceCollection serviceCollection ) { ... serviceCollection . AddTransient < CustomDomainEventHandler , CustomDomainEventHandler2 >(); ... }","title":"How to Override Existing Event Handler with New Derived Type"},{"location":"Fundamentals/Extensibility/overview/","text":"Overview Unlimited extensibility is an indisputable advantage of Virto Commerce. This means end-user solution developers can adapt or replace Virto Commerce modules with their own functionality. This adaptation can be done in an elegant and simple way without workarounds. There are types of vendor-made extensions that guarantee 'seamless delivery'. Virto Commerce, however, guarantees that these ways of extensibility are sufficient to build an ecommerce solution of any complexity on top of it. Those three types of extensions are: No-code extensions API-based extensions Native extensions No-code Extensions Virto Commerce supports declarative extensions through the admin interface and API to extend the data model, UI, and workflow processing. In particular, Virto Commerce supports: Dynamic properties: Extend entities, such as Cart, Order, Company, etc., with new properties. Statuses: Enable implementing any workflow. Role-based security and permissions: Restrict access for a user (API) based on their role. For example, if you want a user to only be able to call the Search products API, you can achieve that. In a similar way, you can allow a user to have access to the Orders API for a specific store, only. Below, you can see how dynamic properties, statuses, and role-based permissions look in the Virto Commerce UI: API-based Extensions These are traditional cloud-based extensions based on API calls and events (hooks). With such extensions, you can use any language or framework for integration and reactive programming. Virto Commerce currently provides two types of API: REST: Enables access to module business functionality, i.e. all CRUD operations and business logic are accessible via Rest API. GraphQL: A new generation of Business API for client applications, it provides you with additional capabilities. We also support two types of event providers: Webhooks: Good point for no development integration. Eventbus: Read for reactive programming and enterprise integrations. Native Extensions This is an advanced mode of modular extensions. It is called native because it is a way how Virto Commerce is built internally. Virto Commerce creates a unique extension framework based on .NET extension and dependency injection. It enables extending default implementation for the unique needs of each business. Moreover, it simplifies DevOps processes and optimizes performance. Warning Source code is available only for transparency purposes. Virto does not recommend extending the platform through the source code, as it may breach the continuous delivery functionality. With a custom module, you can extend every layer: Admin UI API Business Logic Database Tip You can revert back to the original state by uninstalling the extension. For example, on the chart below, the Price module extension extends the default Virto Commerce Price module with the Recommended price property, with this new property being visible on every layer. Why Is It Important Not to Modify Code You Do Not Own? Despite the fact Virto platform is an open-source project, you should at all times avoid direct modification into the source code of modules developed by third parties or VC team. You also should always follow the Open-Closed Principle (open for extensions and closed for modifications). Here are some benefits you get by following our Extension concept and using Extensible points our platform provides for customizing your solution: Seamless delivery: If you don't have any modifications in the code you do not own, you will avoid merging hell during updates and be able to timely receive new fixes for bugs and security vulnerabilities, along with new functionality even for major updates. The platform team makes every effort to simplify the updating process and not to introduce any breaking changes in new releases. This is a huge advantage, but it is only advantageous to you if you take action on the updates. Easier support provision. Virto's support team can easily reproduce your issues and quickly provide you with the right solutions and answers. Seamless Delivery Usually, customization or extensibility means a complex update process. If you customize the default implementation, you need to support it by yourself. Getting updates from the vendor and redeveloping them to extend the functionality for the customers' needs becomes a time consuming task. Here at Virto Commerce, we design the platform with the Keep up to date and Seamless delivery process principles in mind: Here are the basics of our seamless delivery strategy in action: Virto Commerce has a flexible Price module. Let's assume you installed and use it as a binary package. Your product owner asked you to display the Recommended price, as well as the List and Sale price. Everything works properly, you just need to add a new property. To achieve that, you create a new module called Recommended Price Extension , which extends current domain model, CRUD operations, and DB model. Virto Commerce releases a new version of the Price module. You install the new release of the Price module without modifying anything in the custom module. This strategy allows you to receive updates and extend the default implementation. Warning Seamless delivery works properly for all vendor updates, except for the cases when both you and your vendor use the same property name. Our recommendation for such cases is adding a custom prefix or suffix for your custom properties, e.g., xxxStatus , where xxx is the abbreviation for your solution. List of Main Extension Points Our platform is based around a collection of various modules and components that form the backbone of the Virto value proposition, which is to make each part of our system extendable and usable. In order to provide solutions for many different use cases, we decided it was important to ensure that these core concepts were as flexible and extensible as possible. The Virto platform encompasses the extension concept based on various techniques and practices. It can significantly reduce the implementation and upgrade effort for your custom solution. Info The extension concept is the backbone of the Virto platform value proposition and has four main extensible point types. To address crucial extension requirements, the platform contains various extensions points for all three main parts: the Platform application, Modules, and Storefront. Such extension points enable performing multiple customizations without direct code modification. The list below mentions the important ones: Domain and business logic extension: Extending domain models Extending through domain events Extending authorization policies Dynamic properties Platform manager UI extension: Extending main menu Working with widgets Metaforms Extending blade toolbar Extending grid columns Extending commerce logic: New payment method registration New shipping method registration New tax provider registration Customization Type Comparison The table below will help you understand the differences between various customization types, as well as the advantages and disadvantages of each: Summary Virto Commerce provides the best opportunities for customization. You as a developer can choose the best approach and balance between inside and outside integrations. The Native approach simplifies the DevOps processes and optimizes performance, allowing you to reuse and improve Virto Commerce modules. The API approach helps you to glue Virto Commerce's platform into your ecommerce ecosystem. The open source principle enables developers to learn the code and fix issues. We are fully open to your contribution.","title":"Overview"},{"location":"Fundamentals/Extensibility/overview/#overview","text":"Unlimited extensibility is an indisputable advantage of Virto Commerce. This means end-user solution developers can adapt or replace Virto Commerce modules with their own functionality. This adaptation can be done in an elegant and simple way without workarounds. There are types of vendor-made extensions that guarantee 'seamless delivery'. Virto Commerce, however, guarantees that these ways of extensibility are sufficient to build an ecommerce solution of any complexity on top of it. Those three types of extensions are: No-code extensions API-based extensions Native extensions","title":"Overview"},{"location":"Fundamentals/Extensibility/overview/#no-code-extensions","text":"Virto Commerce supports declarative extensions through the admin interface and API to extend the data model, UI, and workflow processing. In particular, Virto Commerce supports: Dynamic properties: Extend entities, such as Cart, Order, Company, etc., with new properties. Statuses: Enable implementing any workflow. Role-based security and permissions: Restrict access for a user (API) based on their role. For example, if you want a user to only be able to call the Search products API, you can achieve that. In a similar way, you can allow a user to have access to the Orders API for a specific store, only. Below, you can see how dynamic properties, statuses, and role-based permissions look in the Virto Commerce UI:","title":"No-code Extensions"},{"location":"Fundamentals/Extensibility/overview/#api-based-extensions","text":"These are traditional cloud-based extensions based on API calls and events (hooks). With such extensions, you can use any language or framework for integration and reactive programming. Virto Commerce currently provides two types of API: REST: Enables access to module business functionality, i.e. all CRUD operations and business logic are accessible via Rest API. GraphQL: A new generation of Business API for client applications, it provides you with additional capabilities. We also support two types of event providers: Webhooks: Good point for no development integration. Eventbus: Read for reactive programming and enterprise integrations.","title":"API-based Extensions"},{"location":"Fundamentals/Extensibility/overview/#native-extensions","text":"This is an advanced mode of modular extensions. It is called native because it is a way how Virto Commerce is built internally. Virto Commerce creates a unique extension framework based on .NET extension and dependency injection. It enables extending default implementation for the unique needs of each business. Moreover, it simplifies DevOps processes and optimizes performance. Warning Source code is available only for transparency purposes. Virto does not recommend extending the platform through the source code, as it may breach the continuous delivery functionality. With a custom module, you can extend every layer: Admin UI API Business Logic Database Tip You can revert back to the original state by uninstalling the extension. For example, on the chart below, the Price module extension extends the default Virto Commerce Price module with the Recommended price property, with this new property being visible on every layer.","title":"Native Extensions"},{"location":"Fundamentals/Extensibility/overview/#why-is-it-important-not-to-modify-code-you-do-not-own","text":"Despite the fact Virto platform is an open-source project, you should at all times avoid direct modification into the source code of modules developed by third parties or VC team. You also should always follow the Open-Closed Principle (open for extensions and closed for modifications). Here are some benefits you get by following our Extension concept and using Extensible points our platform provides for customizing your solution: Seamless delivery: If you don't have any modifications in the code you do not own, you will avoid merging hell during updates and be able to timely receive new fixes for bugs and security vulnerabilities, along with new functionality even for major updates. The platform team makes every effort to simplify the updating process and not to introduce any breaking changes in new releases. This is a huge advantage, but it is only advantageous to you if you take action on the updates. Easier support provision. Virto's support team can easily reproduce your issues and quickly provide you with the right solutions and answers.","title":"Why Is It Important Not to Modify Code You Do Not Own?"},{"location":"Fundamentals/Extensibility/overview/#seamless-delivery","text":"Usually, customization or extensibility means a complex update process. If you customize the default implementation, you need to support it by yourself. Getting updates from the vendor and redeveloping them to extend the functionality for the customers' needs becomes a time consuming task. Here at Virto Commerce, we design the platform with the Keep up to date and Seamless delivery process principles in mind: Here are the basics of our seamless delivery strategy in action: Virto Commerce has a flexible Price module. Let's assume you installed and use it as a binary package. Your product owner asked you to display the Recommended price, as well as the List and Sale price. Everything works properly, you just need to add a new property. To achieve that, you create a new module called Recommended Price Extension , which extends current domain model, CRUD operations, and DB model. Virto Commerce releases a new version of the Price module. You install the new release of the Price module without modifying anything in the custom module. This strategy allows you to receive updates and extend the default implementation. Warning Seamless delivery works properly for all vendor updates, except for the cases when both you and your vendor use the same property name. Our recommendation for such cases is adding a custom prefix or suffix for your custom properties, e.g., xxxStatus , where xxx is the abbreviation for your solution.","title":"Seamless Delivery"},{"location":"Fundamentals/Extensibility/overview/#list-of-main-extension-points","text":"Our platform is based around a collection of various modules and components that form the backbone of the Virto value proposition, which is to make each part of our system extendable and usable. In order to provide solutions for many different use cases, we decided it was important to ensure that these core concepts were as flexible and extensible as possible. The Virto platform encompasses the extension concept based on various techniques and practices. It can significantly reduce the implementation and upgrade effort for your custom solution. Info The extension concept is the backbone of the Virto platform value proposition and has four main extensible point types. To address crucial extension requirements, the platform contains various extensions points for all three main parts: the Platform application, Modules, and Storefront. Such extension points enable performing multiple customizations without direct code modification. The list below mentions the important ones: Domain and business logic extension: Extending domain models Extending through domain events Extending authorization policies Dynamic properties Platform manager UI extension: Extending main menu Working with widgets Metaforms Extending blade toolbar Extending grid columns Extending commerce logic: New payment method registration New shipping method registration New tax provider registration","title":"List of Main Extension Points"},{"location":"Fundamentals/Extensibility/overview/#customization-type-comparison","text":"The table below will help you understand the differences between various customization types, as well as the advantages and disadvantages of each:","title":"Customization Type Comparison"},{"location":"Fundamentals/Extensibility/overview/#summary","text":"Virto Commerce provides the best opportunities for customization. You as a developer can choose the best approach and balance between inside and outside integrations. The Native approach simplifies the DevOps processes and optimizes performance, allowing you to reuse and improve Virto Commerce modules. The API approach helps you to glue Virto Commerce's platform into your ecommerce ecosystem. The open source principle enables developers to learn the code and fix issues. We are fully open to your contribution.","title":"Summary"},{"location":"Fundamentals/Indexed-Search/overview/","text":"Indexed Search Overview This article provides an overview of indexed search that is one of the key features of any ecommerce solution. Virto Search is a search component that gives developers infrastructure, APIs, and tools for building a rich search experience over heterogeneous platform entities. Search is foundational to any ecommerce app that surfaces text content to users, with common scenarios including catalog or various entities search, or data exploration. Architecturally, a search service sits between the data stores that contain your unindexed data, and the client app that sends query requests to a search index and handles the response and external search engines that manage all index and search requests. Below, you can find more info on the main Virto Commerce Indexed Search concepts: Search indexes: A logical group (container) that contains all documents (rows) of a single document ( Type ). Each document also has Fields (columns). Usually it is mapped to a specific index within the index provider, e.g., Elasticsearch index. In Virto, we have the following indexes by default: Product: For catalog item search Category: For catalog category search Member: For customer data search CustomerOrder: For order search Index document: Conceptually, a document is a single unit of searchable data in your index. For example, it may be a document for each product in the catalog. Mapping these concepts to more familiar database equivalents, we can say that search index is an equivalent to a table, while documents are roughly equivalent to rows in the table. The structure of a document is determined by the index schema, as illustrated below. The Fields collection is typically the largest part of an index, where each field is named, assigned a value type, and attributed with allowable behaviors that determine how it is used. Here is how an index may look like: Indexing : A process for data indexing that extracts searchable content from various data sources and populates a search index within the specific search provider with instances of index documents created from the source data by index document builders. Search query : A string consisting of keywords and terms that is processed by custom query syntax parser, which transforms it to a common search request. In other words, it is a complete specification of what should be returned as a result. Here is an example: Asus color:Black,Blue price.usd:[100 TO 200) Search: Enables performing search tasks with the indexed data, receives the search phrase in a special query language and interprets the string into a Virto common search request object that can be supplied to a specific search engine through the integration connector. The key search features include: Full text search with extensions for fuzzy search, proximity search, term boosting, and regular expressions Faceted navigation and filters that allow users to navigate through a website by applying filters for categories, attributes, price ranges, and so on. This can be used to incorporate faceted navigation into your application's UI, enhance query formulation, and filter based on user or developer-specified criteria. Integration: Middleware providing integration to a specific search engine that enables mapping for objects of internal intermediated types, index documents and search requests, into the respective document and query objects a particular search engine expects to receive. Search Engine: A specific index search engine that handles all indexing and search requests. Virto has ready-made integrations with the following services: Lucene (only for the dev mode) Elasticsearch Elastic App Search Azure Cognitive Search","title":"Overview"},{"location":"Fundamentals/Indexed-Search/overview/#indexed-search-overview","text":"This article provides an overview of indexed search that is one of the key features of any ecommerce solution. Virto Search is a search component that gives developers infrastructure, APIs, and tools for building a rich search experience over heterogeneous platform entities. Search is foundational to any ecommerce app that surfaces text content to users, with common scenarios including catalog or various entities search, or data exploration. Architecturally, a search service sits between the data stores that contain your unindexed data, and the client app that sends query requests to a search index and handles the response and external search engines that manage all index and search requests. Below, you can find more info on the main Virto Commerce Indexed Search concepts: Search indexes: A logical group (container) that contains all documents (rows) of a single document ( Type ). Each document also has Fields (columns). Usually it is mapped to a specific index within the index provider, e.g., Elasticsearch index. In Virto, we have the following indexes by default: Product: For catalog item search Category: For catalog category search Member: For customer data search CustomerOrder: For order search Index document: Conceptually, a document is a single unit of searchable data in your index. For example, it may be a document for each product in the catalog. Mapping these concepts to more familiar database equivalents, we can say that search index is an equivalent to a table, while documents are roughly equivalent to rows in the table. The structure of a document is determined by the index schema, as illustrated below. The Fields collection is typically the largest part of an index, where each field is named, assigned a value type, and attributed with allowable behaviors that determine how it is used. Here is how an index may look like: Indexing : A process for data indexing that extracts searchable content from various data sources and populates a search index within the specific search provider with instances of index documents created from the source data by index document builders. Search query : A string consisting of keywords and terms that is processed by custom query syntax parser, which transforms it to a common search request. In other words, it is a complete specification of what should be returned as a result. Here is an example: Asus color:Black,Blue price.usd:[100 TO 200) Search: Enables performing search tasks with the indexed data, receives the search phrase in a special query language and interprets the string into a Virto common search request object that can be supplied to a specific search engine through the integration connector. The key search features include: Full text search with extensions for fuzzy search, proximity search, term boosting, and regular expressions Faceted navigation and filters that allow users to navigate through a website by applying filters for categories, attributes, price ranges, and so on. This can be used to incorporate faceted navigation into your application's UI, enhance query formulation, and filter based on user or developer-specified criteria. Integration: Middleware providing integration to a specific search engine that enables mapping for objects of internal intermediated types, index documents and search requests, into the respective document and query objects a particular search engine expects to receive. Search Engine: A specific index search engine that handles all indexing and search requests. Virto has ready-made integrations with the following services: Lucene (only for the dev mode) Elasticsearch Elastic App Search Azure Cognitive Search","title":"Indexed Search Overview"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/","text":"Search Query Syntax Reference Virto's unified search supports a special query syntax that is processed by our proprietary query syntax parser and interprets it into the Virto query object model that then gets translated into specific search engine syntax by an appropriate search adapter. This makes the query syntax truly search engine agnostic. The table below shows how the syntax defines the grammar for the . searchPhrase expression: 1 searchPhrase : WS* phrase (WS phrase)* WS*; 2 phrase : keyword | filters; 3 keyword : String; 4 filters : negation? (attributeFilter | rangeFilter); 5 attributeFilter : fieldName FD attributeFilterValue; 6 rangeFilter : fieldName FD rangeFilterValue; 7 fieldName : String; 8 attributeFilterValue : string (VD string)*; 9 rangeFilterValue : range (VD range)*; 10 range : rangeStart WS* lower? WS* RD WS* upper? WS* rangeEnd; 11 rangeStart : RangeStart; 12 rangeEnd : RangeEnd; 13 lower : String; 14 upper : String; 15 string : String; 16 17 negation : '!'; 18 FD : ':'; // Filter delimiter 19 VD : ','; // Value delimiter 20 RD : 'TO' | 'to'; // Range delimiter 21 RangeStart : '[' | '('; 22 RangeEnd : ']' | ')'; 23 24 String : SimpleString | QuotedString; 25 fragment SimpleString : ~[!\":,[\\]() \\t]+; 26 fragment QuotedString : ('\"' (Esc | ~[\"\\\\])* '\"'); 27 fragment Esc : '\\\\' ([\"\\\\rnt]); 28 29 WS : [ \\t]+; // Whitespace SearchPhrase expressions are evaluated during query parsing, which constrains the search to specific fields or adds match criteria used during index scans. Strings transferred to the searchPhrase parameter can include keyword for full text search and filters to apply additional criteria to a search in any supported language, with boolean operators, precedence operators, wildcard or prefix characters for starts with queries, escape characters, and URL encoding characters. A term phrase is a query consisting of one or more terms, where any of the terms are considered a match, such as single words like test or hello . A phrase phrase is an exact phrase enclosed in quotation marks ( \" \" ). For example, while Red wine (without quotes) would search for documents containing Red and/or wine anywhere in any order, \"Red wine\" (with quotes) will only match documents that contain the entire phrase in the appropriate order (lexical analysis still applies). Depending on your search client, you might need to escape the quotation marks in a phrase search. For example, in Postman, in a POST request, a phrase search on \"Red wine\" in the request body would be specified as \"\\\"Red wine\\\"\" . A filter phrase is used to apply additional criteria to a search query apart from the full text search terms. Full Text Search (Term and Phrase Search) The parameter that performs full text search against the document index is query , and you need to provide a full text search phrase to make it work. Searchable Fields The full text search runs over data in the index. All searchable text data are stored in a single __content field in the resulting index document, with the full text search being performed only for this field. For instance, the product document in the index may look like this: 1 \"__content\": [ 2 \"JGC-85796278\", 3 \"ASUS ZenFone 2 ZE551ML Gold\", 4 \"asus\", 5 \"android\", 6 \"2.3 ghz intel gtx quad-core\", 7 \"micro-sim\", 8 \"1080\" 9 ], With an example request asus , you will get the search to find all documents where the __content field contains the asus value as an entire phrase or a part of it. Filters A filter provides value-based criteria for selecting which documents to include in the search results. A filter can be a single value or an expression. In contrast with the full text search, a filter succeeds only if an exact match is achieved. Filters are specified in individual fields. A field definition must be attributed as \"filterable\" if you want to use it in filter expressions. Fields When performing a search, you can either specify a field by typing the field name followed by a colon ( : ) and then the term you are looking for, e.g.: name:\"My cool name\" color:Black Specifying multiple values in one field parameter, separated by a comma, will return products in which at least one of the specified values matches (i.e. acting as an OR operator). The example below shows a request that filters products that are either black, grey, or blue: color:Black,Gey,Blue Range Filtration Range filtration enables matching products the field values of which are between the lower and upper bound specified by a Range expression that can be both inclusive or exclusive. The sorting processes runs based on lexicography. Here are a few examples: price:[100 TO 200] This will find products with prices between 100 and 200, inclusive (inclusive range queries use square brackets, while exclusive queries use round brackets). price:(100 TO 200] This will find products with prices between 100, exclusive, and 200, inclusive. You can skip one of the values to ignore either the lower or the upper bound: price:(TO 100] , which means the price must be less than or equal to 100. Boolean Operators Having multiple field terms separated by a space delimiter in a single filter expression will combine them with an AND operator. The following example search request filters products of a certain brand, Onkyo, and a certain color, black. color:Black brand:Onkyo Warning At the moment, only logical AND operators are supported for filter expressions. Wildcard Search You can use single and multiple character wildcard search within a single phrase or phrase terms. To perform a single character wildcard search, use a quotation mark ( ? ), while for a multiple character wildcard search use an asterisk ( * ). For instance, with this search request: te?t multiple character wildcard search will look for 0 or more characters. Alternatively, to search for, say, test , tests , or tester , you can use the following expression: test* You can also use wildcard search in the middle of a term, e.g.: te*t Escaping Special Characters Inside the double quotes block, you might use any unsafe characters; to escape double quote character, use backslash ( \\ ): \\\"my cool property\\\":\\\"&~!'\\\" More Examples Below, you can find some more examples of typical search requests: color:Black,White : The color is either black or white color:Black color:White : The color is both black and white price_usd:[100 TO 200] : The price is between $100 and $200, inclusive price:(100 TO 200) : The price in any currency is between 100 and 200, exclusive price:(0 TO) : The price is greater than zero price:(TO 100] : The price is less than or equal to 100 Da?? Red* : ? replaces a single character, while * replaces zero or more characters color:Black price:[100 TO 200) : Combine keywords and filters","title":"Search Query Syntax Reference"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#search-query-syntax-reference","text":"Virto's unified search supports a special query syntax that is processed by our proprietary query syntax parser and interprets it into the Virto query object model that then gets translated into specific search engine syntax by an appropriate search adapter. This makes the query syntax truly search engine agnostic. The table below shows how the syntax defines the grammar for the . searchPhrase expression: 1 searchPhrase : WS* phrase (WS phrase)* WS*; 2 phrase : keyword | filters; 3 keyword : String; 4 filters : negation? (attributeFilter | rangeFilter); 5 attributeFilter : fieldName FD attributeFilterValue; 6 rangeFilter : fieldName FD rangeFilterValue; 7 fieldName : String; 8 attributeFilterValue : string (VD string)*; 9 rangeFilterValue : range (VD range)*; 10 range : rangeStart WS* lower? WS* RD WS* upper? WS* rangeEnd; 11 rangeStart : RangeStart; 12 rangeEnd : RangeEnd; 13 lower : String; 14 upper : String; 15 string : String; 16 17 negation : '!'; 18 FD : ':'; // Filter delimiter 19 VD : ','; // Value delimiter 20 RD : 'TO' | 'to'; // Range delimiter 21 RangeStart : '[' | '('; 22 RangeEnd : ']' | ')'; 23 24 String : SimpleString | QuotedString; 25 fragment SimpleString : ~[!\":,[\\]() \\t]+; 26 fragment QuotedString : ('\"' (Esc | ~[\"\\\\])* '\"'); 27 fragment Esc : '\\\\' ([\"\\\\rnt]); 28 29 WS : [ \\t]+; // Whitespace SearchPhrase expressions are evaluated during query parsing, which constrains the search to specific fields or adds match criteria used during index scans. Strings transferred to the searchPhrase parameter can include keyword for full text search and filters to apply additional criteria to a search in any supported language, with boolean operators, precedence operators, wildcard or prefix characters for starts with queries, escape characters, and URL encoding characters. A term phrase is a query consisting of one or more terms, where any of the terms are considered a match, such as single words like test or hello . A phrase phrase is an exact phrase enclosed in quotation marks ( \" \" ). For example, while Red wine (without quotes) would search for documents containing Red and/or wine anywhere in any order, \"Red wine\" (with quotes) will only match documents that contain the entire phrase in the appropriate order (lexical analysis still applies). Depending on your search client, you might need to escape the quotation marks in a phrase search. For example, in Postman, in a POST request, a phrase search on \"Red wine\" in the request body would be specified as \"\\\"Red wine\\\"\" . A filter phrase is used to apply additional criteria to a search query apart from the full text search terms.","title":"Search Query Syntax Reference"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#full-text-search-term-and-phrase-search","text":"The parameter that performs full text search against the document index is query , and you need to provide a full text search phrase to make it work.","title":"Full Text Search (Term and Phrase Search)"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#searchable-fields","text":"The full text search runs over data in the index. All searchable text data are stored in a single __content field in the resulting index document, with the full text search being performed only for this field. For instance, the product document in the index may look like this: 1 \"__content\": [ 2 \"JGC-85796278\", 3 \"ASUS ZenFone 2 ZE551ML Gold\", 4 \"asus\", 5 \"android\", 6 \"2.3 ghz intel gtx quad-core\", 7 \"micro-sim\", 8 \"1080\" 9 ], With an example request asus , you will get the search to find all documents where the __content field contains the asus value as an entire phrase or a part of it.","title":"Searchable Fields"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#filters","text":"A filter provides value-based criteria for selecting which documents to include in the search results. A filter can be a single value or an expression. In contrast with the full text search, a filter succeeds only if an exact match is achieved. Filters are specified in individual fields. A field definition must be attributed as \"filterable\" if you want to use it in filter expressions.","title":"Filters"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#fields","text":"When performing a search, you can either specify a field by typing the field name followed by a colon ( : ) and then the term you are looking for, e.g.: name:\"My cool name\" color:Black Specifying multiple values in one field parameter, separated by a comma, will return products in which at least one of the specified values matches (i.e. acting as an OR operator). The example below shows a request that filters products that are either black, grey, or blue: color:Black,Gey,Blue","title":"Fields"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#range-filtration","text":"Range filtration enables matching products the field values of which are between the lower and upper bound specified by a Range expression that can be both inclusive or exclusive. The sorting processes runs based on lexicography. Here are a few examples: price:[100 TO 200] This will find products with prices between 100 and 200, inclusive (inclusive range queries use square brackets, while exclusive queries use round brackets). price:(100 TO 200] This will find products with prices between 100, exclusive, and 200, inclusive. You can skip one of the values to ignore either the lower or the upper bound: price:(TO 100] , which means the price must be less than or equal to 100.","title":"Range Filtration"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#boolean-operators","text":"Having multiple field terms separated by a space delimiter in a single filter expression will combine them with an AND operator. The following example search request filters products of a certain brand, Onkyo, and a certain color, black. color:Black brand:Onkyo Warning At the moment, only logical AND operators are supported for filter expressions.","title":"Boolean Operators"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#wildcard-search","text":"You can use single and multiple character wildcard search within a single phrase or phrase terms. To perform a single character wildcard search, use a quotation mark ( ? ), while for a multiple character wildcard search use an asterisk ( * ). For instance, with this search request: te?t multiple character wildcard search will look for 0 or more characters. Alternatively, to search for, say, test , tests , or tester , you can use the following expression: test* You can also use wildcard search in the middle of a term, e.g.: te*t","title":"Wildcard Search"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#escaping-special-characters","text":"Inside the double quotes block, you might use any unsafe characters; to escape double quote character, use backslash ( \\ ): \\\"my cool property\\\":\\\"&~!'\\\"","title":"Escaping Special Characters"},{"location":"Fundamentals/Indexed-Search/search-query-syntax-reference/#more-examples","text":"Below, you can find some more examples of typical search requests: color:Black,White : The color is either black or white color:Black color:White : The color is both black and white price_usd:[100 TO 200] : The price is between $100 and $200, inclusive price:(100 TO 200) : The price in any currency is between 100 and 200, exclusive price:(0 TO) : The price is greater than zero price:(TO 100] : The price is less than or equal to 100 Da?? Red* : ? replaces a single character, while * replaces zero or more characters color:Black price:[100 TO 200) : Combine keywords and filters","title":"More Examples"},{"location":"Fundamentals/Indexed-Search/indexing/blue-green-indexing/","text":"Blue-Green Indexing Overview Starting version 3.201.0, Elasticsearch supports blue-green indexing. This means that, after running full index Rebuild and Delete : A new backup index will be created for the selected document type. The indexing process will be run against this backup index. During the full indexation process, the current index will remain intact and one will be able to perform all search operations against it. After re-indexing is complete, the index will get swapped: the backup index will now become active, while the current one's role will switch to backup. To roll back to using the previous index, use the Swap Index feature: click Show Backup Indices , right click the row for the selected document type you want to switch to, and click Swap Indices ; this will cause the backup and active indexes to swap their roles again. If you start the re-indexing process again, the previous backup index will be lost and all indexing jobs will run against the new backup index instead. Implementation Details Elasticsearch implements blue-green indexing using Elasticsearch aliases . The search provider implementations use two aliases to tell one index role from the other: active and backup . Full index alias is built as scope name + document type name + alias name ; e.g., an active index alias for the Members index using default scope will look like this: default-member-active . Each time you start the Rebuild and Delete process, the Elasticsearch index provider looks for an existing backup index by backup alias, e.g., default-member-backup , and deletes it in case it is found. After that, when the re-indexing process starts, a new backup index gets created with the backup alias. An actual index name is created dynamically, however: this is a special alphanumeric token suffix that is added to the end of the index name. The only way to tell which index is active is to look at its alias. After the indexing process is complete, the active and backup indices swap aliases, meaning that the active index becomes the backup one, and vice versa.","title":"Blue-Green Indexing"},{"location":"Fundamentals/Indexed-Search/indexing/blue-green-indexing/#blue-green-indexing","text":"","title":"Blue-Green Indexing"},{"location":"Fundamentals/Indexed-Search/indexing/blue-green-indexing/#overview","text":"Starting version 3.201.0, Elasticsearch supports blue-green indexing. This means that, after running full index Rebuild and Delete : A new backup index will be created for the selected document type. The indexing process will be run against this backup index. During the full indexation process, the current index will remain intact and one will be able to perform all search operations against it. After re-indexing is complete, the index will get swapped: the backup index will now become active, while the current one's role will switch to backup. To roll back to using the previous index, use the Swap Index feature: click Show Backup Indices , right click the row for the selected document type you want to switch to, and click Swap Indices ; this will cause the backup and active indexes to swap their roles again. If you start the re-indexing process again, the previous backup index will be lost and all indexing jobs will run against the new backup index instead.","title":"Overview"},{"location":"Fundamentals/Indexed-Search/indexing/blue-green-indexing/#implementation-details","text":"Elasticsearch implements blue-green indexing using Elasticsearch aliases . The search provider implementations use two aliases to tell one index role from the other: active and backup . Full index alias is built as scope name + document type name + alias name ; e.g., an active index alias for the Members index using default scope will look like this: default-member-active . Each time you start the Rebuild and Delete process, the Elasticsearch index provider looks for an existing backup index by backup alias, e.g., default-member-backup , and deletes it in case it is found. After that, when the re-indexing process starts, a new backup index gets created with the backup alias. An actual index name is created dynamically, however: this is a special alphanumeric token suffix that is added to the end of the index name. The only way to tell which index is active is to look at its alias. After the indexing process is complete, the active and backup indices swap aliases, meaning that the active index becomes the backup one, and vice versa.","title":"Implementation Details"},{"location":"Fundamentals/Indexed-Search/indexing/indexing-in-platform-manager/","text":"Indexing in Platform Manager You can work with various indexing features through Platform Manager. Manual Indexing You can initiate the indexing process manually by following these steps: Go to Search Index , select the required document type, click the Build button to start indexing. At this point, you will need to choose one of the two options: Build: Index all data without recreating Delete and Build: The current search index will be deleted and built from scratch Wait for the indexing process to complete. The time it may take depends on the number of entities. Viewing Index Document Platform Manager allows you to preview the index document data without having to write any code. You can use a special widget that will take you to previewing raw JSON data being used for the document that is stored in the index storage. To do so, open the Product blade and click the Search Index widget: Incremental Index Updates Virto commerce can update search indexes incrementally in the background by tracking entity changes and injecting changed entities into the index. Various modules have their own jobs and settings. For example, the Catalog module has two types for incremental indexing: Event-based : Indexing is triggered when a product gets changed. Time-based : A background job checks and re-indexes modified objects every X minutes (5 by default). This type is disabled by default. You can change behavior by going to Settings > Catalog > Search :","title":"Indexing in Platform Manager"},{"location":"Fundamentals/Indexed-Search/indexing/indexing-in-platform-manager/#indexing-in-platform-manager","text":"You can work with various indexing features through Platform Manager.","title":"Indexing in Platform Manager"},{"location":"Fundamentals/Indexed-Search/indexing/indexing-in-platform-manager/#manual-indexing","text":"You can initiate the indexing process manually by following these steps: Go to Search Index , select the required document type, click the Build button to start indexing. At this point, you will need to choose one of the two options: Build: Index all data without recreating Delete and Build: The current search index will be deleted and built from scratch Wait for the indexing process to complete. The time it may take depends on the number of entities.","title":"Manual Indexing"},{"location":"Fundamentals/Indexed-Search/indexing/indexing-in-platform-manager/#viewing-index-document","text":"Platform Manager allows you to preview the index document data without having to write any code. You can use a special widget that will take you to previewing raw JSON data being used for the document that is stored in the index storage. To do so, open the Product blade and click the Search Index widget:","title":"Viewing Index Document"},{"location":"Fundamentals/Indexed-Search/indexing/indexing-in-platform-manager/#incremental-index-updates","text":"Virto commerce can update search indexes incrementally in the background by tracking entity changes and injecting changed entities into the index. Various modules have their own jobs and settings. For example, the Catalog module has two types for incremental indexing: Event-based : Indexing is triggered when a product gets changed. Time-based : A background job checks and re-indexes modified objects every X minutes (5 by default). This type is disabled by default. You can change behavior by going to Settings > Catalog > Search :","title":"Incremental Index Updates"},{"location":"Fundamentals/Indexed-Search/indexing/overview/","text":"Indexing Overview Common Indexing is a search engine agnostic process for data indexation. The process chart of such indexing may look as follows: To do indexing, the process performs the following steps: IndexingManager starts the indexing process for every affected entity in a scope of the specific document types that are requested. It then requests the list of changed entity identifiers that need indexing, by running IIndexDocumentChangesProvider at the specific date for incremental indexing or all entities for overall index rebuild. It gets the resulting index documents for entity identifiers by calling IIndexDocumentBuilder instances. Finally, it collects index documents and saves them in the search index storage through ISearchProvider . The key indexing features are: Specialized UI and API in Platform Manager for routine tasks with indexing. Index document enrichment: You can compose an index document from the fields taken from multiple data sources. Custom indexers: When developing an indexer, you'll specify a data source and a search index (destination). Currently, the process of defining a new indexer requires development efforts . Also, thanks to search engine agnostic capabilities, you need to create a custom indexer only once to work with all search providers without any changes. Manual and incremental index updates: You can run indexers on demand or on a recurring basis. Virto updates search indexes by periodically adding or removing data entities that have changed in the Commerce Engine. Thanks to incremental index updates, the search engine updates the indexes with index documents based on new, changed, or deleted items in the data sources. Blue/Green indexing : Allows you to perform zero downtime upgrades of your index. You can run a full index rebuild or long time indexing tasks on other index instances and switch them to published index the production environment is connected to, when these tasks are finished.","title":"Overview"},{"location":"Fundamentals/Indexed-Search/indexing/overview/#indexing-overview","text":"Common Indexing is a search engine agnostic process for data indexation. The process chart of such indexing may look as follows: To do indexing, the process performs the following steps: IndexingManager starts the indexing process for every affected entity in a scope of the specific document types that are requested. It then requests the list of changed entity identifiers that need indexing, by running IIndexDocumentChangesProvider at the specific date for incremental indexing or all entities for overall index rebuild. It gets the resulting index documents for entity identifiers by calling IIndexDocumentBuilder instances. Finally, it collects index documents and saves them in the search index storage through ISearchProvider . The key indexing features are: Specialized UI and API in Platform Manager for routine tasks with indexing. Index document enrichment: You can compose an index document from the fields taken from multiple data sources. Custom indexers: When developing an indexer, you'll specify a data source and a search index (destination). Currently, the process of defining a new indexer requires development efforts . Also, thanks to search engine agnostic capabilities, you need to create a custom indexer only once to work with all search providers without any changes. Manual and incremental index updates: You can run indexers on demand or on a recurring basis. Virto updates search indexes by periodically adding or removing data entities that have changed in the Commerce Engine. Thanks to incremental index updates, the search engine updates the indexes with index documents based on new, changed, or deleted items in the data sources. Blue/Green indexing : Allows you to perform zero downtime upgrades of your index. You can run a full index rebuild or long time indexing tasks on other index instances and switch them to published index the production environment is connected to, when these tasks are finished.","title":"Indexing Overview"},{"location":"Fundamentals/Indexed-Search/integration/configuring-azure-cognitive-search/","text":"Virto's VirtoCommerce.AzureSearch module enables integrating Azure Cognitive Search as a search engine . VirtoCommerce.AzureSearch implements ISearchProvider defined within the VirtoCommerce Search module and uses Azure Cognitive Search Engine, which stores indexed documents Configuration You can configure the Azure Cognitive Search provider using the following schema: \"Search\":{ <!-- is the name of the search provider and must be AzureSearch--> \"Provider\": \"AzureSearch\", <!-- is a common name (prefix) of all indexes. Each document type is stored in a separate index. Full index name is scope-{documenttype}. One search service can serve multiple indexes. Optional. Default value is default. --> \"Scope\": \"default\", \"AzureSearch\": { <!-- is the name of the search service instance in your Azure account Ex: SERVICENAME.search.windows.net. --> \"SearchServiceName\": \"SERVICENAME.search.windows.net\", <!-- is the primary or secondary admin key for this search service. --> \"AccessKey\": \"<<key value>>\" } } Example appsetings.json \"Search\":{ \"Provider\": \"AzureSearch\", \"Scope\": \"default\",","title":"Configuring Azure Cognitive Search"},{"location":"Fundamentals/Indexed-Search/integration/configuring-azure-cognitive-search/#configuration","text":"You can configure the Azure Cognitive Search provider using the following schema: \"Search\":{ <!-- is the name of the search provider and must be AzureSearch--> \"Provider\": \"AzureSearch\", <!-- is a common name (prefix) of all indexes. Each document type is stored in a separate index. Full index name is scope-{documenttype}. One search service can serve multiple indexes. Optional. Default value is default. --> \"Scope\": \"default\", \"AzureSearch\": { <!-- is the name of the search service instance in your Azure account Ex: SERVICENAME.search.windows.net. --> \"SearchServiceName\": \"SERVICENAME.search.windows.net\", <!-- is the primary or secondary admin key for this search service. --> \"AccessKey\": \"<<key value>>\" } }","title":"Configuration"},{"location":"Fundamentals/Indexed-Search/integration/configuring-azure-cognitive-search/#example","text":"appsetings.json \"Search\":{ \"Provider\": \"AzureSearch\", \"Scope\": \"default\",","title":"Example"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/","text":"Configuring Elastic App Search This guide will explain how to configure and run Elastic App Search for your environment. Prerequisites In order to start using Elastic App Search, you need to: Install the latest version of vc-platform (3.x), either on Windows or on Linux Install the vc-module-experience-api module using this guide Install the vc-module-profile-experience-api module Install Node.js v.16.X Install Yarn Package Manager by running this command: npm install --global yarn Installing vc-storefront You will also need to install vc-storefront by: Cloning https://github.com/VirtoCommerce/vc-storefront in to a local folder Opening the appsettings.json file in a text editor In the Endpoint section, changing Url , UserName , and Password with the correct path and credentials for Virto Commerce Platform: \"Endpoint\" : { \"Url\" : \"https://localhost:5001\" , \"UserName\" : \"admin\" , \"Password\" : \"store\" } Setting up Vue B2B Theme Finally, you will also need to set up Vue B2B Theme : Clone the repo into the folder where Storefront is installed: git clone https://github.com/VirtoCommerce/vue-starter-theme.git \"C:\\vc-storefront\\VirtoCommerce.Storefront\\wwwroot\\cms-content\\themes\\{store-name}\\default\" Change the current directory to the default theme directory (change {store-name} to the store you want to use, e.g., B2B-store ) : cd C: \\v c-storefront \\V irtoCommerce.Storefront \\V irtoCommerce.Storefront \\w wwroot \\c ms-content \\t hemes \\{ store-name } \\d efault + Install the dependencies: npm install yarn Start the theme in the development mode with hot reload support: yarn dev Or build the theme to get an installable artifact: yarn compress Setting up Elastic App Search Deploying Elastic App Search using Docker To deploy Elastic App Search using Docker, do the following: Install Docker for Windows or Linux Install Elastic App Search Container using Docker-Compose : Create a directory and with a file named .env inside: STACK_VERSION=8.3.3 ELASTIC_PASSWORD=!!!changeme!!! KIBANA_PASSWORD=!!!changeme!!! ES_PORT=9200 CLUSTER_NAME=es-cluster LICENSE=basic MEM_LIMIT=1073741824 KIBANA_PORT=5601 ENTERPRISE_SEARCH_PORT=3002 ENCRYPTION_KEYS=secret Create a strong password and place it instead of !!!changeme!!! Create a file named docker-compose.yml and place it with the .env file: ``` yml version : \"2.2\" services : setup : image : docker . elastic . co / elasticsearch / elasticsearch : $ { STACK_VERSION } volumes : - certs : / usr / share / elasticsearch / config / certs user : \"0\" command : > bash - c ' if [ x $ { ELASTIC_PASSWORD } == x ]; then echo \"Set the ELASTIC_PASSWORD environment variable in the .env file\" ; exit 1 ; elif [ x $ { KIBANA_PASSWORD } == x ]; then echo \"Set the KIBANA_PASSWORD environment variable in the .env file\" ; exit 1 ; fi ; if [ ! - f certs / ca . zip ]; then echo \"Creating CA\" ; bin / elasticsearch - certutil ca -- silent -- pem - out config / certs / ca . zip ; unzip config / certs / ca . zip - d config / certs ; fi ; if [ ! - f certs / certs . zip ]; then echo \"Creating certs\" ; echo - ne \\ \"instances: \\n \" \\ \" - name: es01 \\n \" \\ \" dns: \\n \" \\ \" - es01 \\n \" \\ \" - localhost \\n \" \\ \" ip: \\n \" \\ \" - 127.0.0.1 \\n \" \\ > config / certs / instances . yml ; bin / elasticsearch - certutil cert -- silent -- pem - out config / certs / certs . zip -- in config / certs / instances . yml -- ca - cert config / certs / ca / ca . crt -- ca - key config / certs / ca / ca . key ; unzip config / certs / certs . zip - d config / certs ; fi ; echo \"Setting file permissions\" chown - R root : root config / certs ; find . - type d - exec chmod 750 \\ { \\ } \\ ;; find . - type f - exec chmod 640 \\ { \\ } \\ ;; echo \"Waiting for Elasticsearch availability\" ; until curl - s -- cacert config / certs / ca / ca . crt https : // es01 : 9200 | grep - q \"missing authentication credentials\" ; do sleep 30 ; done ; echo \"Setting kibana_system password\" ; until curl - s - X POST -- cacert config / certs / ca / ca . crt - u elastic : $ { ELASTIC_PASSWORD } - H \"Content-Type: application/json\" https : // es01 : 9200 / _security / user / kibana_system / _password - d \"{ \\\" password \\\" : \\\" ${KIBANA_PASSWORD} \\\" }\" | grep - q \"^{}\" ; do sleep 10 ; done ; echo \"All done!\" ; ' healthcheck : test : [ \"CMD-SHELL\" , \"[ -f config/certs/es01/es01.crt ]\" ] interval : 1 s timeout : 5 s retries : 120 es01 : depends_on : setup : condition : service_healthy image : docker . elastic . co / elasticsearch / elasticsearch : $ { STACK_VERSION } volumes : - certs : / usr / share / elasticsearch / config / certs - esdata01 : / usr / share / elasticsearch / data ports : - $ { ES_PORT }: 9200 environment : - node . name = es01 - cluster . name =$ { CLUSTER_NAME } - cluster . initial_master_nodes = es01 - ELASTIC_PASSWORD =$ { ELASTIC_PASSWORD } - bootstrap . memory_lock = true - xpack . security . enabled = true - xpack . security . http . ssl . enabled = true - xpack . security . http . ssl . key = certs / es01 / es01 . key - xpack . security . http . ssl . certificate = certs / es01 / es01 . crt - xpack . security . http . ssl . certificate_authorities = certs / ca / ca . crt - xpack . security . http . ssl . verification_mode = certificate - xpack . security . transport . ssl . enabled = true - xpack . security . transport . ssl . key = certs / es01 / es01 . key - xpack . security . transport . ssl . certificate = certs / es01 / es01 . crt - xpack . security . transport . ssl . certificate_authorities = certs / ca / ca . crt - xpack . security . transport . ssl . verification_mode = certificate - xpack . license . self_generated . type =$ { LICENSE } mem_limit : $ { MEM_LIMIT } ulimits : memlock : soft : - 1 hard : - 1 healthcheck : test : [ \"CMD-SHELL\" , \"curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'\" , ] interval : 10 s timeout : 10 s retries : 120 kibana : depends_on : es01 : condition : service_healthy image : docker . elastic . co / kibana / kibana : $ { STACK_VERSION } volumes : - certs : / usr / share / kibana / config / certs - kibanadata : / usr / share / kibana / data ports : - $ { KIBANA_PORT }: 5601 environment : - SERVERNAME = kibana - ELASTICSEARCH_HOSTS = https : // es01 : 9200 - ELASTICSEARCH_USERNAME = kibana_system - ELASTICSEARCH_PASSWORD =$ { KIBANA_PASSWORD } - ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES = config / certs / ca / ca . crt - ENTERPRISESEARCH_HOST = http : // enterprisesearch : $ { ENTERPRISE_SEARCH_PORT } mem_limit : $ { MEM_LIMIT } healthcheck : test : [ \"CMD-SHELL\" , \"curl -s -I http://localhost:5601 | grep -q 'HTTP/1.1 302 Found'\" , ] interval : 10 s timeout : 10 s retries : 120 enterprisesearch : depends_on : es01 : condition : service_healthy kibana : condition : service_healthy image : docker . elastic . co / enterprise - search / enterprise - search : $ { STACK_VERSION } volumes : - certs : / usr / share / enterprise - search / config / certs - enterprisesearchdata : / usr / share / enterprise - search / config ports : - $ { ENTERPRISE_SEARCH_PORT }: 3002 environment : - SERVERNAME = enterprisesearch - secret_management . encryption_keys = [ $ { ENCRYPTION_KEYS }] - allow_es_settings_modification = true - elasticsearch . host = https : // es01 : 9200 - elasticsearch . username = elastic - elasticsearch . password =$ { ELASTIC_PASSWORD } - elasticsearch . ssl . enabled = true - app_search . engine . total_fields . limit = 128 - elasticsearch . ssl . certificate_authority =/ usr / share / enterprise - search / config / certs / ca / ca . crt - kibana . external_url = http : // kibana : 5601 mem_limit : $ { MEM_LIMIT } healthcheck : test : [ \"CMD-SHELL\" , \"curl -s -I http://localhost:3002 | grep -q 'HTTP/1.1 302 Found'\" , ] interval : 10 s timeout : 10 s retries : 120 volumes : certs : driver : local enterprisesearchdata : driver : local esdata01 : driver : local kibanadata : driver : local ``` Note There are custom settings for enterprisesearch in the .yml file: app_search.engine.total_fields.limit=128 Bring up the Elastic cluster with the following command (run it from the directory where the .yml file is): ``` docker-compose up ``` Access Kibana at http://localhost:5601 . Log in as elastic for username, your password being the value you provided for ELASTIC_PASSWORD in your .env file. Then Access Elasticsearch at http://localhost:9200 . Tip You can find more info on deploying Elastic App Search with Docker here . Setting up Elastic App Search on Platform To install Elastic App Search for Virto Platform, do the following: Install the vc-module-elastic-app-search module Modify the Platform configuration to use Elastic App Search: \"Search\" : { \"Provider\" : \"ElasticAppSearch\" , \"Scope\" : \"default\" , \"ElasticAppSearch\" : { \"Endpoint\" : \"https://localhost:3002\" , \"PrivateApiKey\" : \"private-key\" } } Open Kibana (localhost:5601), navigate to Enterprise Search > Open App Search > Credentials , copy Private Key, and assign it to the PrivateApiKey setting: Run Platform and build the indexes. You should see the ElasticAppSearch value for Provider : Navigate back to Kibana and confirm that engines (indexes) are created: Running Storefont and Working with App Search Running vc-storefront Application Navigate to the Storefront root directory: cd C: \\v c-storefront \\V irtoCommerce.Storefront Build and run the Storefront application: dotnet run Working with Elastic App Search In Kibana , open the App Search Engines overview page. Here can see four engines created after rebuilding the indexes. Clicking on the products engine, you will see general analytics about incoming queries and will be able to manage indexed documents and tune engine behavior with Relevance Tuning , Synonyms , and Curations . Open the Documents menu to examine all indexed documents and their content. Open the Schema menu to see which fields the documents contain. You can examine product index contents in the Platform admin UI by opening the Products screen and clicking the Index widget. Open Synonyms and add search query synonyms. For instance, associating the Sony keyword with the Samsung keyword and trying out the same query as before will yield a different result: you will also get all documents relevant to the Samsung keyword. Go to Storefront and see that the integration works and you get both Sony and Samsung products by the Sony keyword: Curation is a tool, by which you can handpick the results for certain search queries. E.g., search by the Sony keyword again and examine the entries. You can delete a specific document from the result set by clicking the Delete button, and add a new document by clicking the Add manually button and selecting a document from a different result set. Save the curation and check it in the Storefront:","title":"Configuring Elastic App Search"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#configuring-elastic-app-search","text":"This guide will explain how to configure and run Elastic App Search for your environment.","title":"Configuring Elastic App Search"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#prerequisites","text":"In order to start using Elastic App Search, you need to: Install the latest version of vc-platform (3.x), either on Windows or on Linux Install the vc-module-experience-api module using this guide Install the vc-module-profile-experience-api module Install Node.js v.16.X Install Yarn Package Manager by running this command: npm install --global yarn","title":"Prerequisites"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#installing-vc-storefront","text":"You will also need to install vc-storefront by: Cloning https://github.com/VirtoCommerce/vc-storefront in to a local folder Opening the appsettings.json file in a text editor In the Endpoint section, changing Url , UserName , and Password with the correct path and credentials for Virto Commerce Platform: \"Endpoint\" : { \"Url\" : \"https://localhost:5001\" , \"UserName\" : \"admin\" , \"Password\" : \"store\" }","title":"Installing vc-storefront"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#setting-up-vue-b2b-theme","text":"Finally, you will also need to set up Vue B2B Theme : Clone the repo into the folder where Storefront is installed: git clone https://github.com/VirtoCommerce/vue-starter-theme.git \"C:\\vc-storefront\\VirtoCommerce.Storefront\\wwwroot\\cms-content\\themes\\{store-name}\\default\" Change the current directory to the default theme directory (change {store-name} to the store you want to use, e.g., B2B-store ) : cd C: \\v c-storefront \\V irtoCommerce.Storefront \\V irtoCommerce.Storefront \\w wwroot \\c ms-content \\t hemes \\{ store-name } \\d efault + Install the dependencies: npm install yarn Start the theme in the development mode with hot reload support: yarn dev Or build the theme to get an installable artifact: yarn compress","title":"Setting up Vue B2B Theme"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#setting-up-elastic-app-search","text":"","title":"Setting up Elastic App Search"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#deploying-elastic-app-search-using-docker","text":"To deploy Elastic App Search using Docker, do the following: Install Docker for Windows or Linux Install Elastic App Search Container using Docker-Compose : Create a directory and with a file named .env inside: STACK_VERSION=8.3.3 ELASTIC_PASSWORD=!!!changeme!!! KIBANA_PASSWORD=!!!changeme!!! ES_PORT=9200 CLUSTER_NAME=es-cluster LICENSE=basic MEM_LIMIT=1073741824 KIBANA_PORT=5601 ENTERPRISE_SEARCH_PORT=3002 ENCRYPTION_KEYS=secret Create a strong password and place it instead of !!!changeme!!! Create a file named docker-compose.yml and place it with the .env file: ``` yml version : \"2.2\" services : setup : image : docker . elastic . co / elasticsearch / elasticsearch : $ { STACK_VERSION } volumes : - certs : / usr / share / elasticsearch / config / certs user : \"0\" command : > bash - c ' if [ x $ { ELASTIC_PASSWORD } == x ]; then echo \"Set the ELASTIC_PASSWORD environment variable in the .env file\" ; exit 1 ; elif [ x $ { KIBANA_PASSWORD } == x ]; then echo \"Set the KIBANA_PASSWORD environment variable in the .env file\" ; exit 1 ; fi ; if [ ! - f certs / ca . zip ]; then echo \"Creating CA\" ; bin / elasticsearch - certutil ca -- silent -- pem - out config / certs / ca . zip ; unzip config / certs / ca . zip - d config / certs ; fi ; if [ ! - f certs / certs . zip ]; then echo \"Creating certs\" ; echo - ne \\ \"instances: \\n \" \\ \" - name: es01 \\n \" \\ \" dns: \\n \" \\ \" - es01 \\n \" \\ \" - localhost \\n \" \\ \" ip: \\n \" \\ \" - 127.0.0.1 \\n \" \\ > config / certs / instances . yml ; bin / elasticsearch - certutil cert -- silent -- pem - out config / certs / certs . zip -- in config / certs / instances . yml -- ca - cert config / certs / ca / ca . crt -- ca - key config / certs / ca / ca . key ; unzip config / certs / certs . zip - d config / certs ; fi ; echo \"Setting file permissions\" chown - R root : root config / certs ; find . - type d - exec chmod 750 \\ { \\ } \\ ;; find . - type f - exec chmod 640 \\ { \\ } \\ ;; echo \"Waiting for Elasticsearch availability\" ; until curl - s -- cacert config / certs / ca / ca . crt https : // es01 : 9200 | grep - q \"missing authentication credentials\" ; do sleep 30 ; done ; echo \"Setting kibana_system password\" ; until curl - s - X POST -- cacert config / certs / ca / ca . crt - u elastic : $ { ELASTIC_PASSWORD } - H \"Content-Type: application/json\" https : // es01 : 9200 / _security / user / kibana_system / _password - d \"{ \\\" password \\\" : \\\" ${KIBANA_PASSWORD} \\\" }\" | grep - q \"^{}\" ; do sleep 10 ; done ; echo \"All done!\" ; ' healthcheck : test : [ \"CMD-SHELL\" , \"[ -f config/certs/es01/es01.crt ]\" ] interval : 1 s timeout : 5 s retries : 120 es01 : depends_on : setup : condition : service_healthy image : docker . elastic . co / elasticsearch / elasticsearch : $ { STACK_VERSION } volumes : - certs : / usr / share / elasticsearch / config / certs - esdata01 : / usr / share / elasticsearch / data ports : - $ { ES_PORT }: 9200 environment : - node . name = es01 - cluster . name =$ { CLUSTER_NAME } - cluster . initial_master_nodes = es01 - ELASTIC_PASSWORD =$ { ELASTIC_PASSWORD } - bootstrap . memory_lock = true - xpack . security . enabled = true - xpack . security . http . ssl . enabled = true - xpack . security . http . ssl . key = certs / es01 / es01 . key - xpack . security . http . ssl . certificate = certs / es01 / es01 . crt - xpack . security . http . ssl . certificate_authorities = certs / ca / ca . crt - xpack . security . http . ssl . verification_mode = certificate - xpack . security . transport . ssl . enabled = true - xpack . security . transport . ssl . key = certs / es01 / es01 . key - xpack . security . transport . ssl . certificate = certs / es01 / es01 . crt - xpack . security . transport . ssl . certificate_authorities = certs / ca / ca . crt - xpack . security . transport . ssl . verification_mode = certificate - xpack . license . self_generated . type =$ { LICENSE } mem_limit : $ { MEM_LIMIT } ulimits : memlock : soft : - 1 hard : - 1 healthcheck : test : [ \"CMD-SHELL\" , \"curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'\" , ] interval : 10 s timeout : 10 s retries : 120 kibana : depends_on : es01 : condition : service_healthy image : docker . elastic . co / kibana / kibana : $ { STACK_VERSION } volumes : - certs : / usr / share / kibana / config / certs - kibanadata : / usr / share / kibana / data ports : - $ { KIBANA_PORT }: 5601 environment : - SERVERNAME = kibana - ELASTICSEARCH_HOSTS = https : // es01 : 9200 - ELASTICSEARCH_USERNAME = kibana_system - ELASTICSEARCH_PASSWORD =$ { KIBANA_PASSWORD } - ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES = config / certs / ca / ca . crt - ENTERPRISESEARCH_HOST = http : // enterprisesearch : $ { ENTERPRISE_SEARCH_PORT } mem_limit : $ { MEM_LIMIT } healthcheck : test : [ \"CMD-SHELL\" , \"curl -s -I http://localhost:5601 | grep -q 'HTTP/1.1 302 Found'\" , ] interval : 10 s timeout : 10 s retries : 120 enterprisesearch : depends_on : es01 : condition : service_healthy kibana : condition : service_healthy image : docker . elastic . co / enterprise - search / enterprise - search : $ { STACK_VERSION } volumes : - certs : / usr / share / enterprise - search / config / certs - enterprisesearchdata : / usr / share / enterprise - search / config ports : - $ { ENTERPRISE_SEARCH_PORT }: 3002 environment : - SERVERNAME = enterprisesearch - secret_management . encryption_keys = [ $ { ENCRYPTION_KEYS }] - allow_es_settings_modification = true - elasticsearch . host = https : // es01 : 9200 - elasticsearch . username = elastic - elasticsearch . password =$ { ELASTIC_PASSWORD } - elasticsearch . ssl . enabled = true - app_search . engine . total_fields . limit = 128 - elasticsearch . ssl . certificate_authority =/ usr / share / enterprise - search / config / certs / ca / ca . crt - kibana . external_url = http : // kibana : 5601 mem_limit : $ { MEM_LIMIT } healthcheck : test : [ \"CMD-SHELL\" , \"curl -s -I http://localhost:3002 | grep -q 'HTTP/1.1 302 Found'\" , ] interval : 10 s timeout : 10 s retries : 120 volumes : certs : driver : local enterprisesearchdata : driver : local esdata01 : driver : local kibanadata : driver : local ``` Note There are custom settings for enterprisesearch in the .yml file: app_search.engine.total_fields.limit=128 Bring up the Elastic cluster with the following command (run it from the directory where the .yml file is): ``` docker-compose up ``` Access Kibana at http://localhost:5601 . Log in as elastic for username, your password being the value you provided for ELASTIC_PASSWORD in your .env file. Then Access Elasticsearch at http://localhost:9200 . Tip You can find more info on deploying Elastic App Search with Docker here .","title":"Deploying Elastic App Search using Docker"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#setting-up-elastic-app-search-on-platform","text":"To install Elastic App Search for Virto Platform, do the following: Install the vc-module-elastic-app-search module Modify the Platform configuration to use Elastic App Search: \"Search\" : { \"Provider\" : \"ElasticAppSearch\" , \"Scope\" : \"default\" , \"ElasticAppSearch\" : { \"Endpoint\" : \"https://localhost:3002\" , \"PrivateApiKey\" : \"private-key\" } } Open Kibana (localhost:5601), navigate to Enterprise Search > Open App Search > Credentials , copy Private Key, and assign it to the PrivateApiKey setting: Run Platform and build the indexes. You should see the ElasticAppSearch value for Provider : Navigate back to Kibana and confirm that engines (indexes) are created:","title":"Setting up Elastic App Search on Platform"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#running-storefont-and-working-with-app-search","text":"","title":"Running Storefont and Working with App Search"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#running-vc-storefront-application","text":"Navigate to the Storefront root directory: cd C: \\v c-storefront \\V irtoCommerce.Storefront Build and run the Storefront application: dotnet run","title":"Running vc-storefront Application"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elastic-app-search/#working-with-elastic-app-search","text":"In Kibana , open the App Search Engines overview page. Here can see four engines created after rebuilding the indexes. Clicking on the products engine, you will see general analytics about incoming queries and will be able to manage indexed documents and tune engine behavior with Relevance Tuning , Synonyms , and Curations . Open the Documents menu to examine all indexed documents and their content. Open the Schema menu to see which fields the documents contain. You can examine product index contents in the Platform admin UI by opening the Products screen and clicking the Index widget. Open Synonyms and add search query synonyms. For instance, associating the Sony keyword with the Samsung keyword and trying out the same query as before will yield a different result: you will also get all documents relevant to the Samsung keyword. Go to Storefront and see that the integration works and you get both Sony and Samsung products by the Sony keyword: Curation is a tool, by which you can handpick the results for certain search queries. E.g., search by the Sony keyword again and examine the entries. You can delete a specific document from the result set by clicking the Delete button, and add a new document by clicking the Add manually button and selecting a document from a different result set. Save the curation and check it in the Storefront:","title":"Working with Elastic App Search"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elasticsearch/","text":"Configuring Elasticsearch Virto's VirtoCommerce.ElasticSearch module enables integrating Elasticsearch as a search engine . Note This module only supports Elasticsearch engine versions between 6.5 and 8.0. VirtoCommerce.ElasticSearch implements ISearchProvider defined in the VirtoCommerce Search module and uses the Elasticsearch engine, which stores indexed documents on: Standalone Elasticsearch Elastic Cloud Amazon OpenSearch Service (successor to Amazon Elasticsearch Service) Configuration To configure Elasticsearch as a search provider, use the following schema: \"Search\":{ <!-- is the name of the search provider and must be ElasticSearch --> \"Provider\": \"ElasticSearch\", <!-- is a common name (prefix) of all indexes. Each document type is stored in a separate index. Full index name is scope-{documenttype}. One search service can serve multiple indexes. Optional. Default value is default. --> \"Scope\": \"default\", \"ElasticSearch\": { <!-- is a network address and port of the Elasticsearch server. --> \"Server\": \"https://localhost:9200\", <!-- is a user name for either elastic cloud cluster or private elastic server. Optional. Default value is elastic. --> \"User\": \"elastic\", <!-- is a password for either elastic cloud cluster or private elastic server. Optional. --> \"Key\": \"{SECRET_KEY}\", <!-- compatibilty with eralier version. optional --> \"EnableCompatibilityMode\": \"true\", \"CertificateFingerprint\": \"{CERTIFICATE_FINGERPRINT}\" } } Elasticsearch v8.x For Elasticsearch provider v8.x, the configuration string must have seven parameters; namely, you need to add these fields: EnableCompatibilityMode with the true value for using Elasticsearch v8.x or false for earlier version, and CertificateFingerprint for certificate fingerprint. You can read more about it here . To activate Elasticsearch integration, make the following changes to the platform configuration: appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"https://localhost:9200\", \"User\": \"elastic\", \"Key\": \"{SECRET_KEY}\", \"EnableCompatibilityMode\": \"true\", \"CertificateFingerprint\": \"{CERTIFICATE_FINGERPRINT}\" } } Elasticsearch between v6.5 and v8.x appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"localhost:9200\", } } Elastic Cloud appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"https://4fe3ad462de203c52b358ff2cc6fe9cc.europe-west1.gcp.cloud.es.io:9243\", \"Key\": \"{SECRET_KEY}\", } } Amazon OpenSearch Service appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"https://{master-user}:{master-user-password}@search-test-vc-c74km3tiav64fiimnisw3ghpd4.us-west-1.es.amazonaws.com;\", } }","title":"Configuring Elasticsearch"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elasticsearch/#configuring-elasticsearch","text":"Virto's VirtoCommerce.ElasticSearch module enables integrating Elasticsearch as a search engine . Note This module only supports Elasticsearch engine versions between 6.5 and 8.0. VirtoCommerce.ElasticSearch implements ISearchProvider defined in the VirtoCommerce Search module and uses the Elasticsearch engine, which stores indexed documents on: Standalone Elasticsearch Elastic Cloud Amazon OpenSearch Service (successor to Amazon Elasticsearch Service)","title":"Configuring Elasticsearch"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elasticsearch/#configuration","text":"To configure Elasticsearch as a search provider, use the following schema: \"Search\":{ <!-- is the name of the search provider and must be ElasticSearch --> \"Provider\": \"ElasticSearch\", <!-- is a common name (prefix) of all indexes. Each document type is stored in a separate index. Full index name is scope-{documenttype}. One search service can serve multiple indexes. Optional. Default value is default. --> \"Scope\": \"default\", \"ElasticSearch\": { <!-- is a network address and port of the Elasticsearch server. --> \"Server\": \"https://localhost:9200\", <!-- is a user name for either elastic cloud cluster or private elastic server. Optional. Default value is elastic. --> \"User\": \"elastic\", <!-- is a password for either elastic cloud cluster or private elastic server. Optional. --> \"Key\": \"{SECRET_KEY}\", <!-- compatibilty with eralier version. optional --> \"EnableCompatibilityMode\": \"true\", \"CertificateFingerprint\": \"{CERTIFICATE_FINGERPRINT}\" } }","title":"Configuration"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elasticsearch/#elasticsearch-v8x","text":"For Elasticsearch provider v8.x, the configuration string must have seven parameters; namely, you need to add these fields: EnableCompatibilityMode with the true value for using Elasticsearch v8.x or false for earlier version, and CertificateFingerprint for certificate fingerprint. You can read more about it here . To activate Elasticsearch integration, make the following changes to the platform configuration: appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"https://localhost:9200\", \"User\": \"elastic\", \"Key\": \"{SECRET_KEY}\", \"EnableCompatibilityMode\": \"true\", \"CertificateFingerprint\": \"{CERTIFICATE_FINGERPRINT}\" } }","title":"Elasticsearch v8.x"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elasticsearch/#elasticsearch-between-v65-and-v8x","text":"appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"localhost:9200\", } }","title":"Elasticsearch between v6.5 and v8.x"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elasticsearch/#elastic-cloud","text":"appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"https://4fe3ad462de203c52b358ff2cc6fe9cc.europe-west1.gcp.cloud.es.io:9243\", \"Key\": \"{SECRET_KEY}\", } }","title":"Elastic Cloud"},{"location":"Fundamentals/Indexed-Search/integration/configuring-elasticsearch/#amazon-opensearch-service","text":"appsettings.json \"Search\":{ \"Provider\": \"ElasticSearch\", \"Scope\": \"default\", \"ElasticSearch\": { \"Server\": \"https://{master-user}:{master-user-password}@search-test-vc-c74km3tiav64fiimnisw3ghpd4.us-west-1.es.amazonaws.com;\", } }","title":"Amazon OpenSearch Service"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/","text":"Elastic Search App Overview Search powers the way people shop and helps them find exactly what they are looking for, instantly. Virto Commerce can bring unparalleled relevance and personalized suggestions, optimize product discovery, turning browsers into buyers with seamless transactions that inspire repeat purchases. Virto Commerce and Elastic App Search bring the next level of ecommerce administration experience. You can use analytics to improve ecommerce search relevance without any development effort. Prerequisites To start using Elastic App Search, you will need to install and configure the following: Elastic App Search 8.x Virto Commerce 3.2xx Elastic App Search Virto Commerce Module 3.2xx Virto Storefront 6.x Vue B2B Theme 1.x Note After completing the above steps, you will also need to rebuild the index in Virto Commerce. Note If you are already using Virto Commerce, we recommend you testing it by using the Elastic App Search module. Using Analytics Every time a customer searches for something on your website, they provide your business with valuable information about what they are looking for. To view this info, you can use Kibana and Open: Enterprise Search \u2192 App Search \u2192 Engines : By default, Virto Commerce adds four engines: Product , Category , CustomerOrder , and Member . Choose the Product engine and review the Overview section, where you can find basic information on product queries and API requests per day: Choose Analytics to dive into customer experience and query data. Out-of-the-box data collection, metrics, and visualizations on search keywords give you all you need to glean insights from the user behavior: Improving Search Relevance With Elastic App Search, you can make relevance and tune adjustments, or promote/demote results based on your findings in a few clicks, right from the management interface. Below, you can find out how to improve the search relevance with: Synonyms Curations Relevance Tuning Using Synonyms Sometimes, users will use different terminology than your context might expect. In the Top queries with no results section, you can find query results. For example, your customers might have searched for duplicator , but when you go to Storefront and try searching duplicator , you didn\u2019t find any product for it: It is a common mistake that may to poor search relevance: you are selling movies, but they want films . The Synonym feature builds synonym sets . A synonym set contains two or more queries that have similar meanings. Each synonym set can contain up to 32 words. To manage synonyms through the App Search dashboard, choose Synonyms , choose Create a synonym set , and add a synonym set. Once you click Save , the synonym set will be applied: Now, if your customer searches for duplicator , they will see the appropriate product set: Configuring Synonyms is a useful way to guide your users to the most relevant content. It is most useful when you know the precise terms they are searching for. For that, you should explore Analytics , so that you might be aware of your insightful capabilities. If you are looking to provide even more precise and curated results, venture to the Curations section. Curations Curations allow search operators to customize search results for specific queries. For instance, you can use promoted products to ensure that the specified products always match a query and receive the highest relevance scores. Imagine an ecommerce store with featured product results. Similarly, use hidden documents to exclude particular products from the results. Here is how you can boost product search score for, e.g., office printer search query. Manage curations using Kibana: Open Enterprise Search \u2192 App Search \u2192 Engines \u2192 product_ engine \u2192 Curations Add a curation for office printer In our example, we promote two products: 565507636 - HP OfficeJet Pro 6978 All-in-One Multifunction and 551879675 - HP LaserJet Pro MFP M521dn - multifunction printer (B/W) : Once you click Save , the curation will be applied: Note Currently, Elastic App Search offers an upgrade to the Platinum subscription to harness the power of machine learning. By analyzing your engine\u2019s analytics, App Search is able to suggest new or updated curations. This way, you can effortlessly help your users find exactly what they are looking for. If you are looking for advanced results, continue reading to the Relevance Tuning section. Relevance Tuning Out of the box, App Search provides quality search relevance. Built on top of Elasticsearch, App Search is a managed, the expertly crafted distillation of its finest points. It provides tools to help you further tune the search experience to optimize for your own needs. We recommend you reviewing this step by step guide . Performance After running load tests and comparing Elasticsearch Vs Elastic App Search, we can confirm that both engines are ready for production and demonstrate the same results. Limitations For performance and historical reasons, App Search has default limitations on some objects and API calls. You can review the current limitations here .","title":"Elastic App Search Overview"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#elastic-search-app-overview","text":"Search powers the way people shop and helps them find exactly what they are looking for, instantly. Virto Commerce can bring unparalleled relevance and personalized suggestions, optimize product discovery, turning browsers into buyers with seamless transactions that inspire repeat purchases. Virto Commerce and Elastic App Search bring the next level of ecommerce administration experience. You can use analytics to improve ecommerce search relevance without any development effort.","title":"Elastic Search App Overview"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#prerequisites","text":"To start using Elastic App Search, you will need to install and configure the following: Elastic App Search 8.x Virto Commerce 3.2xx Elastic App Search Virto Commerce Module 3.2xx Virto Storefront 6.x Vue B2B Theme 1.x Note After completing the above steps, you will also need to rebuild the index in Virto Commerce. Note If you are already using Virto Commerce, we recommend you testing it by using the Elastic App Search module.","title":"Prerequisites"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#using-analytics","text":"Every time a customer searches for something on your website, they provide your business with valuable information about what they are looking for. To view this info, you can use Kibana and Open: Enterprise Search \u2192 App Search \u2192 Engines : By default, Virto Commerce adds four engines: Product , Category , CustomerOrder , and Member . Choose the Product engine and review the Overview section, where you can find basic information on product queries and API requests per day: Choose Analytics to dive into customer experience and query data. Out-of-the-box data collection, metrics, and visualizations on search keywords give you all you need to glean insights from the user behavior:","title":"Using Analytics"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#improving-search-relevance","text":"With Elastic App Search, you can make relevance and tune adjustments, or promote/demote results based on your findings in a few clicks, right from the management interface. Below, you can find out how to improve the search relevance with: Synonyms Curations Relevance Tuning","title":"Improving Search Relevance"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#using-synonyms","text":"Sometimes, users will use different terminology than your context might expect. In the Top queries with no results section, you can find query results. For example, your customers might have searched for duplicator , but when you go to Storefront and try searching duplicator , you didn\u2019t find any product for it: It is a common mistake that may to poor search relevance: you are selling movies, but they want films . The Synonym feature builds synonym sets . A synonym set contains two or more queries that have similar meanings. Each synonym set can contain up to 32 words. To manage synonyms through the App Search dashboard, choose Synonyms , choose Create a synonym set , and add a synonym set. Once you click Save , the synonym set will be applied: Now, if your customer searches for duplicator , they will see the appropriate product set: Configuring Synonyms is a useful way to guide your users to the most relevant content. It is most useful when you know the precise terms they are searching for. For that, you should explore Analytics , so that you might be aware of your insightful capabilities. If you are looking to provide even more precise and curated results, venture to the Curations section.","title":"Using Synonyms"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#curations","text":"Curations allow search operators to customize search results for specific queries. For instance, you can use promoted products to ensure that the specified products always match a query and receive the highest relevance scores. Imagine an ecommerce store with featured product results. Similarly, use hidden documents to exclude particular products from the results. Here is how you can boost product search score for, e.g., office printer search query. Manage curations using Kibana: Open Enterprise Search \u2192 App Search \u2192 Engines \u2192 product_ engine \u2192 Curations Add a curation for office printer In our example, we promote two products: 565507636 - HP OfficeJet Pro 6978 All-in-One Multifunction and 551879675 - HP LaserJet Pro MFP M521dn - multifunction printer (B/W) : Once you click Save , the curation will be applied: Note Currently, Elastic App Search offers an upgrade to the Platinum subscription to harness the power of machine learning. By analyzing your engine\u2019s analytics, App Search is able to suggest new or updated curations. This way, you can effortlessly help your users find exactly what they are looking for. If you are looking for advanced results, continue reading to the Relevance Tuning section.","title":"Curations"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#relevance-tuning","text":"Out of the box, App Search provides quality search relevance. Built on top of Elasticsearch, App Search is a managed, the expertly crafted distillation of its finest points. It provides tools to help you further tune the search experience to optimize for your own needs. We recommend you reviewing this step by step guide .","title":"Relevance Tuning"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#performance","text":"After running load tests and comparing Elasticsearch Vs Elastic App Search, we can confirm that both engines are ready for production and demonstrate the same results.","title":"Performance"},{"location":"Fundamentals/Indexed-Search/integration/elastic-app-search-overview/#limitations","text":"For performance and historical reasons, App Search has default limitations on some objects and API calls. You can review the current limitations here .","title":"Limitations"},{"location":"Fundamentals/Indexed-Search/search/faceted-search/","text":"Faceted Search Overview and Configuration Faceted search (sometimes also called faceted navigation) allows users to navigate through a website by applying filters for categories, attributes, price ranges, and so on. The main idea behind faceted search is to present the attributes of the documents of the previous search result as filters, which can be used by the user to narrow down search results, along with calculating statistical counts to aid. For example, let's assume we need to query for all blue shirts. The search engine has a facet configured on the category category level, and another one on the color attribute level. This way, the search query will be executed using these two facets. The search result will return the entries that are aggregated both in the category facet with the shirt category ID and in the color facet with the value blue . Muti-select Faceting Search This policy allows you to select multiple values of the same facet (e.g using a checkbox). You can read more on how muti-select faceting search works in this article telling you how to implement multi-select faceting for nested documents in Solr. You may also want to check out Elastic search post filter . The muti-select faceting search policy is enabled by default and you do not need any extra parameters or setting to activate it. Faceted Search Configuration This section is based on example of catalog entities, where the properties available for faceted search are configured at the Store level in Platform Manager. Open Stores , select an appropriate store, click the Aggregation Properties widget, and pick catalog properties eligible for filtering in this store: There are two facet types (aggregation types) that are supported for configuration: Attribute facet: Displays and enables using all or selected values of the selected property for facet filters, e.g color: Red(1), Blue(22) , etc. Range facet: Enables aggregating facet counts across ranges of values. This type is applicable to the date, time, datetime, number, and money type fields.","title":"Faceted Search Overview and Configuration"},{"location":"Fundamentals/Indexed-Search/search/faceted-search/#faceted-search-overview-and-configuration","text":"Faceted search (sometimes also called faceted navigation) allows users to navigate through a website by applying filters for categories, attributes, price ranges, and so on. The main idea behind faceted search is to present the attributes of the documents of the previous search result as filters, which can be used by the user to narrow down search results, along with calculating statistical counts to aid. For example, let's assume we need to query for all blue shirts. The search engine has a facet configured on the category category level, and another one on the color attribute level. This way, the search query will be executed using these two facets. The search result will return the entries that are aggregated both in the category facet with the shirt category ID and in the color facet with the value blue .","title":"Faceted Search Overview and Configuration"},{"location":"Fundamentals/Indexed-Search/search/faceted-search/#muti-select-faceting-search","text":"This policy allows you to select multiple values of the same facet (e.g using a checkbox). You can read more on how muti-select faceting search works in this article telling you how to implement multi-select faceting for nested documents in Solr. You may also want to check out Elastic search post filter . The muti-select faceting search policy is enabled by default and you do not need any extra parameters or setting to activate it.","title":"Muti-select Faceting Search"},{"location":"Fundamentals/Indexed-Search/search/faceted-search/#faceted-search-configuration","text":"This section is based on example of catalog entities, where the properties available for faceted search are configured at the Store level in Platform Manager. Open Stores , select an appropriate store, click the Aggregation Properties widget, and pick catalog properties eligible for filtering in this store: There are two facet types (aggregation types) that are supported for configuration: Attribute facet: Displays and enables using all or selected values of the selected property for facet filters, e.g color: Red(1), Blue(22) , etc. Range facet: Enables aggregating facet counts across ranges of values. This type is applicable to the date, time, datetime, number, and money type fields.","title":"Faceted Search Configuration"},{"location":"Fundamentals/Indexed-Search/search/overview/","text":"Indexed Search Overview The common search component is an entry point in Virto commerce application that is used to perform search request. The chart below shows the components used to process a search request: A specific search service (e.g ProductIndexedSearchService ) is designed to handle search requests for particular domain entities, such as catalog products or customers. A specific search service processes a search query starts with parsing the query text to convert it to the object of the search request by calling ISearchRequestBuilder . Then search request is sent to the specific search engine through the ISearchProvider abstraction that uses an index to retrieve documents with matching terms. At the next stage, all specific search services are materialized in all found documents via fetching the entities by their identifiers from the data source (e.g., database) and return the resulting entities to the requester. Note In Virto search, we use an additional roundtrip call to the data source to get the actual entity data for the resulting documents the index engine returns. Restated, query execution has four stages: Query parsing Index document retrieval Resulting documented enrichment with entities are taken from data source Anatomy of Search Request and Query Parsing A search request is a complete specification of what should be returned in the result set. It has search engine agnostic nature; this generic form enables easily switching between different search engines without any business logic changes. In simplest form, it is an empty query with no criteria of any kind. The following example shows how a query string saying black brand:Asus will be converted into the search request: new SearchRequest { SearchKeywords = new [] { \"black\" }, Filter = new [] { new TermFilter { FieldName : new [] { \"brand\" , \"Asus\" } },, Sorting = \"name:desc\" , Skip = 0 , Take = 20 };","title":"Overview"},{"location":"Fundamentals/Indexed-Search/search/overview/#indexed-search-overview","text":"The common search component is an entry point in Virto commerce application that is used to perform search request. The chart below shows the components used to process a search request: A specific search service (e.g ProductIndexedSearchService ) is designed to handle search requests for particular domain entities, such as catalog products or customers. A specific search service processes a search query starts with parsing the query text to convert it to the object of the search request by calling ISearchRequestBuilder . Then search request is sent to the specific search engine through the ISearchProvider abstraction that uses an index to retrieve documents with matching terms. At the next stage, all specific search services are materialized in all found documents via fetching the entities by their identifiers from the data source (e.g., database) and return the resulting entities to the requester. Note In Virto search, we use an additional roundtrip call to the data source to get the actual entity data for the resulting documents the index engine returns. Restated, query execution has four stages: Query parsing Index document retrieval Resulting documented enrichment with entities are taken from data source","title":"Indexed Search Overview"},{"location":"Fundamentals/Indexed-Search/search/overview/#anatomy-of-search-request-and-query-parsing","text":"A search request is a complete specification of what should be returned in the result set. It has search engine agnostic nature; this generic form enables easily switching between different search engines without any business logic changes. In simplest form, it is an empty query with no criteria of any kind. The following example shows how a query string saying black brand:Asus will be converted into the search request: new SearchRequest { SearchKeywords = new [] { \"black\" }, Filter = new [] { new TermFilter { FieldName : new [] { \"brand\" , \"Asus\" } },, Sorting = \"name:desc\" , Skip = 0 , Take = 20 };","title":"Anatomy of Search Request and Query Parsing"},{"location":"Fundamentals/Integration/Payment-Gateways/new-payment-method-registration/","text":"There are two approaches of working with payment systems: Off-site: The customer fills in the required payment credentials in payment system. On-site: The customer fills in the required payment details on the seller's system side. Once the required details are filled, the seller's system sends a request to the payment system. In some specific cases, the customer will be asked to enter additional security data to commit the transaction (MasterCard SecureCode). VirtoCommerce supports both off-site and on-site payment method implementations. To view or download our sample code, click here . Concepts This chart shows how the off-site payment method works: Defining New Payment Method In order to define a new payment method, you need to: Create a new module by following this guide Create a class derived from the PaymentMethod abstract class and override all abstract methods; each of them will be called on the appropriate stage of the payment processing workflow: public class DefaultManualPaymentMethod : PaymentMethod { //has to implement payment transaction registration in an outside payment system; //gets ProcessPaymentEvaluationContext as a parameter, which contains all the required information to create a payment transaction in an outside payment system; //returns ProcessPaymentResult as a result, which includes the OuterId property, that has to be set to PaymentId. That way it associates payment in the Virto Commerce platform with the payment transaction in //the outside payment system public override ProcessPaymentRequestResult ProcessPayment ( ProcessPaymentRequest request ) { ... } //has to implement payment status check in the outside payment system; //get PostProcessPaymentEvaluationContext as a parameter, which contains all the required information to check payment status in outside payment system; //returns PostProcessPaymentResult as a result, which includes the payment status result returned by the outside payment system public override PostProcessPaymentRequestResult PostProcessPayment ( PostProcessPaymentRequest request ) { ... } public override VoidPaymentRequestResult VoidProcessPayment ( VoidPaymentRequest request ) { ... } public override CapturePaymentRequestResult CaptureProcessPayment ( CapturePaymentRequest request ) { ... } public override RefundPaymentRequestResult RefundProcessPayment ( RefundPaymentRequest request ) { ... } //has to impelement querystring request processing. The request comes to `push url` from outside payment system or frontend. The `push url` is set in account settings of most payment systems or during //payment transaction processing in outside payment system (ProcessPayment method). //as a result of successfully checked (valid) payment the OuterId property of ValidatePostProcessRequestResult has to be set. It identifies payment in VirtoCommerce with the transaction in outside payment system. public override ValidatePostProcessRequestResult ValidatePostProcessRequest ( System . Collections . Specialized . NameValueCollection queryString ) { ... } } Register your module class in the DI container. This must be done in the PostInitialize method. You can also associate the settings, which will be used in your method and can be changed in the management UI. public void PostInitialize ( IApplicationBuilder applicationBuilder ) { ... var settingsRegistrar = appBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar >(); var paymentMethodsRegistrar = appBuilder . ApplicationServices . GetRequiredService < IPaymentMethodsRegistrar >(); paymentMethodsRegistrar . RegisterPaymentMethod < DefaultManualPaymentMethod >(); //Associate the settings with the particular payment method settingsRegistrar . RegisterSettingsForType ( ModuleConstants . Settings . DefaultManualPaymentMethod . AllSettings , typeof ( DefaultManualPaymentMethod ). Name ); ... } A very important property belonging to the payment method is PaymentMethodType , which defines the actions run by the front end to get the transaction registration result. Currently, there are two types of actions defined, with more being implemented in future: Redirection : Use this type of action if the payment method redirects the user to an outside URL. In order to do so, point the link to the RedirectUrl property in the ProcessPaymentResult . The front end will use it to redirect the customer (for example, this will happen with the Paypal Express Checkout payment method). PreparedForm : Use this type of action in case the payment method provides an HTML form for filling in the credentials. Namely, you need to set the HtmlForm property in the ProcessPaymentResult with an HTML form the outside payment system returns or with the generated form in our payment system. An example of such behavior would be the Klarna Checkout payment method. Enable and Configure Payment Method for Store After your module is installed in your target system, all your payment methods should appear and be available for configuration in every store in your system under the Store->Payment method widget. You can configure payment methods for each store individually: Enable or disable a method for the current store Change priority to determine the order in which the payment methods will be displayed at checkout Edit all settings and what you define for the payment method Use a custom UI for more detailed payment method configuration After you are done configuring, your payment method will appear in the front end checkout page, and the customer will be able to select it as an option. UI Customization If our standard user interface is not enough, you may consider implementing your own UI for managing payment methods through the standard UI extension point (widget container with the paymentMethodDetail group). You can read more about extending the existing UI with widgets here .","title":"Registering New Payment Method"},{"location":"Fundamentals/Integration/Payment-Gateways/new-payment-method-registration/#concepts","text":"This chart shows how the off-site payment method works:","title":"Concepts"},{"location":"Fundamentals/Integration/Payment-Gateways/new-payment-method-registration/#defining-new-payment-method","text":"In order to define a new payment method, you need to: Create a new module by following this guide Create a class derived from the PaymentMethod abstract class and override all abstract methods; each of them will be called on the appropriate stage of the payment processing workflow: public class DefaultManualPaymentMethod : PaymentMethod { //has to implement payment transaction registration in an outside payment system; //gets ProcessPaymentEvaluationContext as a parameter, which contains all the required information to create a payment transaction in an outside payment system; //returns ProcessPaymentResult as a result, which includes the OuterId property, that has to be set to PaymentId. That way it associates payment in the Virto Commerce platform with the payment transaction in //the outside payment system public override ProcessPaymentRequestResult ProcessPayment ( ProcessPaymentRequest request ) { ... } //has to implement payment status check in the outside payment system; //get PostProcessPaymentEvaluationContext as a parameter, which contains all the required information to check payment status in outside payment system; //returns PostProcessPaymentResult as a result, which includes the payment status result returned by the outside payment system public override PostProcessPaymentRequestResult PostProcessPayment ( PostProcessPaymentRequest request ) { ... } public override VoidPaymentRequestResult VoidProcessPayment ( VoidPaymentRequest request ) { ... } public override CapturePaymentRequestResult CaptureProcessPayment ( CapturePaymentRequest request ) { ... } public override RefundPaymentRequestResult RefundProcessPayment ( RefundPaymentRequest request ) { ... } //has to impelement querystring request processing. The request comes to `push url` from outside payment system or frontend. The `push url` is set in account settings of most payment systems or during //payment transaction processing in outside payment system (ProcessPayment method). //as a result of successfully checked (valid) payment the OuterId property of ValidatePostProcessRequestResult has to be set. It identifies payment in VirtoCommerce with the transaction in outside payment system. public override ValidatePostProcessRequestResult ValidatePostProcessRequest ( System . Collections . Specialized . NameValueCollection queryString ) { ... } } Register your module class in the DI container. This must be done in the PostInitialize method. You can also associate the settings, which will be used in your method and can be changed in the management UI. public void PostInitialize ( IApplicationBuilder applicationBuilder ) { ... var settingsRegistrar = appBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar >(); var paymentMethodsRegistrar = appBuilder . ApplicationServices . GetRequiredService < IPaymentMethodsRegistrar >(); paymentMethodsRegistrar . RegisterPaymentMethod < DefaultManualPaymentMethod >(); //Associate the settings with the particular payment method settingsRegistrar . RegisterSettingsForType ( ModuleConstants . Settings . DefaultManualPaymentMethod . AllSettings , typeof ( DefaultManualPaymentMethod ). Name ); ... } A very important property belonging to the payment method is PaymentMethodType , which defines the actions run by the front end to get the transaction registration result. Currently, there are two types of actions defined, with more being implemented in future: Redirection : Use this type of action if the payment method redirects the user to an outside URL. In order to do so, point the link to the RedirectUrl property in the ProcessPaymentResult . The front end will use it to redirect the customer (for example, this will happen with the Paypal Express Checkout payment method). PreparedForm : Use this type of action in case the payment method provides an HTML form for filling in the credentials. Namely, you need to set the HtmlForm property in the ProcessPaymentResult with an HTML form the outside payment system returns or with the generated form in our payment system. An example of such behavior would be the Klarna Checkout payment method.","title":"Defining New Payment Method"},{"location":"Fundamentals/Integration/Payment-Gateways/new-payment-method-registration/#enable-and-configure-payment-method-for-store","text":"After your module is installed in your target system, all your payment methods should appear and be available for configuration in every store in your system under the Store->Payment method widget. You can configure payment methods for each store individually: Enable or disable a method for the current store Change priority to determine the order in which the payment methods will be displayed at checkout Edit all settings and what you define for the payment method Use a custom UI for more detailed payment method configuration After you are done configuring, your payment method will appear in the front end checkout page, and the customer will be able to select it as an option.","title":"Enable and Configure Payment Method for Store"},{"location":"Fundamentals/Integration/Payment-Gateways/new-payment-method-registration/#ui-customization","text":"If our standard user interface is not enough, you may consider implementing your own UI for managing payment methods through the standard UI extension point (widget container with the paymentMethodDetail group). You can read more about extending the existing UI with widgets here .","title":"UI Customization"},{"location":"Fundamentals/Integration/Shipping-Providers/new-shipping-method-registration/","text":"In case your customers have any shippable products to choose from, they can also choose a shipping option during checkout. Defining New Shipping Method In order to define a new shipping method, you need to: Create a new module by following this guide ) Create a class derived from the ShippingMethod abstract class and override all abstract methods; each of them will be called on the appropriate stage of the payment processing workflow: public class FixedRateShippingMethod : ShippingMethod { public FixedRateShippingMethod () : base ( \"FixedRate\" ) { } public override IEnumerable < ShippingRate > CalculateRates ( IEvaluationContext context ) { //Implement logic of shipping rates calculation here } } Register your module class in the DI container. This must be done in the PostInitialize method. You can also associate the settings, which will be used in your method and can be changed in the management UI. public void PostInitialize ( IApplicationBuilder applicationBuilder ) { ... var settingsRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar >(); var shippingMethodsRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < IShippingMethodsRegistrar >(); //Associate the settings with the particular shipping provider settingsRegistrar . RegisterSettingsForType ( ModuleConstants . Settings . FixedRateShippingMethod . AllSettings , typeof ( FixedRateShippingMethod ). Name ); shippingMethodsRegistrar . RegisterShippingMethod < FixedRateShippingMethod >(); ... } All settings may have default values that can be used for default methods if not overridden by custom values later. To view or download our sample code, click here . Enabling and Configuring Shipping Method for Store After your module is installed in your target system, all your shipping methods should appear and be available for configuration in every store in your system under the Store->Shipping methods widget. You can also configure shipping methods for each store individually: Enable or disable a method for the current store Change priority to determine the order in which the shipping methods will be displayed at checkout Edit all settings and what you define for the shipping method Use a custom UI for more detailed shipping method configuration After you are done configuring, your shipping method will appear in the front end checkout page, and the customer will be able to select it as an option. UI Customization If our standard user interface is not enough, you may consider implementing your own UI for managing shipping methods through the standard UI extension point (widget container with the shippingMethodDetail group). You can read more about extending the existing UI with widgets here .","title":"Registering New Shipping Method"},{"location":"Fundamentals/Integration/Shipping-Providers/new-shipping-method-registration/#defining-new-shipping-method","text":"In order to define a new shipping method, you need to: Create a new module by following this guide ) Create a class derived from the ShippingMethod abstract class and override all abstract methods; each of them will be called on the appropriate stage of the payment processing workflow: public class FixedRateShippingMethod : ShippingMethod { public FixedRateShippingMethod () : base ( \"FixedRate\" ) { } public override IEnumerable < ShippingRate > CalculateRates ( IEvaluationContext context ) { //Implement logic of shipping rates calculation here } } Register your module class in the DI container. This must be done in the PostInitialize method. You can also associate the settings, which will be used in your method and can be changed in the management UI. public void PostInitialize ( IApplicationBuilder applicationBuilder ) { ... var settingsRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar >(); var shippingMethodsRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < IShippingMethodsRegistrar >(); //Associate the settings with the particular shipping provider settingsRegistrar . RegisterSettingsForType ( ModuleConstants . Settings . FixedRateShippingMethod . AllSettings , typeof ( FixedRateShippingMethod ). Name ); shippingMethodsRegistrar . RegisterShippingMethod < FixedRateShippingMethod >(); ... } All settings may have default values that can be used for default methods if not overridden by custom values later. To view or download our sample code, click here .","title":"Defining New Shipping Method"},{"location":"Fundamentals/Integration/Shipping-Providers/new-shipping-method-registration/#enabling-and-configuring-shipping-method-for-store","text":"After your module is installed in your target system, all your shipping methods should appear and be available for configuration in every store in your system under the Store->Shipping methods widget. You can also configure shipping methods for each store individually: Enable or disable a method for the current store Change priority to determine the order in which the shipping methods will be displayed at checkout Edit all settings and what you define for the shipping method Use a custom UI for more detailed shipping method configuration After you are done configuring, your shipping method will appear in the front end checkout page, and the customer will be able to select it as an option.","title":"Enabling and Configuring Shipping Method for Store"},{"location":"Fundamentals/Integration/Shipping-Providers/new-shipping-method-registration/#ui-customization","text":"If our standard user interface is not enough, you may consider implementing your own UI for managing shipping methods through the standard UI extension point (widget container with the shippingMethodDetail group). You can read more about extending the existing UI with widgets here .","title":"UI Customization"},{"location":"Fundamentals/Integration/Tax-Providers/new-tax-provider-registration/","text":"In order to calculate taxes in Virto Commerce, you've got to register at least one TaxProvider implementation. Defining New Tax Provider In order to define a new tax provider, you need to: Create a new module by following this guide Create a class derived from the TaxProvider abstract class and override the CalculateRate method: public class FixedRateTaxProvider : TaxProvider { public FixedRateTaxProvider () { Code = \"FixedRate\" ; } public override IEnumerable < TaxRate > CalculateRates ( IEvaluationContext context ) { //Implement logic of tax calculation here } } Register your module class in the DI container. This must be done in the PostInitialize method. You can also associate the settings, which will be used in your method and can be changed in the management UI. public void PostInitialize ( IApplicationBuilder applicationBuilder ) { ... var settingsRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar >(); var taxProviderRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < ITaxProviderRegistrar >(); taxProviderRegistrar . RegisterTaxProvider < FixedRateTaxProvider >(); //Associate the settings with the particular tax provider settingsRegistrar . RegisterSettingsForType ( Core . ModuleConstants . Settings . FixedTaxProviderSettings . AllSettings , typeof ( FixedRateTaxProvider ). Name ); ... } All settings may have default values that can be used for default methods if not overridden by custom values later. To view or download our sample code, click here . Enabling and Configure Tax Provider for Store After your module is installed in your target system, all tax providers should appear and be available for configuration in every store in your system under the Store->Tax providers widget. You can configure tax provider for each store individually: Enable or disable a provider for the current store Edit all settings and what you define for the tax calculation provider Use a custom UI for a more detailed tax provider configuration After you complete the configuration, your tax provider will be used for tax calculation of orders in the store. UI Customization If our standard user interface is not enough, you may consider implementing your own UI for managing tax providers through the standard UI extension point (widget container with the taxProviderDetail group). You can read more about extending the existing UI with widgets here .","title":"Registering New Tax Provider"},{"location":"Fundamentals/Integration/Tax-Providers/new-tax-provider-registration/#defining-new-tax-provider","text":"In order to define a new tax provider, you need to: Create a new module by following this guide Create a class derived from the TaxProvider abstract class and override the CalculateRate method: public class FixedRateTaxProvider : TaxProvider { public FixedRateTaxProvider () { Code = \"FixedRate\" ; } public override IEnumerable < TaxRate > CalculateRates ( IEvaluationContext context ) { //Implement logic of tax calculation here } } Register your module class in the DI container. This must be done in the PostInitialize method. You can also associate the settings, which will be used in your method and can be changed in the management UI. public void PostInitialize ( IApplicationBuilder applicationBuilder ) { ... var settingsRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar >(); var taxProviderRegistrar = applicationBuilder . ApplicationServices . GetRequiredService < ITaxProviderRegistrar >(); taxProviderRegistrar . RegisterTaxProvider < FixedRateTaxProvider >(); //Associate the settings with the particular tax provider settingsRegistrar . RegisterSettingsForType ( Core . ModuleConstants . Settings . FixedTaxProviderSettings . AllSettings , typeof ( FixedRateTaxProvider ). Name ); ... } All settings may have default values that can be used for default methods if not overridden by custom values later. To view or download our sample code, click here .","title":"Defining New Tax Provider"},{"location":"Fundamentals/Integration/Tax-Providers/new-tax-provider-registration/#enabling-and-configure-tax-provider-for-store","text":"After your module is installed in your target system, all tax providers should appear and be available for configuration in every store in your system under the Store->Tax providers widget. You can configure tax provider for each store individually: Enable or disable a provider for the current store Edit all settings and what you define for the tax calculation provider Use a custom UI for a more detailed tax provider configuration After you complete the configuration, your tax provider will be used for tax calculation of orders in the store.","title":"Enabling and Configure Tax Provider for Store"},{"location":"Fundamentals/Integration/Tax-Providers/new-tax-provider-registration/#ui-customization","text":"If our standard user interface is not enough, you may consider implementing your own UI for managing tax providers through the standard UI extension point (widget container with the taxProviderDetail group). You can read more about extending the existing UI with widgets here .","title":"UI Customization"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/","text":"Modular Architecture Overview This article provides an overview of modular architecture, a pillar principle of any Virto Commerce solution. Virto Commerce is a modular platform that consists of various loosely coupled components that are loaded into the platform application. It is a good way of tackling complexity for large applications by breaking it up into separate conceptual modules. A module encapsulates a portion of the application's overall functionality and typically contains a set of related components, such as domain features, including user interface and business logic, or pieces of application infrastructure and REST API methods. Modules are independent of one another but can communicate with each other in a loosely coupled fashion. Either way, it is important to keep the communication between modules to a minimum to avoid dependency issues. Overall, modular architecture makes it easier for you to develop, test, deploy, and maintain your application. Note When designing your modules, you have to stick to the the loosely coupled and shared-nothing infrastructure principles. The following chart shows the overall design concept of the platform application: Notes to the chart: Platform application: Works as a runtime environment that hosts the modules running within the same process and having access to shared resources and dependencies. Modularity engine: A software component that is responsible for module discovery, initialization, and loading into the main ASP.NET app process. Module: A piece of functionality that can be added into the platform app at runtime. Cross-cutting functionality: Common or shared logic that can be reused from any program level or component. e.g., caching, security, logging, etc. Virto Architecture: Plugins or Modules? Traditionally, module and plugin are defined as follows: A Module is a self-contained piece of software, which may contain types, data structure, functions, or otherwise, and can be combined with other modules to construct more complex software. In the meantime, a Plugin is a ready to use software component that can be added to an existing software to change or add features. Now, the question is: which definition do the Virto modules meet? The answer is, both. As a module, any Virto component can have dependencies to other modules, while, as a plugin, it can be added to an existing application without any recompilation. A well known design pattern, Modular Monolith , does also apply to Virto, with monolith referring to the hosting or runtime model. This means that all services and parts exist in the same solution (not in the same project), are running in the same process, and are therefore deployed at the same time. However, each service or part is located in its own module (.NET project) and is thus decoupled from other modules. At the same time, the Virto platform cannot be considered as a pure Modular Monolith based entity, since the Virto modules are not parts of a single platform solution. Each module is an isolated project that can be developed, deployed, and installed into a running platform instance independently. Modular Architecture Benefits Virto uses modular architecture since it provides our solutions with various benefits, such as: Reduced complexity: Each module only gets linked to the code it specifically needs. Easier to refactor: Changing a module has less or no effect on other modules. Better for teams: It is easier for developers to work on different parts of the code. Enforcing boundaries: Once each component has achieved one hundred percent isolation, boundaries will be enforced between them. Scaling the development process up to multiple teams: You can have independent development and release cycles for each module implemented by different dev teams. Module Structure Each Virto module breaks down into multiple layers and encapsulates and groups all aspects, from front end to back end, that are in charge of proving the necessary features. Such layers are in line with the Vertical Slices design principle, which, at a high level, may be depicted like this: Instead of being coupled across a layer, a module is coupled vertically along a slice, while minimizing coupling between slices and maximizing it within a slice. This architecture is very convenient, as, when it comes to adding or changing a feature in an module, logically, e.g., changing the user interface, adding fields to models, modifying validation, and so on, you can do it all on each layer and then couple it vertically along a slice. For module solution, there is also a determined folder structure that reflects this logical structure, which is described in detail here . Modules Relationships Even though the modules should not have much coupling between each other, it is common for them to communicate with one another, and since all modules are loaded into the platform application process, they also have access to the platform functionality. A particular module can have the following types of relationships with another module and the platform: Use: Module A uses module B. Extend: Module A extends module B by modifying the behavior of module B or using special extensions points defined in module B. React: Module A reacts to module B when its behavior is triggered by an integration event in module B without module B being aware of module A. The chart below shows all possible types of relationships between modules and the platform: Apart from the above, there are several loosely coupled communication patterns, each with their own strong points. Typically, combinations of such patterns (see below) are used to create the resulting solution: Integration events: A module may log events, while other modules can subscribe to such events and get notified when it occurs. Integration events are a lightweight manner of setting up communication between two modules; therefore, they are easily implemented. Program and UI extension points: Certain extension points each module can expose to tasks to extend or supplement the existing module functionality with a new one. UI widgets and navigations Domain model overriding Persistent layer extensions Shared services: A shared service is a class that can be accessed through a common interface. Typically, shared services are located in shared assemblies and provide system-wide services, such as authentication, logging, or configuration. You can read more about modules versioning and dependencies here . Module Installation, Update, and Deployment Processes Virto offers two different ways to install and update modules: Runtime and Design-time modes. The Runtime mode is used to update and install modules on a working system or at the first time setup. This process is based on requesting the modules.json file, a registry that can be either public or internal and contains information on all modules and their latest major versions (minor and patch versions history is not stored). You can set the path to this file with the module.manifest setting in the appsettings.json file (see string 7): appsettings.json 1 ... 2 \"ExternalModules\" : { 3 //flag indicates to display and be able to install pre-release versions of modules 4 \"IncludePrerelease\" : true , 5 //url to json that contains all information about all available virto modules versions 6 //This URL can be changed to point into a file with modules versions specific for your solution 7 \"ModulesManifestUrl\" : \"https://raw.githubusercontent.com/VirtoCommerce/vc-modules/master/modules_v3.json\" , 8 ... 9 } 10 ... When using Virto Commerce in your production environment, you will rather have to deal with a list of your custom modules that have dependencies to the Virto modules that are not upgraded to the latest version. If this is the case, it is better to define your own version of the modules.json file that will contain a list of your custom and Virto modules with specific versions for your solution. Having your own modules.json file is basically the same as having package.json for NPM dependencies; the difference lies in the shared nature and the option to use it globally. The Design time mode is often leveraged during the development process, when you manage the installed versions of modules, or install or update them manually on the local computer or in any other public environment. Virto provides a special CLI tool for this that, more info on which can be found here . Here are a few examples of interface commands you can use to perform various operations: 1vc-build install -Module VirtoCommerce.Store : This installs the latest version of a particular module 1vc-build update : This updates the platform and all installed modules to the latest version For the module deployment process , you can also use our VirtoCommerce.GlobalTool , which helps bundle your module solution to the deployment package; you can read more on this here . Next Steps Now that we explained some basic things about Virto's modular architecture, feel free to check out other guides on this topic: Module Solution Folder Structure How to Create New Module Related Sources To learn more on the concepts covered by this article, we encourage you to also check out these sources: Modular Monolith by Kamil Grzybek Vertical Slice Architecture by Jimmy Bogard Software Architecture Patterns by Mark Richards (Microkernel Architecture) Bounded Context by Martin Fowler Context Mapping Pattern","title":"Overview"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#modular-architecture-overview","text":"This article provides an overview of modular architecture, a pillar principle of any Virto Commerce solution. Virto Commerce is a modular platform that consists of various loosely coupled components that are loaded into the platform application. It is a good way of tackling complexity for large applications by breaking it up into separate conceptual modules. A module encapsulates a portion of the application's overall functionality and typically contains a set of related components, such as domain features, including user interface and business logic, or pieces of application infrastructure and REST API methods. Modules are independent of one another but can communicate with each other in a loosely coupled fashion. Either way, it is important to keep the communication between modules to a minimum to avoid dependency issues. Overall, modular architecture makes it easier for you to develop, test, deploy, and maintain your application. Note When designing your modules, you have to stick to the the loosely coupled and shared-nothing infrastructure principles. The following chart shows the overall design concept of the platform application: Notes to the chart: Platform application: Works as a runtime environment that hosts the modules running within the same process and having access to shared resources and dependencies. Modularity engine: A software component that is responsible for module discovery, initialization, and loading into the main ASP.NET app process. Module: A piece of functionality that can be added into the platform app at runtime. Cross-cutting functionality: Common or shared logic that can be reused from any program level or component. e.g., caching, security, logging, etc.","title":"Modular Architecture Overview"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#virto-architecture-plugins-or-modules","text":"Traditionally, module and plugin are defined as follows: A Module is a self-contained piece of software, which may contain types, data structure, functions, or otherwise, and can be combined with other modules to construct more complex software. In the meantime, a Plugin is a ready to use software component that can be added to an existing software to change or add features. Now, the question is: which definition do the Virto modules meet? The answer is, both. As a module, any Virto component can have dependencies to other modules, while, as a plugin, it can be added to an existing application without any recompilation. A well known design pattern, Modular Monolith , does also apply to Virto, with monolith referring to the hosting or runtime model. This means that all services and parts exist in the same solution (not in the same project), are running in the same process, and are therefore deployed at the same time. However, each service or part is located in its own module (.NET project) and is thus decoupled from other modules. At the same time, the Virto platform cannot be considered as a pure Modular Monolith based entity, since the Virto modules are not parts of a single platform solution. Each module is an isolated project that can be developed, deployed, and installed into a running platform instance independently.","title":"Virto Architecture: Plugins or Modules?"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#modular-architecture-benefits","text":"Virto uses modular architecture since it provides our solutions with various benefits, such as: Reduced complexity: Each module only gets linked to the code it specifically needs. Easier to refactor: Changing a module has less or no effect on other modules. Better for teams: It is easier for developers to work on different parts of the code. Enforcing boundaries: Once each component has achieved one hundred percent isolation, boundaries will be enforced between them. Scaling the development process up to multiple teams: You can have independent development and release cycles for each module implemented by different dev teams.","title":"Modular Architecture Benefits"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#module-structure","text":"Each Virto module breaks down into multiple layers and encapsulates and groups all aspects, from front end to back end, that are in charge of proving the necessary features. Such layers are in line with the Vertical Slices design principle, which, at a high level, may be depicted like this: Instead of being coupled across a layer, a module is coupled vertically along a slice, while minimizing coupling between slices and maximizing it within a slice. This architecture is very convenient, as, when it comes to adding or changing a feature in an module, logically, e.g., changing the user interface, adding fields to models, modifying validation, and so on, you can do it all on each layer and then couple it vertically along a slice. For module solution, there is also a determined folder structure that reflects this logical structure, which is described in detail here .","title":"Module Structure"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#modules-relationships","text":"Even though the modules should not have much coupling between each other, it is common for them to communicate with one another, and since all modules are loaded into the platform application process, they also have access to the platform functionality. A particular module can have the following types of relationships with another module and the platform: Use: Module A uses module B. Extend: Module A extends module B by modifying the behavior of module B or using special extensions points defined in module B. React: Module A reacts to module B when its behavior is triggered by an integration event in module B without module B being aware of module A. The chart below shows all possible types of relationships between modules and the platform: Apart from the above, there are several loosely coupled communication patterns, each with their own strong points. Typically, combinations of such patterns (see below) are used to create the resulting solution: Integration events: A module may log events, while other modules can subscribe to such events and get notified when it occurs. Integration events are a lightweight manner of setting up communication between two modules; therefore, they are easily implemented. Program and UI extension points: Certain extension points each module can expose to tasks to extend or supplement the existing module functionality with a new one. UI widgets and navigations Domain model overriding Persistent layer extensions Shared services: A shared service is a class that can be accessed through a common interface. Typically, shared services are located in shared assemblies and provide system-wide services, such as authentication, logging, or configuration. You can read more about modules versioning and dependencies here .","title":"Modules Relationships"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#module-installation-update-and-deployment-processes","text":"Virto offers two different ways to install and update modules: Runtime and Design-time modes. The Runtime mode is used to update and install modules on a working system or at the first time setup. This process is based on requesting the modules.json file, a registry that can be either public or internal and contains information on all modules and their latest major versions (minor and patch versions history is not stored). You can set the path to this file with the module.manifest setting in the appsettings.json file (see string 7): appsettings.json 1 ... 2 \"ExternalModules\" : { 3 //flag indicates to display and be able to install pre-release versions of modules 4 \"IncludePrerelease\" : true , 5 //url to json that contains all information about all available virto modules versions 6 //This URL can be changed to point into a file with modules versions specific for your solution 7 \"ModulesManifestUrl\" : \"https://raw.githubusercontent.com/VirtoCommerce/vc-modules/master/modules_v3.json\" , 8 ... 9 } 10 ... When using Virto Commerce in your production environment, you will rather have to deal with a list of your custom modules that have dependencies to the Virto modules that are not upgraded to the latest version. If this is the case, it is better to define your own version of the modules.json file that will contain a list of your custom and Virto modules with specific versions for your solution. Having your own modules.json file is basically the same as having package.json for NPM dependencies; the difference lies in the shared nature and the option to use it globally. The Design time mode is often leveraged during the development process, when you manage the installed versions of modules, or install or update them manually on the local computer or in any other public environment. Virto provides a special CLI tool for this that, more info on which can be found here . Here are a few examples of interface commands you can use to perform various operations: 1vc-build install -Module VirtoCommerce.Store : This installs the latest version of a particular module 1vc-build update : This updates the platform and all installed modules to the latest version For the module deployment process , you can also use our VirtoCommerce.GlobalTool , which helps bundle your module solution to the deployment package; you can read more on this here .","title":"Module Installation, Update, and Deployment Processes"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#next-steps","text":"Now that we explained some basic things about Virto's modular architecture, feel free to check out other guides on this topic: Module Solution Folder Structure How to Create New Module","title":"Next Steps"},{"location":"Fundamentals/Modularity/01-overview-IN-PROGRESS/#related-sources","text":"To learn more on the concepts covered by this article, we encourage you to also check out these sources: Modular Monolith by Kamil Grzybek Vertical Slice Architecture by Jimmy Bogard Software Architecture Patterns by Mark Richards (Microkernel Architecture) Bounded Context by Martin Fowler Context Mapping Pattern","title":"Related Sources"},{"location":"Fundamentals/Modularity/02-folder-structure-IN-PROGRESS/","text":"Module Solution Folder Structure Typically, any Virto module solution is organized in the following way: Module.Core : This project contains all abstractions and domain model definitions and serves as an API to access all module functionality and enable interaction between other modules. This project has a class library project type and can be packaged and distributed as a NuGet package. Events : A folder containing all domain and integration events the module in question can trigger within the application. Services : Contains all abstractions and interfaces of all services that represent a programming API to the entire functionality of the module domain. Model : Contains domain model classes. ModuleConstants.cs : Houses all module constants, such as permissions, settings, and string literals. Module.Data : This project is comprised of business layers and may include repositories and domain service implementations. It is also of the class library type and can be packaged and distributed as a NuGet package and used as a reference from other modules. Caching : Contains strongly typed cache regions used in the module . Handlers : Houses domain and integration event handlers. Migrations : Contains database migrations. Model : Virto uses the Data Mapping pattern to isolate the domain model from the persistence specific one ( Persistence Ignorance principle). This folder contains classes that get directly mapped to database tables with using EF fluent API. Repositories : An implementation of repositories that provides a set of methods to access the database. These methods hide the code needed to implement various database features you need. Services : Contains the domain CRUD services and other business logic implementations. Module.Web : Represents an application level of module domain. This project uses all services and domain types in order to implement business scenarios. Initialization, public API, and user interface are also implemented on this level. This project cannot be used directly from other modules and is not distributed as a NuGet package. Content : Has CSS styles for the module user interface. Scripts : Contains Angular.js JavaScript files and templates used for module presentation in Platform Manager. dist : Contains the resulting JavaScript and style bundles as the output of the WebPack bundling process. Controllers : Has all ASP.NET MVC Core REST API controllers. Localizations : Contains resource files that are used for UI localization. Module.cs : Core module entry point. module.manifest : A required file that contains meta information describing your module with its dependencies and versions.","title":"Folder Structure"},{"location":"Fundamentals/Modularity/02-folder-structure-IN-PROGRESS/#module-solution-folder-structure","text":"Typically, any Virto module solution is organized in the following way: Module.Core : This project contains all abstractions and domain model definitions and serves as an API to access all module functionality and enable interaction between other modules. This project has a class library project type and can be packaged and distributed as a NuGet package. Events : A folder containing all domain and integration events the module in question can trigger within the application. Services : Contains all abstractions and interfaces of all services that represent a programming API to the entire functionality of the module domain. Model : Contains domain model classes. ModuleConstants.cs : Houses all module constants, such as permissions, settings, and string literals. Module.Data : This project is comprised of business layers and may include repositories and domain service implementations. It is also of the class library type and can be packaged and distributed as a NuGet package and used as a reference from other modules. Caching : Contains strongly typed cache regions used in the module . Handlers : Houses domain and integration event handlers. Migrations : Contains database migrations. Model : Virto uses the Data Mapping pattern to isolate the domain model from the persistence specific one ( Persistence Ignorance principle). This folder contains classes that get directly mapped to database tables with using EF fluent API. Repositories : An implementation of repositories that provides a set of methods to access the database. These methods hide the code needed to implement various database features you need. Services : Contains the domain CRUD services and other business logic implementations. Module.Web : Represents an application level of module domain. This project uses all services and domain types in order to implement business scenarios. Initialization, public API, and user interface are also implemented on this level. This project cannot be used directly from other modules and is not distributed as a NuGet package. Content : Has CSS styles for the module user interface. Scripts : Contains Angular.js JavaScript files and templates used for module presentation in Platform Manager. dist : Contains the resulting JavaScript and style bundles as the output of the WebPack bundling process. Controllers : Has all ASP.NET MVC Core REST API controllers. Localizations : Contains resource files that are used for UI localization. Module.cs : Core module entry point. module.manifest : A required file that contains meta information describing your module with its dependencies and versions.","title":"Module Solution Folder Structure"},{"location":"Fundamentals/Modularity/03-versioning-and-dependencies/","text":"Module Versioning and Dependencies Virto modules and platform use the SemVer pattern. Short for Semantic Versioning, SemVer, in its latest incarnation (v2.0.0), describes the versioning scheme as MAJOR.MINOR.PATCH , where: You increment MAJOR version when you make incompatible API changes. You increment MINOR version when you add functionality in a backwards-compatible manner. You increment PATCH version when you make backwards-compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. Along with the release version, you might also use pre-release versions by adding a prerelease tag. The resulting format of the pre-release version is as follows: MAJOR.MINOR.PATCH-<alpha | beta | rc When it comes to module pre-release tags, we generally follow the recognized naming conventions: Alpha: Alpha release, typically used for work-in-progress and experiments Beta: Beta release, typically one that is feature complete for the next planned release, but may contain some known bugs RC: Release candidate, typically a release that is potentially final (stable), unless significant bugs emerge. Each Virto module has a version both as a project assembly version and the one contained in the module.manifest file. Thus, to change the version, you will have to change both the assembly version manually in Directory.Build.Props (going forward, it will be automatically calculated from current Git branches and tags tanks in the GitVersion utility) and the module version is the module.manifest file. A module can depend on other modules and cannot function without the modules it depends on; along with this, each module has a dependency to a specific platform version. All module and platform dependencies must be described in the module.manifest file, namely, in the dependencies section: module.manifest 1 <?xml versio n = \"1.0\" e n codi n g= \"utf-8\" ?> 2 <module> 3 <id>Vir t oCommerce.Ca tal og</id> 4 <versio n > 3.3.0 </versio n > 5 <pla tf ormVersio n > 3.0.0 </pla tf ormVersio n > 6 <depe n de n cies> 7 <depe n de n cy id= \"VirtoCommerce.Core\" versio n = \"3.0.0\" /> 8 <depe n de n cy id= \"VirtoCommerce.BulkActionsModule\" versio n = \"3.0.0\" /> 9 </depe n de n cies> 10 ... The Virto dependency version resolving logic always interprets all versions as ^major.minor.path (Next Significant Release Caret Version Range operator), and it will always allow non-breaking updates. This is the best explained by the following example: Note ^1.2.3 is equivalent to >=1.2.3 <2.0.0 as none of the releases until 2.0 should break backwards compatibility. Managing Third Party Dependencies for Modules As all module assemblies are copied into the probing folder before being loaded into the platform application process, except the assemblies of the module in question, the platform module manager copies all third party dependency assemblies and applies the same version conflict resolution policy: Note The assembly with the highest version or the one that was modified last, wins. This fact may lead to an unexpected update of third party dependencies for other modules and the platform application itself when resolving an assembly at runtime. You should always consider this fact when updating dependencies for your custom modules.","title":"Versioning and Dependencies"},{"location":"Fundamentals/Modularity/03-versioning-and-dependencies/#module-versioning-and-dependencies","text":"Virto modules and platform use the SemVer pattern. Short for Semantic Versioning, SemVer, in its latest incarnation (v2.0.0), describes the versioning scheme as MAJOR.MINOR.PATCH , where: You increment MAJOR version when you make incompatible API changes. You increment MINOR version when you add functionality in a backwards-compatible manner. You increment PATCH version when you make backwards-compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. Along with the release version, you might also use pre-release versions by adding a prerelease tag. The resulting format of the pre-release version is as follows: MAJOR.MINOR.PATCH-<alpha | beta | rc When it comes to module pre-release tags, we generally follow the recognized naming conventions: Alpha: Alpha release, typically used for work-in-progress and experiments Beta: Beta release, typically one that is feature complete for the next planned release, but may contain some known bugs RC: Release candidate, typically a release that is potentially final (stable), unless significant bugs emerge. Each Virto module has a version both as a project assembly version and the one contained in the module.manifest file. Thus, to change the version, you will have to change both the assembly version manually in Directory.Build.Props (going forward, it will be automatically calculated from current Git branches and tags tanks in the GitVersion utility) and the module version is the module.manifest file. A module can depend on other modules and cannot function without the modules it depends on; along with this, each module has a dependency to a specific platform version. All module and platform dependencies must be described in the module.manifest file, namely, in the dependencies section: module.manifest 1 <?xml versio n = \"1.0\" e n codi n g= \"utf-8\" ?> 2 <module> 3 <id>Vir t oCommerce.Ca tal og</id> 4 <versio n > 3.3.0 </versio n > 5 <pla tf ormVersio n > 3.0.0 </pla tf ormVersio n > 6 <depe n de n cies> 7 <depe n de n cy id= \"VirtoCommerce.Core\" versio n = \"3.0.0\" /> 8 <depe n de n cy id= \"VirtoCommerce.BulkActionsModule\" versio n = \"3.0.0\" /> 9 </depe n de n cies> 10 ... The Virto dependency version resolving logic always interprets all versions as ^major.minor.path (Next Significant Release Caret Version Range operator), and it will always allow non-breaking updates. This is the best explained by the following example: Note ^1.2.3 is equivalent to >=1.2.3 <2.0.0 as none of the releases until 2.0 should break backwards compatibility.","title":"Module Versioning and Dependencies"},{"location":"Fundamentals/Modularity/03-versioning-and-dependencies/#managing-third-party-dependencies-for-modules","text":"As all module assemblies are copied into the probing folder before being loaded into the platform application process, except the assemblies of the module in question, the platform module manager copies all third party dependency assemblies and applies the same version conflict resolution policy: Note The assembly with the highest version or the one that was modified last, wins. This fact may lead to an unexpected update of third party dependencies for other modules and the platform application itself when resolving an assembly at runtime. You should always consider this fact when updating dependencies for your custom modules.","title":"Managing Third Party Dependencies for Modules"},{"location":"Fundamentals/Modularity/04-loading-modules-into-app-process/","text":"How Platform Loads Modules into Application Process The process of loading modules into the Virto platform application process includes the following steps: Discovering or registering modules: The modules to load at the first run in runtime are defined in the discovery folder called ~/modules . This folder contains the module folder tree, with each module folder containing the module.manifest file and other module resources, such as assemblies, JavaScript files, style bundles, and localization resources. Copying module assemblies into the probing folder to apply the version conflict resolution. Note The current policy is as follows: the assembly with the latest version or latest date of modification always prevails when copying. Copying assemblies into the probing folder prevents assembly lock issues that might happen when the same assemblies loaded into the application process at the same time can be modified during development or other activity. In multi-instance platform configurations, only one instance checks or copies assemblies into the probing folder. This is achieved by distributed locking between instances through Redis: the instance that was started first copies the files, while other instances skip this process. Loading modules: The assemblies that contain the modules are loaded into the AssemblyLoadContex.Default default context of the application process. This phase requires the module assemblies to be retrieved from the probing folder. Ordering by dependency graph: All loaded modules are stored in the order of their dependencies for proper initialization order. Initializing modules: Finally, the modules get initialized, which means creating instances of the module class and calling the Initialize method against them via the IModule interface. The chart below shows the module loading process: Note The Virto platform's modularity engine supports only eager loading from local disk for modules.","title":"Loading Modules into App Process"},{"location":"Fundamentals/Modularity/04-loading-modules-into-app-process/#how-platform-loads-modules-into-application-process","text":"The process of loading modules into the Virto platform application process includes the following steps: Discovering or registering modules: The modules to load at the first run in runtime are defined in the discovery folder called ~/modules . This folder contains the module folder tree, with each module folder containing the module.manifest file and other module resources, such as assemblies, JavaScript files, style bundles, and localization resources. Copying module assemblies into the probing folder to apply the version conflict resolution. Note The current policy is as follows: the assembly with the latest version or latest date of modification always prevails when copying. Copying assemblies into the probing folder prevents assembly lock issues that might happen when the same assemblies loaded into the application process at the same time can be modified during development or other activity. In multi-instance platform configurations, only one instance checks or copies assemblies into the probing folder. This is achieved by distributed locking between instances through Redis: the instance that was started first copies the files, while other instances skip this process. Loading modules: The assemblies that contain the modules are loaded into the AssemblyLoadContex.Default default context of the application process. This phase requires the module assemblies to be retrieved from the probing folder. Ordering by dependency graph: All loaded modules are stored in the order of their dependencies for proper initialization order. Initializing modules: Finally, the modules get initialized, which means creating instances of the module class and calling the Initialize method against them via the IModule interface. The chart below shows the module loading process: Note The Virto platform's modularity engine supports only eager loading from local disk for modules.","title":"How Platform Loads Modules into Application Process"},{"location":"Fundamentals/Modularity/05-best-practices/","text":"Best Practices Identifying Domain Model Boundaries for Each Module and Best Number of Modules for Custom Solution When it comes to identifying model boundaries and size for each module, the goal is not to get to the most granular separation possible, although you should tend towards having smaller modules, when possible. Instead, however, your goal is to get to the most meaningful separation guided by your domain knowledge. The emphasis is not on the size but on business capabilities. In addition, if you need cohesion for a certain area of the application based on a high number of dependencies, this means you need a single module, too. Cohesion is a way to identify how to break modules apart or group them together. Ultimately, while you gain more knowledge about the domain, you should adapt the size of your module, iteratively. Warning A Virto module basically represents a unit for compilation and distribution of functionality, which means it has exactly one deployment unit. Please do not consider any module as a single possible way of separation of domains and business logic. You might organize a well designed multiple domain architecture within a single module. A large number of modules that have many dependencies and are closely coupled together might significantly affect the development team productivity, deployment, and the maintenance processes due to dependency hell and cascade releases. Implementing your entire custom solution into a single module will be a good choice if your project satisfies all of the below requirements: You have a single development team and single code review and release flow (same dev life cycle). Most of your business logic is based on the core Virto modules and simply extends them. You do not have any strict scale requirement that causes your solution to run some modules independently as standalone services. One can draw parallels between how your code can spread among Virto modules and how the same code can be arranged in poly or mono repositories. For those who want to learn more, this article explains the advantages of a mono repository without giving away the benefits of poly repositories, while this one will tell you about the Modular Monolith architecture.","title":"Best Practices"},{"location":"Fundamentals/Modularity/05-best-practices/#best-practices","text":"","title":"Best Practices"},{"location":"Fundamentals/Modularity/05-best-practices/#identifying-domain-model-boundaries-for-each-module-and-best-number-of-modules-for-custom-solution","text":"When it comes to identifying model boundaries and size for each module, the goal is not to get to the most granular separation possible, although you should tend towards having smaller modules, when possible. Instead, however, your goal is to get to the most meaningful separation guided by your domain knowledge. The emphasis is not on the size but on business capabilities. In addition, if you need cohesion for a certain area of the application based on a high number of dependencies, this means you need a single module, too. Cohesion is a way to identify how to break modules apart or group them together. Ultimately, while you gain more knowledge about the domain, you should adapt the size of your module, iteratively. Warning A Virto module basically represents a unit for compilation and distribution of functionality, which means it has exactly one deployment unit. Please do not consider any module as a single possible way of separation of domains and business logic. You might organize a well designed multiple domain architecture within a single module. A large number of modules that have many dependencies and are closely coupled together might significantly affect the development team productivity, deployment, and the maintenance processes due to dependency hell and cascade releases. Implementing your entire custom solution into a single module will be a good choice if your project satisfies all of the below requirements: You have a single development team and single code review and release flow (same dev life cycle). Most of your business logic is based on the core Virto modules and simply extends them. You do not have any strict scale requirement that causes your solution to run some modules independently as standalone services. One can draw parallels between how your code can spread among Virto modules and how the same code can be arranged in poly or mono repositories. For those who want to learn more, this article explains the advantages of a mono repository without giving away the benefits of poly repositories, while this one will tell you about the Modular Monolith architecture.","title":"Identifying Domain Model Boundaries for Each Module and Best Number of Modules for Custom Solution"},{"location":"Fundamentals/Modularity/06-module-manifest-file/","text":"Module.manifest The module.manifest file is used both to build the module package and to provide information to the platform runtime when a module is loading . The manifest is always included into a module package. Module.manifest is an XML file containing a top-level node, which in its turn contains section elements described in the section below. Manifest File Example Below, you can find an example of a module.manifest file that illustrates a number of settings including optional ones: module.manifest <module xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd= \"http://www.w3.org/2001/XMLSchema\" > <!-- (Required) The case-insensitive module identifier, which must be unique across the set of modules module 6 resides in. IDs may not contain spaces or characters that are not valid for a URL,and generally follow .NET namespace rules. --> <id> VirtoCommerce.Cart </id> <!-- (Required) The version of the package following the major.minor.patch pattern. --> <version> 3.27.0 </version> <!-- (Optional) Version numbers may include a pre-release suffix. --> <version-tag> beta001 </version-tag> <!-- (Required) The minimum platform version the current module is compatible with. --> <platformVersion> 3.62.0 </platformVersion> <!-- (Optional) A human-friendly title and description of the module, which may be used in the Platform Manager UI. --> <title> Shopping cart module </title> <description> Shopping cart / checkout functionality </description> <authors> <author> Virto Commerce </author> </authors> <owners> <owner> Virto Commerce </owner> </owners> <!-- (Optional) A URL for the package home page displayed by the Platform Manager UI. --> <projectUrl> https://virtocommerce.com/apps/extensions/virto-shoppingcart-module </projectUrl> <!-- (Optional) A path to an image file shown in the Platform Manager UI as a module icon. This can be either a path to an image file within the module that is located in the Content folder or a URL to an external image. --> <iconUrl> Modules/$(VirtoCommerce.Cart)/Content/logo.png </iconUrl> <!-- (Required) This value is used to specify the name of the assembly, which the module type is loaded from. --> <assemblyFile> VirtoCommerce.CartModule.Web.dll </assemblyFile> <!-- (Required) A fully qualified name of the type, including its namespace with a class that implements the IModule interface. The module loader creates an instance of the module class, and then it calls the Initialize method. <moduleType>VirtoCommerce.CartModule.Web.Module, VirtoCommerce.CartModule.Web</moduleType> <!-- (Optional) Contains any number of <dependency> elements that identify other modules this module depends upon. --> <dependencies> <dependency id= \"VirtoCommerce.Core\" version= \"3.22.0\" /> </dependencies> </module>","title":"Module.manifest File"},{"location":"Fundamentals/Modularity/06-module-manifest-file/#modulemanifest","text":"The module.manifest file is used both to build the module package and to provide information to the platform runtime when a module is loading . The manifest is always included into a module package. Module.manifest is an XML file containing a top-level node, which in its turn contains section elements described in the section below.","title":"Module.manifest"},{"location":"Fundamentals/Modularity/06-module-manifest-file/#manifest-file-example","text":"Below, you can find an example of a module.manifest file that illustrates a number of settings including optional ones: module.manifest <module xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd= \"http://www.w3.org/2001/XMLSchema\" > <!-- (Required) The case-insensitive module identifier, which must be unique across the set of modules module 6 resides in. IDs may not contain spaces or characters that are not valid for a URL,and generally follow .NET namespace rules. --> <id> VirtoCommerce.Cart </id> <!-- (Required) The version of the package following the major.minor.patch pattern. --> <version> 3.27.0 </version> <!-- (Optional) Version numbers may include a pre-release suffix. --> <version-tag> beta001 </version-tag> <!-- (Required) The minimum platform version the current module is compatible with. --> <platformVersion> 3.62.0 </platformVersion> <!-- (Optional) A human-friendly title and description of the module, which may be used in the Platform Manager UI. --> <title> Shopping cart module </title> <description> Shopping cart / checkout functionality </description> <authors> <author> Virto Commerce </author> </authors> <owners> <owner> Virto Commerce </owner> </owners> <!-- (Optional) A URL for the package home page displayed by the Platform Manager UI. --> <projectUrl> https://virtocommerce.com/apps/extensions/virto-shoppingcart-module </projectUrl> <!-- (Optional) A path to an image file shown in the Platform Manager UI as a module icon. This can be either a path to an image file within the module that is located in the Content folder or a URL to an external image. --> <iconUrl> Modules/$(VirtoCommerce.Cart)/Content/logo.png </iconUrl> <!-- (Required) This value is used to specify the name of the assembly, which the module type is loaded from. --> <assemblyFile> VirtoCommerce.CartModule.Web.dll </assemblyFile> <!-- (Required) A fully qualified name of the type, including its namespace with a class that implements the IModule interface. The module loader creates an instance of the module class, and then it calls the Initialize method. <moduleType>VirtoCommerce.CartModule.Web.Module, VirtoCommerce.CartModule.Web</moduleType> <!-- (Optional) Contains any number of <dependency> elements that identify other modules this module depends upon. --> <dependencies> <dependency id= \"VirtoCommerce.Core\" version= \"3.22.0\" /> </dependencies> </module>","title":"Manifest File Example"},{"location":"Fundamentals/Security/extending-authorization-policies/","text":"Virto Commerce supports extendng the existing authorization policies that are defined and checked in the API controllers and other locations. This article will tell you how to use various techniques to extend the authorization policy type without direct code modification. Click here to view or download our sample code. Extending Existing Authorization Policies Let's assume we have the below authorization checks in the Order Module . Additionally, we want to extend the default OrderAuthorizationHandler that is associated with the OrderAuthorizationRequirement requirement called during the authorization check with a new policy limiting the resulting orders by their statuses. The purpose is to create a role that enables specific users to see orders only with specific status(es). You can read more about how authorization policies work here . OrderModuleController.cs [HttpPost] [Route(\"api/order/customerOrders/search\")] public async Task < ActionResult < CustomerOrderSearchResult >> SearchCustomerOrder ([ FromBody ] CustomerOrderSearchCriteria criteria ) { var authorizationResult = await _authorizationService . AuthorizeAsync ( User , criteria , new OrderAuthorizationRequirement ( ModuleConstants . Security . Permissions . Read )); if (! authorizationResult . Succeeded ) { return Unauthorized (); } } In order to enable this extension, you need to define a new CustomOrderAuthorizationHandler class and use the same OrderAuthorizationRequirement requirement, as it is used in the original controller method for authorization check. CustomOrderAuthorizationHandler.cs public sealed class CustomOrderAuthorizationHandler : PermissionAuthorizationHandlerBase < OrderAuthorizationRequirement > { //Code skipped for better clarity } The next step is registering your handler in the DI to tell ASP.NET Authorization to call your handler along with others associated with the OrderAuthorizationRequirement requirement: Module.cs public class Module : IModule { public void Initialize ( IServiceCollection serviceCollection ) { //Rest of code skipped for better clarity serviceCollection . AddTransient < IAuthorizationHandler , CustomOrderAuthorizationHandler >(); } } After this point, the custom CustomOrderAuthorizationHandler along with other registered handlers will be executed each time when OrderAuthorizationRequirement is checked by this call: IAuthorizationService . AuthorizeAsync ( User , data , new OrderAuthorizationRequirement ()); Additional Resources You can also check out how to handle secure Web API here .","title":"Extending Authorizarion Policies"},{"location":"Fundamentals/Security/extending-authorization-policies/#extending-existing-authorization-policies","text":"Let's assume we have the below authorization checks in the Order Module . Additionally, we want to extend the default OrderAuthorizationHandler that is associated with the OrderAuthorizationRequirement requirement called during the authorization check with a new policy limiting the resulting orders by their statuses. The purpose is to create a role that enables specific users to see orders only with specific status(es). You can read more about how authorization policies work here . OrderModuleController.cs [HttpPost] [Route(\"api/order/customerOrders/search\")] public async Task < ActionResult < CustomerOrderSearchResult >> SearchCustomerOrder ([ FromBody ] CustomerOrderSearchCriteria criteria ) { var authorizationResult = await _authorizationService . AuthorizeAsync ( User , criteria , new OrderAuthorizationRequirement ( ModuleConstants . Security . Permissions . Read )); if (! authorizationResult . Succeeded ) { return Unauthorized (); } } In order to enable this extension, you need to define a new CustomOrderAuthorizationHandler class and use the same OrderAuthorizationRequirement requirement, as it is used in the original controller method for authorization check. CustomOrderAuthorizationHandler.cs public sealed class CustomOrderAuthorizationHandler : PermissionAuthorizationHandlerBase < OrderAuthorizationRequirement > { //Code skipped for better clarity } The next step is registering your handler in the DI to tell ASP.NET Authorization to call your handler along with others associated with the OrderAuthorizationRequirement requirement: Module.cs public class Module : IModule { public void Initialize ( IServiceCollection serviceCollection ) { //Rest of code skipped for better clarity serviceCollection . AddTransient < IAuthorizationHandler , CustomOrderAuthorizationHandler >(); } } After this point, the custom CustomOrderAuthorizationHandler along with other registered handlers will be executed each time when OrderAuthorizationRequirement is checked by this call: IAuthorizationService . AuthorizeAsync ( User , data , new OrderAuthorizationRequirement ());","title":"Extending Existing Authorization Policies"},{"location":"Fundamentals/Security/extending-authorization-policies/#additional-resources","text":"You can also check out how to handle secure Web API here .","title":"Additional Resources"},{"location":"Getting-Started/","text":"Getting Started Just starting out with Virto? This section will tell you how to get started correctly. In particular, you will be able to check the minimum requirements for installing the Virto Commerce solution, and to learn how to install it. What this section contains: System Requirements Installation Guide Post Installation Steps Looking for something else? Go back to Start page","title":"Getting Started"},{"location":"Getting-Started/#getting-started","text":"Just starting out with Virto? This section will tell you how to get started correctly. In particular, you will be able to check the minimum requirements for installing the Virto Commerce solution, and to learn how to install it. What this section contains: System Requirements Installation Guide Post Installation Steps Looking for something else? Go back to Start page","title":"Getting Started"},{"location":"Getting-Started/system-requirements-in-progress/","text":"System Requirements This guide will explain you the basic hardware and software requirements to installing the Virto Commerce platform. Minimum Hardware Requirements Before installing the Virto platform, make sure the computer you are going to install it on satisfies these minimum requirements: Parameter Value RAM 1GB Disk space 1GB Processor speed 2GHz Number of cores Dual core Processor type x64-compatible only Supported Operation Systems for .NET 6 The Virto platform runs on .NET 6, which supports installation on Windows and Linux. For the Windows family, the requirements are as follows: Version Subversion Type Windows 11 21H2 x64, Arm64 Windows 10 Client 1607+ x64, x86, Arm64 Windows Client 7 SP1+, 8.1 x64, x86 Windows Server 2012+ x64, x86 Windows Server Core 2012+ x64, x86 Nano Server 1809+ x64 Supported Databases The Virto platform supports MS SQL Server 2017 and above. Supported Browsers The Virto platform supports the following browsers: Microsoft Internet Explorer 9 and above Note Virto Commerce previously supported IE6 and IE7 in versions prior to 3.60, while IE8 was supported in versions prior to 4.10. Mozilla Firefox 2.0 and above Google Chrome 1.x Apple Safari 2.x","title":"System Requirements"},{"location":"Getting-Started/system-requirements-in-progress/#system-requirements","text":"This guide will explain you the basic hardware and software requirements to installing the Virto Commerce platform.","title":"System Requirements"},{"location":"Getting-Started/system-requirements-in-progress/#minimum-hardware-requirements","text":"Before installing the Virto platform, make sure the computer you are going to install it on satisfies these minimum requirements: Parameter Value RAM 1GB Disk space 1GB Processor speed 2GHz Number of cores Dual core Processor type x64-compatible only","title":"Minimum Hardware Requirements"},{"location":"Getting-Started/system-requirements-in-progress/#supported-operation-systems-for-net-6","text":"The Virto platform runs on .NET 6, which supports installation on Windows and Linux. For the Windows family, the requirements are as follows: Version Subversion Type Windows 11 21H2 x64, Arm64 Windows 10 Client 1607+ x64, x86, Arm64 Windows Client 7 SP1+, 8.1 x64, x86 Windows Server 2012+ x64, x86 Windows Server Core 2012+ x64, x86 Nano Server 1809+ x64","title":"Supported Operation Systems for .NET 6"},{"location":"Getting-Started/system-requirements-in-progress/#supported-databases","text":"The Virto platform supports MS SQL Server 2017 and above.","title":"Supported Databases"},{"location":"Getting-Started/system-requirements-in-progress/#supported-browsers","text":"The Virto platform supports the following browsers: Microsoft Internet Explorer 9 and above Note Virto Commerce previously supported IE6 and IE7 in versions prior to 3.60, while IE8 was supported in versions prior to 4.10. Mozilla Firefox 2.0 and above Google Chrome 1.x Apple Safari 2.x","title":"Supported Browsers"},{"location":"Getting-Started/Installation-Guide/index-dummy/","text":"Installation Guide This is a dummy file.","title":"Installation Guide"},{"location":"Getting-Started/Installation-Guide/index-dummy/#installation-guide","text":"This is a dummy file.","title":"Installation Guide"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/01-installation-windows-on-premises-prerequisites/","text":"Prerequisites In order to run Virto Commerce, you will first need to install the below prerequisites. Required Software Components This components must be installed in your Windows environment before running the Virto Commerce platform: ASP.NET Core Runtime 6.0.2 MS SQL Server 2017 or above Note After installing MS SQL server, please switch its authentication to mixed mode, as described here . Virto Commerce CLI , our proprietary command line interface that enables automating the installation process and updating the dependencies. Optional software components For VirtoCommerce 3.200 or above, we recommend you installing MS Visual Studio 2022 (version 17.0 or above). You might also want to install .NET 6 SDK in case you will need to edit the source code. For better search capabilities, you can install Elastic search 7.15 . By default, VirtoCommerce uses Lucene .NET ; however, it has very limited functionality and cannot be used in production.","title":"Prerequisites"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/01-installation-windows-on-premises-prerequisites/#prerequisites","text":"In order to run Virto Commerce, you will first need to install the below prerequisites.","title":"Prerequisites"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/01-installation-windows-on-premises-prerequisites/#required-software-components","text":"This components must be installed in your Windows environment before running the Virto Commerce platform: ASP.NET Core Runtime 6.0.2 MS SQL Server 2017 or above Note After installing MS SQL server, please switch its authentication to mixed mode, as described here . Virto Commerce CLI , our proprietary command line interface that enables automating the installation process and updating the dependencies.","title":"Required Software Components"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/01-installation-windows-on-premises-prerequisites/#optional-software-components","text":"For VirtoCommerce 3.200 or above, we recommend you installing MS Visual Studio 2022 (version 17.0 or above). You might also want to install .NET 6 SDK in case you will need to edit the source code. For better search capabilities, you can install Elastic search 7.15 . By default, VirtoCommerce uses Lucene .NET ; however, it has very limited functionality and cannot be used in production.","title":"Optional software components"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/02-installation-windows-on-premises-precompiled-binaries/","text":"Manual Installation with Precompiled Binaries This section explains how to install Virto Commerce on a Windows based PC. Downloading Precompiled Platform Version To download the precompiled files, navigate to the Releases section of our public GitHub repository. Locate the VirtoCommerce.Platform.3.x.x.zip archive, which already has the website built and can be run without any additional compilation. The source code, however, is not included. Unpack the zipped archive to a local directory, e.g., C:\\vc-platform-3 . That's it, you've got a directory with the precompiled platform files. Updating Settings File Once you have downloaded and unpacked the files, you will need to adjust the settings. Open the appsettings.json file in your text editor and change the VirtoCommerce string in the ConnectionStrings section. Warning The provided user must have enough permissions to create a new database. ConnectionStrings Section Example 1 \"ConnectionStrings\" : { 2 \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" 3 }, This is how the string in question may look like after you change it: appsettings.json ` \"VirtoCommerce\" : \"Data Source=(local);Initial Catalog=VirtoCommerce3;Persist Security Info=True;User ID=virto;Password=virto;Connect Timeout=30\" , ` Installing Self Signed SSL Certificate Another step before launching the platform is installing and trusting the HTTPS certificate. In order to trust the certificate, run this command: dotnet dev-certs https --trust For more information, please refer to this Microsoft article . Launching Platform In order to launch the platform, run this command: dotnet VirtoCommerce.Platform.Web.dll Note *The command above will run the Platform enforcing the HTTPS schema. You can also add HTTP URLs in the --urls argument of the dotnet command for development or demo purposes (see below). For security reasons, however, you should never use it in the production mode. dotnet VirtoCommerce.Platform.Web.dll --urls=http://localhost:5000 First Time Launch To launch the platform for the first time, open your browser and type http://localhost:5000 or https://localhost:5001 . You may get the Your connection is not private error; in this case, click Advanced and then Proceed to... : You can also remove this error using a self signed certificate . The application will then create and initialize the database. After that, you should see the sign in page. Supply admin for login and store for password. After you log into the platform for the first time, the installation wizard will show up and download default modules and sample data: Once the wizard is done installing, you will be prompted to reset the default credentials: This is it! Your platform is good to go.","title":"Installing with Precompiled Binaries"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/02-installation-windows-on-premises-precompiled-binaries/#manual-installation-with-precompiled-binaries","text":"This section explains how to install Virto Commerce on a Windows based PC.","title":"Manual Installation with Precompiled Binaries"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/02-installation-windows-on-premises-precompiled-binaries/#downloading-precompiled-platform-version","text":"To download the precompiled files, navigate to the Releases section of our public GitHub repository. Locate the VirtoCommerce.Platform.3.x.x.zip archive, which already has the website built and can be run without any additional compilation. The source code, however, is not included. Unpack the zipped archive to a local directory, e.g., C:\\vc-platform-3 . That's it, you've got a directory with the precompiled platform files.","title":"Downloading Precompiled Platform Version"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/02-installation-windows-on-premises-precompiled-binaries/#updating-settings-file","text":"Once you have downloaded and unpacked the files, you will need to adjust the settings. Open the appsettings.json file in your text editor and change the VirtoCommerce string in the ConnectionStrings section. Warning The provided user must have enough permissions to create a new database. ConnectionStrings Section Example 1 \"ConnectionStrings\" : { 2 \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" 3 }, This is how the string in question may look like after you change it: appsettings.json ` \"VirtoCommerce\" : \"Data Source=(local);Initial Catalog=VirtoCommerce3;Persist Security Info=True;User ID=virto;Password=virto;Connect Timeout=30\" , `","title":"Updating Settings File"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/02-installation-windows-on-premises-precompiled-binaries/#installing-self-signed-ssl-certificate","text":"Another step before launching the platform is installing and trusting the HTTPS certificate. In order to trust the certificate, run this command: dotnet dev-certs https --trust For more information, please refer to this Microsoft article .","title":"Installing Self Signed SSL Certificate"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/02-installation-windows-on-premises-precompiled-binaries/#launching-platform","text":"In order to launch the platform, run this command: dotnet VirtoCommerce.Platform.Web.dll Note *The command above will run the Platform enforcing the HTTPS schema. You can also add HTTP URLs in the --urls argument of the dotnet command for development or demo purposes (see below). For security reasons, however, you should never use it in the production mode. dotnet VirtoCommerce.Platform.Web.dll --urls=http://localhost:5000","title":"Launching Platform"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/02-installation-windows-on-premises-precompiled-binaries/#first-time-launch","text":"To launch the platform for the first time, open your browser and type http://localhost:5000 or https://localhost:5001 . You may get the Your connection is not private error; in this case, click Advanced and then Proceed to... : You can also remove this error using a self signed certificate . The application will then create and initialize the database. After that, you should see the sign in page. Supply admin for login and store for password. After you log into the platform for the first time, the installation wizard will show up and download default modules and sample data: Once the wizard is done installing, you will be prompted to reset the default credentials: This is it! Your platform is good to go.","title":"First Time Launch"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/","text":"Installation Using Virto Commerce CLI This guide will explain you how to install VirtCommerce in demo mode on Windows using Virto Commerce's proprietary command line interface (CLI). Virto Commerce Global Tool CLI, or vc-build , is our official .NET Core GlobalTool that helps you build, test, and deploy releases, create and push NuGet packages, provide package management for projects based on VirtoCommerce, and automate common DevOps tasks. Installation Process In order to install the Virto Commerce platform using CLI, do the following: Install vc-build by running this command: 1dotnet tool install -g VirtoCommerce.GlobalTool Create an empty folder on your local disk to house the platform files. For instance, if you want to install it to your C drive, type: 1cd c:\\vc-platform Run the following command to install both platform and modules with the latest versions: 1vc-build install Once you are done, you will have the latest platform application release with the default module settings installed to your C:\\vc-platform folder. Tip You also can use vc-build for other operations, such as updating the existing Virto packages or installing new ones. You can find more information on this here . Post Installation Steps Once you have install the platform, you will need to perform a few additional steps to get it up and running. These steps are described below. Adjusting SQL Connection Settings Open the appsettings.json file in your text editor and change the VirtoCommerce string in the ConnectionStrings section. Warning The provided user must have enough permissions to create a new database. ConnectionStrings Section Example \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" }, This is how the string in question may look like after you change it: appsettings.json ` \"VirtoCommerce\" : \"Data Source=(local);Initial Catalog=VirtoCommerce3;Persist Security Info=True;User ID=virto;Password=virto;Connect Timeout=30\" , ` Installing Self Signed SSL Certificate Another step before launching the platform is installing and trusting the HTTPS certificate. In order to trust the certificate, run this command: dotnet dev-certs https --trust For more information, please refer to this Microsoft article . Launching Platform In order to launch the platform, run this command: dotnet VirtoCommerce.Platform.Web.dll Note The command above will run the Platform enforcing the HTTPS schema. You can also add HTTP URLs in the --urls argument of the dotnet command for development or demo purposes (see below). For security reasons, however, you should never use it in the production mode. dotnet VirtoCommerce.Platform.Web.dll --urls=http://localhost:5000 First Time Launch To launch the platform for the first time, open your browser and type http://localhost:5000 or https://localhost:5001 . You may get the Your connection is not private error; in this case, click Advanced and then Proceed to... : You can also remove this error using a self signed certificate . The application will then create and initialize the database. After that, you should see the sign in page. Supply admin for login and store for password. After you log into the platform for the first time, the installation wizard will show up and download default modules and sample data: Once the wizard is done installing, you will be prompted to reset the default credentials: This is it! Your platform is good to go.","title":"Installing with CLI"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/#installation-using-virto-commerce-cli","text":"This guide will explain you how to install VirtCommerce in demo mode on Windows using Virto Commerce's proprietary command line interface (CLI). Virto Commerce Global Tool CLI, or vc-build , is our official .NET Core GlobalTool that helps you build, test, and deploy releases, create and push NuGet packages, provide package management for projects based on VirtoCommerce, and automate common DevOps tasks.","title":"Installation Using Virto Commerce CLI"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/#installation-process","text":"In order to install the Virto Commerce platform using CLI, do the following: Install vc-build by running this command: 1dotnet tool install -g VirtoCommerce.GlobalTool Create an empty folder on your local disk to house the platform files. For instance, if you want to install it to your C drive, type: 1cd c:\\vc-platform Run the following command to install both platform and modules with the latest versions: 1vc-build install Once you are done, you will have the latest platform application release with the default module settings installed to your C:\\vc-platform folder. Tip You also can use vc-build for other operations, such as updating the existing Virto packages or installing new ones. You can find more information on this here .","title":"Installation Process"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/#post-installation-steps","text":"Once you have install the platform, you will need to perform a few additional steps to get it up and running. These steps are described below.","title":"Post Installation Steps"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/#adjusting-sql-connection-settings","text":"Open the appsettings.json file in your text editor and change the VirtoCommerce string in the ConnectionStrings section. Warning The provided user must have enough permissions to create a new database. ConnectionStrings Section Example \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" }, This is how the string in question may look like after you change it: appsettings.json ` \"VirtoCommerce\" : \"Data Source=(local);Initial Catalog=VirtoCommerce3;Persist Security Info=True;User ID=virto;Password=virto;Connect Timeout=30\" , `","title":"Adjusting SQL Connection Settings"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/#installing-self-signed-ssl-certificate","text":"Another step before launching the platform is installing and trusting the HTTPS certificate. In order to trust the certificate, run this command: dotnet dev-certs https --trust For more information, please refer to this Microsoft article .","title":"Installing Self Signed SSL Certificate"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/#launching-platform","text":"In order to launch the platform, run this command: dotnet VirtoCommerce.Platform.Web.dll Note The command above will run the Platform enforcing the HTTPS schema. You can also add HTTP URLs in the --urls argument of the dotnet command for development or demo purposes (see below). For security reasons, however, you should never use it in the production mode. dotnet VirtoCommerce.Platform.Web.dll --urls=http://localhost:5000","title":"Launching Platform"},{"location":"Getting-Started/Installation-Guide/Installing-on-Windows/03-installation-windows-on-premises-CLI/#first-time-launch","text":"To launch the platform for the first time, open your browser and type http://localhost:5000 or https://localhost:5001 . You may get the Your connection is not private error; in this case, click Advanced and then Proceed to... : You can also remove this error using a self signed certificate . The application will then create and initialize the database. After that, you should see the sign in page. Supply admin for login and store for password. After you log into the platform for the first time, the installation wizard will show up and download default modules and sample data: Once the wizard is done installing, you will be prompted to reset the default credentials: This is it! Your platform is good to go.","title":"First Time Launch"},{"location":"Getting-Started/Post-Installation-Steps/01-setting-up-self-signed-ssl-cert/","text":"Setting up Self-signed SSL Certificate Running Virto Commerce Platform with HTTPS requires using an SSL certificate. When it comes to non-production applications or development and testing scenarios, you can use a self-signed certificate (see also sections Installing Self Signed SSL Certificate and First Time Launch of the Installation Guide ). Although such a certificate implements full encryption, the visitors of your website will see a browser warning saying the certificate should not be trusted. Thus, when you first launch the platform with HTTPS enabled at https://localhost:5001 , you may also get this warning: This is because it is an untrusted SSL certificate generated locally: In this case, you can use the dotnet dev-certs command to work with self-signed certificates. All you need to do is run the following: 1 dotnet dev-certs https --trust This will take you to a popup dialog asking whether you want to trust this localhost certificate: Click Yes , close your browser, and open it again at https://localhost:5001 . You will then see a trusted Secure badge in your browser (a lock icon): To learn more about self-signed certificates, refer to this Microsoft .NET guide .","title":"Setting Up Self Signed SSL Certificate"},{"location":"Getting-Started/Post-Installation-Steps/01-setting-up-self-signed-ssl-cert/#setting-up-self-signed-ssl-certificate","text":"Running Virto Commerce Platform with HTTPS requires using an SSL certificate. When it comes to non-production applications or development and testing scenarios, you can use a self-signed certificate (see also sections Installing Self Signed SSL Certificate and First Time Launch of the Installation Guide ). Although such a certificate implements full encryption, the visitors of your website will see a browser warning saying the certificate should not be trusted. Thus, when you first launch the platform with HTTPS enabled at https://localhost:5001 , you may also get this warning: This is because it is an untrusted SSL certificate generated locally: In this case, you can use the dotnet dev-certs command to work with self-signed certificates. All you need to do is run the following: 1 dotnet dev-certs https --trust This will take you to a popup dialog asking whether you want to trust this localhost certificate: Click Yes , close your browser, and open it again at https://localhost:5001 . You will then see a trusted Secure badge in your browser (a lock icon): To learn more about self-signed certificates, refer to this Microsoft .NET guide .","title":"Setting up Self-signed SSL Certificate"},{"location":"Getting-Started/Post-Installation-Steps/02-configuring-email-notifications/","text":"Configuring Email Notifications Virto Commerce Platform enables sending email notifications for various system events, such as restoring passwords, customer order processing, etc. In order to send such notifications, you will need to use a third-party email service provider that will handle email delivery. All you have to do is set up an mail gateway so that the platform may start sending emails. Currently, the only two options for gateways available are SMTP and SendGrid (see below for details). Prerequisites In order to enable sending and receiving notifications, you must have the Notification module installed. Configuring SMTP Email Settings This is how you can work with the SMTP settings with Gmail.com provider as an example. To enable sending notifications through Gmail, turn on the Allow less secure apps option in Google Security Settings . Then, edit the Notifications section in the appsettings.json file: appsettings.json 1 ... 2 \"Notifications\" : { 3 \"Gateway\" : \"Smtp\" , 4 \"DefaultSender\" : \"noreply@gmail.com\" , //the default sender address 5 \"Smtp\" : { 6 \"SmtpServer\" : \"http://smtp.gmail.com\" , 7 \"Port\" : 587 , //TLS port 8 \"Login\" : \"\" , //Your full Gmail address (e.g. you@gmail.com) 9 \"Password\" : \"\" //The password that you use to log in to Gmail 10 }, 11 }, 12 .... Warning After making any changes to the appsettings.json file, be sure to restart the application for those changes to apply. Configuring SendGrid Email Settings In order to work with the SendGrid settings, you must have a SendGrid account. To learn how to set up one, as well as other relevant details, refer to this SendGrid article . Once your account is up and running, edit the Notifications section in the appsettings.json file: appsettings.json 1 ... 2 \"Notifications\" : { 3 \"Gateway\" : \"SendGrid\" , 4 \"DefaultSender\" : \"noreply@gmail.com\" , //the default sender address 5 \"SendGrid\" : { 6 \"ApiKey\" : \"your API key\" , //SendGrid API key 7 }, 8 }, 9.... Testing Notification Sending Process To test your notifications, you will need to use REST Admin API queries that require a valid Shopify access token. To test whether an email has been sent successfully, run this query: curl -X POST \"https://localhost:5001/api/notifications/send\" -H \"accept: text/plain\" -H \"Authorization: Bearer {access_token}\" -H \"Content-Type: application/json-patch+json\" -d '{\"type\":\"RemindUserNameEmailNotification\",\"from\":\"no-reply@mail.com\",\"to\":\"{your email}\"}'' In case of success, you will receive an test email on your email account. Otherwise, go to Notifications \u2192 Notification activity feed to see which error(s) led to a failure:","title":"Configuring Email Notifications"},{"location":"Getting-Started/Post-Installation-Steps/02-configuring-email-notifications/#configuring-email-notifications","text":"Virto Commerce Platform enables sending email notifications for various system events, such as restoring passwords, customer order processing, etc. In order to send such notifications, you will need to use a third-party email service provider that will handle email delivery. All you have to do is set up an mail gateway so that the platform may start sending emails. Currently, the only two options for gateways available are SMTP and SendGrid (see below for details).","title":"Configuring Email Notifications"},{"location":"Getting-Started/Post-Installation-Steps/02-configuring-email-notifications/#prerequisites","text":"In order to enable sending and receiving notifications, you must have the Notification module installed.","title":"Prerequisites"},{"location":"Getting-Started/Post-Installation-Steps/02-configuring-email-notifications/#configuring-smtp-email-settings","text":"This is how you can work with the SMTP settings with Gmail.com provider as an example. To enable sending notifications through Gmail, turn on the Allow less secure apps option in Google Security Settings . Then, edit the Notifications section in the appsettings.json file: appsettings.json 1 ... 2 \"Notifications\" : { 3 \"Gateway\" : \"Smtp\" , 4 \"DefaultSender\" : \"noreply@gmail.com\" , //the default sender address 5 \"Smtp\" : { 6 \"SmtpServer\" : \"http://smtp.gmail.com\" , 7 \"Port\" : 587 , //TLS port 8 \"Login\" : \"\" , //Your full Gmail address (e.g. you@gmail.com) 9 \"Password\" : \"\" //The password that you use to log in to Gmail 10 }, 11 }, 12 .... Warning After making any changes to the appsettings.json file, be sure to restart the application for those changes to apply.","title":"Configuring SMTP Email Settings"},{"location":"Getting-Started/Post-Installation-Steps/02-configuring-email-notifications/#configuring-sendgrid-email-settings","text":"In order to work with the SendGrid settings, you must have a SendGrid account. To learn how to set up one, as well as other relevant details, refer to this SendGrid article . Once your account is up and running, edit the Notifications section in the appsettings.json file: appsettings.json 1 ... 2 \"Notifications\" : { 3 \"Gateway\" : \"SendGrid\" , 4 \"DefaultSender\" : \"noreply@gmail.com\" , //the default sender address 5 \"SendGrid\" : { 6 \"ApiKey\" : \"your API key\" , //SendGrid API key 7 }, 8 }, 9....","title":"Configuring SendGrid Email Settings"},{"location":"Getting-Started/Post-Installation-Steps/02-configuring-email-notifications/#testing-notification-sending-process","text":"To test your notifications, you will need to use REST Admin API queries that require a valid Shopify access token. To test whether an email has been sent successfully, run this query: curl -X POST \"https://localhost:5001/api/notifications/send\" -H \"accept: text/plain\" -H \"Authorization: Bearer {access_token}\" -H \"Content-Type: application/json-patch+json\" -d '{\"type\":\"RemindUserNameEmailNotification\",\"from\":\"no-reply@mail.com\",\"to\":\"{your email}\"}'' In case of success, you will receive an test email on your email account. Otherwise, go to Notifications \u2192 Notification activity feed to see which error(s) led to a failure:","title":"Testing Notification Sending Process"},{"location":"Getting-Started/Post-Installation-Steps/03-configuring-asset-blob-storage/","text":"Configuring Asset Blob Storage This guide will explain you how to configure Asset blob storage, an abstraction that works as a single point of access to all media files in your online store. Such files could be product images or attachments, PDF specs, etc., regardless of their location or protocol. By default, the platform allows you to configure one of the following blob storage providers: FileSystem AzureBlobStorage Setting Up FileSystem Asset Storage in Development Mode This provider uses the local file system to store and provide public access to all media files. This mode implements Static files in ASP.NET Core , with all files are stored within the app local directory. The FileSystem storage provides public access to the files via relative URIs. To switch platform to using this provider, you need to edit the Assets section of the appsetting.json file so that it may look like this: appsetting.json 1 \"Assets\" : { 2 \"Provider\" : \"FileSystem\" , 3 \"FileSystem\" : { 4 \"RootPath\" : \"~/assets\" , 5 \"PublicUrl\" : \"https://localhost:5001/assets/\" 6 } 7 }, Note Line 2: Specify FileSystem as your default asset provider. Line 4: For RootPath , provide the base path to the wwwroot directory inside app folder. *Line 5: Provide the base URL that will be used when generating a public URI ASP.NET Core app serves directly. Make sure both host and port are up-to-date and valid for your platform instance. Example Let's assume you have an image file named MyImage.jpg that is stored at wwwroot/assets/MyImage.jpg . This file will be accessible through https://localhost:5001/assets/MyImage.jpg (a public URI), since ASP.NET marks all files in wwwroot as servable. Note This mode is good for local development purposes and not recommended for production because it lacks scalability. Setting up Azure Blob Storage in Production Mode Before setting up Azure blob storage, you will first need to create one. This quick start guide by Microsoft will explain you how. Once your blob storage has been created, open appsettings.json and add the connection string under the Assets section. As a result, the Assets section should look like this: appsetting.json 1 \"Assets\" : { 2 \"Provider\" : \"AzureBlobStorage\" , 3 \"AzureBlobStorage\" : { 4 \"ConnectionString\" : \"DefaultEndpointsProtocol=https;AccountName=<media account name>;AccountKey=<media account key>;EndpointSuffix=core.windows.net\" 5 } 6 }, Note Line 2: Specify AzureBlobStorage as your default asset provider. Line 4: In ConnectionString , provide the connection string of your storage account. Tip You can get your connection string from your Azure Portal under the Access Keys section. Note This mode is recommended for using in production environment since it enables sharing the asset storage across multiple platform instances.","title":"Configuring Asset Blob Storage"},{"location":"Getting-Started/Post-Installation-Steps/03-configuring-asset-blob-storage/#configuring-asset-blob-storage","text":"This guide will explain you how to configure Asset blob storage, an abstraction that works as a single point of access to all media files in your online store. Such files could be product images or attachments, PDF specs, etc., regardless of their location or protocol. By default, the platform allows you to configure one of the following blob storage providers: FileSystem AzureBlobStorage","title":"Configuring Asset Blob Storage"},{"location":"Getting-Started/Post-Installation-Steps/03-configuring-asset-blob-storage/#setting-up-filesystem-asset-storage-in-development-mode","text":"This provider uses the local file system to store and provide public access to all media files. This mode implements Static files in ASP.NET Core , with all files are stored within the app local directory. The FileSystem storage provides public access to the files via relative URIs. To switch platform to using this provider, you need to edit the Assets section of the appsetting.json file so that it may look like this: appsetting.json 1 \"Assets\" : { 2 \"Provider\" : \"FileSystem\" , 3 \"FileSystem\" : { 4 \"RootPath\" : \"~/assets\" , 5 \"PublicUrl\" : \"https://localhost:5001/assets/\" 6 } 7 }, Note Line 2: Specify FileSystem as your default asset provider. Line 4: For RootPath , provide the base path to the wwwroot directory inside app folder. *Line 5: Provide the base URL that will be used when generating a public URI ASP.NET Core app serves directly. Make sure both host and port are up-to-date and valid for your platform instance.","title":"Setting Up FileSystem Asset Storage in Development Mode"},{"location":"Getting-Started/Post-Installation-Steps/03-configuring-asset-blob-storage/#example","text":"Let's assume you have an image file named MyImage.jpg that is stored at wwwroot/assets/MyImage.jpg . This file will be accessible through https://localhost:5001/assets/MyImage.jpg (a public URI), since ASP.NET marks all files in wwwroot as servable. Note This mode is good for local development purposes and not recommended for production because it lacks scalability.","title":"Example"},{"location":"Getting-Started/Post-Installation-Steps/03-configuring-asset-blob-storage/#setting-up-azure-blob-storage-in-production-mode","text":"Before setting up Azure blob storage, you will first need to create one. This quick start guide by Microsoft will explain you how. Once your blob storage has been created, open appsettings.json and add the connection string under the Assets section. As a result, the Assets section should look like this: appsetting.json 1 \"Assets\" : { 2 \"Provider\" : \"AzureBlobStorage\" , 3 \"AzureBlobStorage\" : { 4 \"ConnectionString\" : \"DefaultEndpointsProtocol=https;AccountName=<media account name>;AccountKey=<media account key>;EndpointSuffix=core.windows.net\" 5 } 6 }, Note Line 2: Specify AzureBlobStorage as your default asset provider. Line 4: In ConnectionString , provide the connection string of your storage account. Tip You can get your connection string from your Azure Portal under the Access Keys section. Note This mode is recommended for using in production environment since it enables sharing the asset storage across multiple platform instances.","title":"Setting up Azure Blob Storage in Production Mode"},{"location":"Getting-Started/Post-Installation-Steps/04-importing-sample-data/","text":"Importing Sample Data To make it easier for you to explore what Virto Commerce can do, we provide a sample data set that you can import to automatically populate various entities. On the first launch, the platform displays a wizard that will prompt you to choose and import sample data. Currently, we only offer Clothing and Electronics sample data set that includes products, categories, customers, and other demo data that can assist developers and platform managers with learning how Virto Commerce works. In some cases, however, you may want to skip this step when getting started and import sample data later. In so, you will need to do this manually later on. Importing Sample Data Manually To manually install sample data, open More \u2192 Settings \u2192 Platform \u2192 Setup in the Virto Commerce platform and click the Import Sample Data widget: Select Clothing and Electronics in the popup window that will show up and wait until the sample data has been downloaded and imported into your system. Once finished, you will have a complete sample data set that is ready to use.","title":"Importing Sample Data"},{"location":"Getting-Started/Post-Installation-Steps/04-importing-sample-data/#importing-sample-data","text":"To make it easier for you to explore what Virto Commerce can do, we provide a sample data set that you can import to automatically populate various entities. On the first launch, the platform displays a wizard that will prompt you to choose and import sample data. Currently, we only offer Clothing and Electronics sample data set that includes products, categories, customers, and other demo data that can assist developers and platform managers with learning how Virto Commerce works. In some cases, however, you may want to skip this step when getting started and import sample data later. In so, you will need to do this manually later on.","title":"Importing Sample Data"},{"location":"Getting-Started/Post-Installation-Steps/04-importing-sample-data/#importing-sample-data-manually","text":"To manually install sample data, open More \u2192 Settings \u2192 Platform \u2192 Setup in the Virto Commerce platform and click the Import Sample Data widget: Select Clothing and Electronics in the popup window that will show up and wait until the sample data has been downloaded and imported into your system. Once finished, you will have a complete sample data set that is ready to use.","title":"Importing Sample Data Manually"},{"location":"GraphQL-Storefront-API-Reference-xAPI/","text":"Overview The project \"Experience API\" it is primarily a intermediated layer between clients and enterprise services powered by GraphQL protocol and is tightly coupled to a specific user/touchpoint experience with fast and reliable access, it represents an implementation of Backend for Frontend design pattern (BFF). The context diagram: Key concepts Use GraphQL protocol to leverage more selective and flexible control of resulting data retrieving from API; Fast and reliable indexed search thanks to integration with ES 7.x and single data source for indexed search and data storage (<= 300ms); Autonomy. Shared nothing with rest VC data infrastructure except index data source; Tracing and performance requests metrics. Key features X-Catalog docs X-Purchase cart docs X-Purchase order docs X-UserProfile module (moved to a separate module) Recommendations Gateway API (prototype) How to use Playground IDE To explore the GraphQL API, you can use an interactive graphql-playground environment. To open playground console open ui/playground in the platform manager application. http://localhost:10645/ui/playground Curl POST https://{platform-url}/graphql It accepts POST requests with following fields in a JSON body: - query - String - GraphQL query as a string - variables - Object - Optional - containing JSON object that defines variables for your query - operationName - String - Optional - the name of the operation, in case you defined several of them in the query Here is an example of a GraphQL query: $ curl -X POST http://localhost:10645/graphql \\ -H \"Content-Type:application/json\" \\ -H \"Authorization:Bearer ...\" \\ -d '{\"operationName\":null,\"variables\":{},\"query\":\"{ product(id: \\\"019e93d973cd4adab99b6f9cbb4ca97a\\\") { name }}\"}' Getting started Read this article... How to extend Read this article... Where to find logs Read this article... Limitation The project has integration with Elastic Search 7.x and Azure Search Service providers for indexing search. Lucene search provider not supported.","title":"Overview"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#overview","text":"The project \"Experience API\" it is primarily a intermediated layer between clients and enterprise services powered by GraphQL protocol and is tightly coupled to a specific user/touchpoint experience with fast and reliable access, it represents an implementation of Backend for Frontend design pattern (BFF). The context diagram:","title":"Overview"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#key-concepts","text":"Use GraphQL protocol to leverage more selective and flexible control of resulting data retrieving from API; Fast and reliable indexed search thanks to integration with ES 7.x and single data source for indexed search and data storage (<= 300ms); Autonomy. Shared nothing with rest VC data infrastructure except index data source; Tracing and performance requests metrics.","title":"Key concepts"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#key-features","text":"X-Catalog docs X-Purchase cart docs X-Purchase order docs X-UserProfile module (moved to a separate module) Recommendations Gateway API (prototype)","title":"Key features"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#how-to-use","text":"","title":"How to use"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#playground-ide","text":"To explore the GraphQL API, you can use an interactive graphql-playground environment. To open playground console open ui/playground in the platform manager application. http://localhost:10645/ui/playground","title":"Playground IDE"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#curl","text":"POST https://{platform-url}/graphql It accepts POST requests with following fields in a JSON body: - query - String - GraphQL query as a string - variables - Object - Optional - containing JSON object that defines variables for your query - operationName - String - Optional - the name of the operation, in case you defined several of them in the query Here is an example of a GraphQL query: $ curl -X POST http://localhost:10645/graphql \\ -H \"Content-Type:application/json\" \\ -H \"Authorization:Bearer ...\" \\ -d '{\"operationName\":null,\"variables\":{},\"query\":\"{ product(id: \\\"019e93d973cd4adab99b6f9cbb4ca97a\\\") { name }}\"}'","title":"Curl"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#getting-started","text":"Read this article...","title":"Getting started"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#how-to-extend","text":"Read this article...","title":"How to extend"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#where-to-find-logs","text":"Read this article...","title":"Where to find logs"},{"location":"GraphQL-Storefront-API-Reference-xAPI/#limitation","text":"The project has integration with Elastic Search 7.x and Azure Search Service providers for indexing search. Lucene search provider not supported.","title":"Limitation"},{"location":"GraphQL-Storefront-API-Reference-xAPI/getting-started/","text":"Getting started The project \"Experience API\" it is primarily a intermediated layer between clients and enterprise services powered by GraphQL protocol and is tightly coupled to a specific user/touchpoint experience with fast and reliable access, it represents an implementation of Backend for Frontend design pattern (BFF). Prerequisites VC platform 3.0 or later The platform is configured to use ElasticSearch engine appsettings.json \"Search\" : { \"Provider\" : \"ElasticSearch\" , \"Scope\" : \"default\" , \"ElasticSearch\" : { \"Server\" : \"localhost:9200\" , \"User\" : \"elastic\" , \"Key\" : \"\" , \"EnableHttpCompression\" : \"\" }, \"OrderFullTextSearchEnabled\" : true } The settings \u201cStore full object in index modules\u201d are enabled for catalog and pricing modules: Rebuild index Test environment Deploy vc-module-experience-api module into the platform of 3.0 version or latest, guided by this article https://github.com/VirtoCommerce/vc-platform/blob/master/docs/developer-guide/deploy-module-from-source-code.md Restart the platform instance Open GraphQL UI playground in the browser http://{platform url}/ui/playground The sample requests: { produc t (id : \"0f7a77cc1b9a46a29f6a159e5cd49ad1\" ) { id na me proper t ies { na me t ype values } } produc ts (query : \"sony\" fu zzy : true f il ter : \"price.USD:(400 TO 1000]\" ) { t o tal Cou nt i te ms { na me id prices (curre n cy : \"USD\" ) { lis t curre n cy } } } }","title":"Getting Started"},{"location":"GraphQL-Storefront-API-Reference-xAPI/getting-started/#getting-started","text":"The project \"Experience API\" it is primarily a intermediated layer between clients and enterprise services powered by GraphQL protocol and is tightly coupled to a specific user/touchpoint experience with fast and reliable access, it represents an implementation of Backend for Frontend design pattern (BFF).","title":"Getting started"},{"location":"GraphQL-Storefront-API-Reference-xAPI/getting-started/#prerequisites","text":"VC platform 3.0 or later The platform is configured to use ElasticSearch engine appsettings.json \"Search\" : { \"Provider\" : \"ElasticSearch\" , \"Scope\" : \"default\" , \"ElasticSearch\" : { \"Server\" : \"localhost:9200\" , \"User\" : \"elastic\" , \"Key\" : \"\" , \"EnableHttpCompression\" : \"\" }, \"OrderFullTextSearchEnabled\" : true } The settings \u201cStore full object in index modules\u201d are enabled for catalog and pricing modules: Rebuild index","title":"Prerequisites"},{"location":"GraphQL-Storefront-API-Reference-xAPI/getting-started/#test-environment","text":"Deploy vc-module-experience-api module into the platform of 3.0 version or latest, guided by this article https://github.com/VirtoCommerce/vc-platform/blob/master/docs/developer-guide/deploy-module-from-source-code.md Restart the platform instance Open GraphQL UI playground in the browser http://{platform url}/ui/playground The sample requests: { produc t (id : \"0f7a77cc1b9a46a29f6a159e5cd49ad1\" ) { id na me proper t ies { na me t ype values } } produc ts (query : \"sony\" fu zzy : true f il ter : \"price.USD:(400 TO 1000]\" ) { t o tal Cou nt i te ms { na me id prices (curre n cy : \"USD\" ) { lis t curre n cy } } } }","title":"Test environment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/recommendations/","text":"Sample: Recommendations Install Digital catalog experience API see above. Install Recommendations Gateway API module Add to the platform configuration file appsettings.json the following settings from this example https://github.com/VirtoSolutions/vc-module-experience-api/blob/master/samples/RecommendationsGatewayModule/RecommendationsGatewayModule.Core/Configuration/samples/vc-recommendations.json this settings add vc product association APIs as downstream for product recommendations. Open GraphQL UI playground in the browser http://{platform url}/ui/playground to start consume API. The recommendations example GraphQL request: recomme n da t io ns (sce nar io : \"vc-recommendations\" a fter : \"10\" f irs t : 5 i te mId : \"8b7b07c165924a879392f4f51a6f7ce0\" ) { i te ms { sce nar io produc t { id na me } } }","title":"Samples and Recommendations"},{"location":"GraphQL-Storefront-API-Reference-xAPI/recommendations/#sample-recommendations","text":"Install Digital catalog experience API see above. Install Recommendations Gateway API module Add to the platform configuration file appsettings.json the following settings from this example https://github.com/VirtoSolutions/vc-module-experience-api/blob/master/samples/RecommendationsGatewayModule/RecommendationsGatewayModule.Core/Configuration/samples/vc-recommendations.json this settings add vc product association APIs as downstream for product recommendations. Open GraphQL UI playground in the browser http://{platform url}/ui/playground to start consume API. The recommendations example GraphQL request: recomme n da t io ns (sce nar io : \"vc-recommendations\" a fter : \"10\" f irs t : 5 i te mId : \"8b7b07c165924a879392f4f51a6f7ce0\" ) { i te ms { sce nar io produc t { id na me } } }","title":"Sample: Recommendations"},{"location":"GraphQL-Storefront-API-Reference-xAPI/troubleshooting/","text":"Troubleshooting By default all GraphQL requests are sent via HTTP POST /graphql endpoind method and all the information about the request is included in the POST request body, therefore the ability to see in Application Insights what query or mutation was executed is lost. By overriding the default GraphQL executor we can send our custom telemetry to Application Insights and see what mutation or query was executed and what errors, if any, were handled by GraphQL. 1. General list of requests can be seen in the Performance tab: 2. Information about failed requests and associated Exceptions can be found in Failures tab: 3. Application Insights query mechanism:","title":"Troubleshooting"},{"location":"GraphQL-Storefront-API-Reference-xAPI/troubleshooting/#troubleshooting","text":"By default all GraphQL requests are sent via HTTP POST /graphql endpoind method and all the information about the request is included in the POST request body, therefore the ability to see in Application Insights what query or mutation was executed is lost. By overriding the default GraphQL executor we can send our custom telemetry to Application Insights and see what mutation or query was executed and what errors, if any, were handled by GraphQL. 1. General list of requests can be seen in the Performance tab: 2. Information about failed requests and associated Exceptions can be found in Failures tab: 3. Application Insights query mechanism:","title":"Troubleshooting"},{"location":"GraphQL-Storefront-API-Reference-xAPI/x-api-extensions/","text":"How to extend The xAPI provides default GraphQL schemas for types, queries, and mutations. However, each project has its unique requirements, and we can\u2019t foresee all of them and include into the base schema, but thanks to extensions points that the xAPI provides you can change the baseline behavior and data structures. On this article are described the main extension points and techniques that you can use in your custom projects. At the moment the xAPI project has the following main extensions points in addition to the extension points that platform provides extensibility overview Note: However, unfortunately, there is no opportunity to extend AutoMapper's profiles using AbstractTypeFactory<> type. Sample code Extend the root GraphQL schema Since the graphql-dotnet is supported the both schema definition schema-first-approach and graphtype-first-approach in the xAPI we stayed only on the graphtype-first-approach because it more naturally to .NET developers and gives you access to all of the provided properties of your GraphType's and Schema also this approach is better to suit the extension model via type overrides. In order to register a new query or mutation you need to derive the custom schema type from ISchemaBuilder . ISchemaBuilder \u2013 interface is intended for dynamic adding the new queries into the root GraphQL schema query, so that for register a new query you need to define a new type that implements this interface and register it in the DI. The multiple ISchemaBuilder instances will be used to add the queries into root schema in first time when application start. Here an example how to define schema types for existing domain types. On this example we define the new GraphQL schema object type - InventoryType for underlying domain type Inventory from the inventory module . CustomSchema.cs public class CustomSchema : ISchemaBuilder { public void Build ( ISchema schema ) { var inventoryQueryField = new FieldType { Name = \"inventory\" , Arguments = new QueryArguments ( new QueryArgument < NonNullGraphType < StringGraphType >> { Name = \"id\" }, ), Type = typeof ( InventoryType ), Resolver = new FieldResolver < Inventory >( context => { return new Inventory { ProductId = \"1\" , FulfillmentCenterId = \"center1\" }; }) }; schema . Query . AddField ( inventoryQueryField ); } } module.cs public class Module : IModule { public void Initialize ( IServiceCollection services ) { //Register custom schema services . AddSchemaBuilder < CustomSchema >(); } } Extend the existing schema type with new properties To extend the existing GraphQL type you need to do the following steps Derive your schema type from the existing one that you want to extend CartType2.cs public class CartType2 : CartType { public CartType2 ( ICartAvailMethodsService cartAvailMethods ) : base ( cartAvailMethods ) { Field < StringGraphType >( \"myCoolScalarProperty\" , resolve : context => \"my cool value\" ); } } Register your override with the special syntax in the module.cs . module.cs public class Module : IModule { public void Initialize ( IServiceCollection services ) { //GraphQL schema overrides services . AddSchemaType < CartType2 >(). OverrideType < CartType , CartType2 >(); } } Extend validation logic / replace validators The system uses Platform's abstract type factory to instantiate validators. Therefore the approach of validation logic extension similar to other cases (such as domain model extension): - Derive your custom validator from original one: CartValidator2.cs public class CartValidator2 : CartValidator { public CartValidator2 () { // Some additional rules (to the basic) can be provided there RuleFor ( x => x . CartAggregate . Cart . Id ). NotEmpty (); // Just example } } - Override original validator type with your custom in order to tell the factory CartValidator2 replaces the original validator: module.cs public class Module : IModule { public void PostInitialize ( IApplicationBuilder appBuilder ) { ... // Example: replace cart validator AbstractTypeFactory < CartValidator >. OverrideType < CartValidator , CartValidator2 >(); ... } } Generic behavior pipelines xAPI extension points are not limited to data structure extensions. You can also change behavior and business logic outside from the your custom module without touching the original source code. Generic behavior pipelines - is primarily intended to split the complex logic into multiple lousily coupled stages (middleware) that can be define on the different places and that are combined into one logical pipeline that can executed for some system events of requests. You can extend the existing generic pipelines with you own middlewares or even replace an existing to your custom version. Consider the example when you want to replace the existing generic pipeline that is called to enrich the ProductSearchResult with the data for pricing and availability from different data sources. //the generic pipeline that is used for on-the-fly additional data evaluation (prices, inventories, discounts and taxes) for resulting products services . AddPipeline < SearchProductResponse >( builder => { builder . AddMiddleware ( typeof ( EvalProductsPricesMiddleware )); builder . AddMiddleware ( typeof ( EvalProductsDiscountsMiddleware )); builder . AddMiddleware ( typeof ( EvalProductsTaxMiddleware )); builder . AddMiddleware ( typeof ( EvalProductsInventoryMiddleware )); }); First we need to define the new middleware MyCoolMiddleware.cs public class MyCoolMiddleware : IAsyncMiddleware < SearchProductResponse > { //code skipped for better clarity } The last step is register it for the generic behavior pipeline module.cs public class Module : IModule { public void Initialize ( IServiceCollection services ) { services . AddPipeline < SearchProductResponse >( builder => { builder . AddMiddleware ( typeof ( MyCoolMiddleware )); }); } } To replace the existing middleware to new one need to use the following syntax services . AddPipeline < SearchProductResponse >( builder => { builder . ReplaceMiddleware ( typeof ( EvalProductsTaxMiddleware ), typeof ( MyCoolMiddleware )); //this line replaced the EvalProductsTaxMiddleware with the MyCoolMiddleware for GenericPipeline<SearchProductResponse> }); Command/Query handlers replacement xAPI is built with using the clean architecture based on CQRS and DDD principles, where each command and query has it's own handler that is responsible for handling and processing incoming actions, you can easy override and substitute any existing handler with your own implementation thereby changing the default behavior. To do this, it is just enough to replace the required handler in the DI container with your own implementation. public class Module : IModule { public void Initialize ( IServiceCollection services ) { //use such lines to override exists query or command handler services . AddTransient < IRequestHandler < GetCartQuery , CartAggregate >, CustomGetCartQueryHandler >(); } } To replace an existing command with your own implementation first register and override of your Input type module.cs services . AddSchemaType < InputRemoveCartType2 >(). OverrideType < InputRemoveCartType , InputRemoveCartType2 >(); And then regiser your implementations of Command and Handler like this module.cs services . OverrideCommandType < RemoveCartCommand , RemoveCartCommandExtended >(). WithCommandHandler < RemoveCartCommandHandlerExtended >();","title":"xAPI Extensions"},{"location":"GraphQL-Storefront-API-Reference-xAPI/x-api-extensions/#how-to-extend","text":"The xAPI provides default GraphQL schemas for types, queries, and mutations. However, each project has its unique requirements, and we can\u2019t foresee all of them and include into the base schema, but thanks to extensions points that the xAPI provides you can change the baseline behavior and data structures. On this article are described the main extension points and techniques that you can use in your custom projects. At the moment the xAPI project has the following main extensions points in addition to the extension points that platform provides extensibility overview Note: However, unfortunately, there is no opportunity to extend AutoMapper's profiles using AbstractTypeFactory<> type. Sample code","title":"How to extend"},{"location":"GraphQL-Storefront-API-Reference-xAPI/x-api-extensions/#extend-the-root-graphql-schema","text":"Since the graphql-dotnet is supported the both schema definition schema-first-approach and graphtype-first-approach in the xAPI we stayed only on the graphtype-first-approach because it more naturally to .NET developers and gives you access to all of the provided properties of your GraphType's and Schema also this approach is better to suit the extension model via type overrides. In order to register a new query or mutation you need to derive the custom schema type from ISchemaBuilder . ISchemaBuilder \u2013 interface is intended for dynamic adding the new queries into the root GraphQL schema query, so that for register a new query you need to define a new type that implements this interface and register it in the DI. The multiple ISchemaBuilder instances will be used to add the queries into root schema in first time when application start. Here an example how to define schema types for existing domain types. On this example we define the new GraphQL schema object type - InventoryType for underlying domain type Inventory from the inventory module . CustomSchema.cs public class CustomSchema : ISchemaBuilder { public void Build ( ISchema schema ) { var inventoryQueryField = new FieldType { Name = \"inventory\" , Arguments = new QueryArguments ( new QueryArgument < NonNullGraphType < StringGraphType >> { Name = \"id\" }, ), Type = typeof ( InventoryType ), Resolver = new FieldResolver < Inventory >( context => { return new Inventory { ProductId = \"1\" , FulfillmentCenterId = \"center1\" }; }) }; schema . Query . AddField ( inventoryQueryField ); } } module.cs public class Module : IModule { public void Initialize ( IServiceCollection services ) { //Register custom schema services . AddSchemaBuilder < CustomSchema >(); } }","title":"Extend the root GraphQL schema"},{"location":"GraphQL-Storefront-API-Reference-xAPI/x-api-extensions/#extend-the-existing-schema-type-with-new-properties","text":"To extend the existing GraphQL type you need to do the following steps Derive your schema type from the existing one that you want to extend CartType2.cs public class CartType2 : CartType { public CartType2 ( ICartAvailMethodsService cartAvailMethods ) : base ( cartAvailMethods ) { Field < StringGraphType >( \"myCoolScalarProperty\" , resolve : context => \"my cool value\" ); } } Register your override with the special syntax in the module.cs . module.cs public class Module : IModule { public void Initialize ( IServiceCollection services ) { //GraphQL schema overrides services . AddSchemaType < CartType2 >(). OverrideType < CartType , CartType2 >(); } }","title":"Extend the existing schema type with new properties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/x-api-extensions/#extend-validation-logic-replace-validators","text":"The system uses Platform's abstract type factory to instantiate validators. Therefore the approach of validation logic extension similar to other cases (such as domain model extension): - Derive your custom validator from original one: CartValidator2.cs public class CartValidator2 : CartValidator { public CartValidator2 () { // Some additional rules (to the basic) can be provided there RuleFor ( x => x . CartAggregate . Cart . Id ). NotEmpty (); // Just example } } - Override original validator type with your custom in order to tell the factory CartValidator2 replaces the original validator: module.cs public class Module : IModule { public void PostInitialize ( IApplicationBuilder appBuilder ) { ... // Example: replace cart validator AbstractTypeFactory < CartValidator >. OverrideType < CartValidator , CartValidator2 >(); ... } }","title":"Extend validation logic / replace validators"},{"location":"GraphQL-Storefront-API-Reference-xAPI/x-api-extensions/#generic-behavior-pipelines","text":"xAPI extension points are not limited to data structure extensions. You can also change behavior and business logic outside from the your custom module without touching the original source code. Generic behavior pipelines - is primarily intended to split the complex logic into multiple lousily coupled stages (middleware) that can be define on the different places and that are combined into one logical pipeline that can executed for some system events of requests. You can extend the existing generic pipelines with you own middlewares or even replace an existing to your custom version. Consider the example when you want to replace the existing generic pipeline that is called to enrich the ProductSearchResult with the data for pricing and availability from different data sources. //the generic pipeline that is used for on-the-fly additional data evaluation (prices, inventories, discounts and taxes) for resulting products services . AddPipeline < SearchProductResponse >( builder => { builder . AddMiddleware ( typeof ( EvalProductsPricesMiddleware )); builder . AddMiddleware ( typeof ( EvalProductsDiscountsMiddleware )); builder . AddMiddleware ( typeof ( EvalProductsTaxMiddleware )); builder . AddMiddleware ( typeof ( EvalProductsInventoryMiddleware )); }); First we need to define the new middleware MyCoolMiddleware.cs public class MyCoolMiddleware : IAsyncMiddleware < SearchProductResponse > { //code skipped for better clarity } The last step is register it for the generic behavior pipeline module.cs public class Module : IModule { public void Initialize ( IServiceCollection services ) { services . AddPipeline < SearchProductResponse >( builder => { builder . AddMiddleware ( typeof ( MyCoolMiddleware )); }); } } To replace the existing middleware to new one need to use the following syntax services . AddPipeline < SearchProductResponse >( builder => { builder . ReplaceMiddleware ( typeof ( EvalProductsTaxMiddleware ), typeof ( MyCoolMiddleware )); //this line replaced the EvalProductsTaxMiddleware with the MyCoolMiddleware for GenericPipeline<SearchProductResponse> });","title":"Generic behavior pipelines"},{"location":"GraphQL-Storefront-API-Reference-xAPI/x-api-extensions/#commandquery-handlers-replacement","text":"xAPI is built with using the clean architecture based on CQRS and DDD principles, where each command and query has it's own handler that is responsible for handling and processing incoming actions, you can easy override and substitute any existing handler with your own implementation thereby changing the default behavior. To do this, it is just enough to replace the required handler in the DI container with your own implementation. public class Module : IModule { public void Initialize ( IServiceCollection services ) { //use such lines to override exists query or command handler services . AddTransient < IRequestHandler < GetCartQuery , CartAggregate >, CustomGetCartQueryHandler >(); } } To replace an existing command with your own implementation first register and override of your Input type module.cs services . AddSchemaType < InputRemoveCartType2 >(). OverrideType < InputRemoveCartType , InputRemoveCartType2 >(); And then regiser your implementations of Command and Handler like this module.cs services . OverrideCommandType < RemoveCartCommand , RemoveCartCommandExtended >(). WithCommandHandler < RemoveCartCommandHandlerExtended >();","title":"Command/Query handlers replacement"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/overview/","text":"Cart xAPI The Cart xAPI provides high performance API for shopping cart with the following key features: Working with shopping cart Auto evaluating taxes and prices Multi-language and multi-currency capabilities Lazy resolving Jump to any of the following sections to see what exactly this API does: Queries Mutations Objects","title":"Overview"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/overview/#cart-xapi","text":"The Cart xAPI provides high performance API for shopping cart with the following key features: Working with shopping cart Auto evaluating taxes and prices Multi-language and multi-currency capabilities Lazy resolving Jump to any of the following sections to see what exactly this API does: Queries Mutations Objects","title":"Cart xAPI"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/01-overview/","text":"Mutations Every mutation contains base arguments for working with the cart context: storeId : Current store ID cartName : Cart name userId : Current user ID currencyCode : Currency code, e.g., USD cultureName : Culture code for the current language, e.g., en-US cartType : Cart type, which is either cart or whishlist","title":"Overview"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/01-overview/#mutations","text":"Every mutation contains base arguments for working with the cart context: storeId : Current store ID cartName : Cart name userId : Current user ID currencyCode : Currency code, e.g., USD cultureName : Culture code for the current language, e.g., en-US cartType : Cart type, which is either cart or whishlist","title":"Mutations"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/02-mutation-list/","text":"Mutation List # Endpoint Arguments Description 1 addItem !productId !quantity price comment Adds item to cart 2 clearCart - Removes items from cart 3 changeComment comment Updates cart comment 4 changeCartItemPrice !productId !price Changes cart item price 5 changeCartItemQuantity !lineItemId !quantity Changes cart item quantity 6 changeCartItemComment !lineItemId comment Changes cart item comment 7 removeCartItem !lineItemId Removes cart item from cart 8 addCoupon !couponCode Adds coupon to cart 9 removeCoupon couponCode Removes coupon from cart; if no specific coupon name is supplied, clears all coupons from cart 10 removeShipment shipmentId Removes shipping method from cart 11 addOrUpdateCartShipment !shipment ( type ) Adds or updates shipping method for cart. 12 addOrUpdateCartPayment !payment ( type ) Adds or updates payment method for cart 13 validateCoupon !coupon Validates coupon and returns result 14 mergeCart !secondCartId Merges two carts into one 15 removeCart !cartId Removes cart 16 clearShipments - Clears cart shipping methods 17 clearPayments - Clears cart payment methods 18 updateCartDynamicProperties !dynamicProperties Updates dynamic properties within cart 19 updateCartItemDynamicProperties !lineItemId !dynamicProperties Updates dynamic properties within cart items 20 updateCartShipmentDynamicProperties !shipmentId !dynamicProperties Updates dynamic properties whitin cart shipping methods 21 updateCartPaymentDynamicProperties !paymentId !dynamicProperties Updates dynamic properties within cart payment methods 22 addCartAddress !address ( type ) Adds address for cart or updates it by type 23 addWishlistBulkItem !listIds !productId Adds product to multiple wish lists Note The Arguments column lists only additional arguments; those marked with an exclamation mark are required.","title":"Mutation List"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/02-mutation-list/#mutation-list","text":"# Endpoint Arguments Description 1 addItem !productId !quantity price comment Adds item to cart 2 clearCart - Removes items from cart 3 changeComment comment Updates cart comment 4 changeCartItemPrice !productId !price Changes cart item price 5 changeCartItemQuantity !lineItemId !quantity Changes cart item quantity 6 changeCartItemComment !lineItemId comment Changes cart item comment 7 removeCartItem !lineItemId Removes cart item from cart 8 addCoupon !couponCode Adds coupon to cart 9 removeCoupon couponCode Removes coupon from cart; if no specific coupon name is supplied, clears all coupons from cart 10 removeShipment shipmentId Removes shipping method from cart 11 addOrUpdateCartShipment !shipment ( type ) Adds or updates shipping method for cart. 12 addOrUpdateCartPayment !payment ( type ) Adds or updates payment method for cart 13 validateCoupon !coupon Validates coupon and returns result 14 mergeCart !secondCartId Merges two carts into one 15 removeCart !cartId Removes cart 16 clearShipments - Clears cart shipping methods 17 clearPayments - Clears cart payment methods 18 updateCartDynamicProperties !dynamicProperties Updates dynamic properties within cart 19 updateCartItemDynamicProperties !lineItemId !dynamicProperties Updates dynamic properties within cart items 20 updateCartShipmentDynamicProperties !shipmentId !dynamicProperties Updates dynamic properties whitin cart shipping methods 21 updateCartPaymentDynamicProperties !paymentId !dynamicProperties Updates dynamic properties within cart payment methods 22 addCartAddress !address ( type ) Adds address for cart or updates it by type 23 addWishlistBulkItem !listIds !productId Adds product to multiple wish lists Note The Arguments column lists only additional arguments; those marked with an exclamation mark are required.","title":"Mutation List"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/03-add-item/","text":"AddItem This mutation validates an item and adds it to the cart; it also recalculates promotion rewards and taxes and applies it to the cart. Query mutation ($command:InputAddItemType!) { (command: $command) { name items { id sku } itemsCount itemsQuantity } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"productId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"quantity\" : 1 , \"dynamicProperties\" : [ { \"name\" : \"ItemProperty\" , \"value\" : \"test value\" } ] }","title":"AddItem"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/03-add-item/#additem","text":"This mutation validates an item and adds it to the cart; it also recalculates promotion rewards and taxes and applies it to the cart.","title":"AddItem"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/03-add-item/#query","text":"mutation ($command:InputAddItemType!) { (command: $command) { name items { id sku } itemsCount itemsQuantity } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/03-add-item/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"productId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"quantity\" : 1 , \"dynamicProperties\" : [ { \"name\" : \"ItemProperty\" , \"value\" : \"test value\" } ] }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/04-clear-cart/","text":"ClearCart This mutation removes all items from the cart, resets promotion rewards based on the amount of items, and saves the cart. Query mu tat io n ($comma n d : I n pu t ClearCar t Type!) { (comma n d : $comma n d) { na me i te ms { id sku } i te msCou nt i te msQua nt i t y } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" }","title":"ClearCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/04-clear-cart/#clearcart","text":"This mutation removes all items from the cart, resets promotion rewards based on the amount of items, and saves the cart.","title":"ClearCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/04-clear-cart/#query","text":"mu tat io n ($comma n d : I n pu t ClearCar t Type!) { (comma n d : $comma n d) { na me i te ms { id sku } i te msCou nt i te msQua nt i t y } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/04-clear-cart/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/05-change-comment/","text":"ChangeComment This mutation changes the cart comments. Query mu tat io n ($comma n d : I n pu t Cha n geComme nt Type!) { (comma n d : $comma n d) { na me comme nt } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"comment\" : \"Hi, Virto! :)\" }","title":"ChangeComment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/05-change-comment/#changecomment","text":"This mutation changes the cart comments.","title":"ChangeComment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/05-change-comment/#query","text":"mu tat io n ($comma n d : I n pu t Cha n geComme nt Type!) { (comma n d : $comma n d) { na me comme nt } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/05-change-comment/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"comment\" : \"Hi, Virto! :)\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/06-change-cart-item-price/","text":"ChangeCartItemPrice This mutation changes the cart item price. Query mu tat io n ($comma n d : I n pu t Cha n geCar t I te mPriceType!) { (comma n d : $comma n d) { id i te ms { sku produc t Id lis t Price lis t PriceWi t hTax salePrice salePriceWi t hTax } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"productId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"price\" : 777 }","title":"ChangeCartItemPrice"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/06-change-cart-item-price/#changecartitemprice","text":"This mutation changes the cart item price.","title":"ChangeCartItemPrice"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/06-change-cart-item-price/#query","text":"mu tat io n ($comma n d : I n pu t Cha n geCar t I te mPriceType!) { (comma n d : $comma n d) { id i te ms { sku produc t Id lis t Price lis t PriceWi t hTax salePrice salePriceWi t hTax } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/06-change-cart-item-price/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"productId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"price\" : 777 }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/07-change-cart-item-quantity/","text":"ChangeCartItemQuantity This mutation changes the cart item quantity. Query mu tat io n ($comma n d : I n pu t Cha n geCar t I te mQua nt i t yType!) { (comma n d : $comma n d) { id i te ms { sku produc t Id qua nt i t y } i te msCou nt i te msQua nt i t y } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"quantity\" : 7 }","title":"ChangeCartItemQuantity"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/07-change-cart-item-quantity/#changecartitemquantity","text":"This mutation changes the cart item quantity.","title":"ChangeCartItemQuantity"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/07-change-cart-item-quantity/#query","text":"mu tat io n ($comma n d : I n pu t Cha n geCar t I te mQua nt i t yType!) { (comma n d : $comma n d) { id i te ms { sku produc t Id qua nt i t y } i te msCou nt i te msQua nt i t y } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/07-change-cart-item-quantity/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"quantity\" : 7 }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/08-change-cart-item-comment/","text":"ChangeCartItemComment This mutation changes cart item comments. Query mu tat io n ($comma n d : I n pu t Cha n geCar t I te mComme nt Type!) { (comma n d : $comma n d) { id i te ms { sku produc t Id comme nt } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"comment\" : \"nice product\" }","title":"ChangeCartItemComment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/08-change-cart-item-comment/#changecartitemcomment","text":"This mutation changes cart item comments.","title":"ChangeCartItemComment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/08-change-cart-item-comment/#query","text":"mu tat io n ($comma n d : I n pu t Cha n geCar t I te mComme nt Type!) { (comma n d : $comma n d) { id i te ms { sku produc t Id comme nt } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/08-change-cart-item-comment/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"9cbd8f316e254a679ba34a900fccb076\" , \"comment\" : \"nice product\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/09-remove-cart-item/","text":"RemoveCartItem This mutation enables removing an item from the cart. Query mu tat io n ($comma n d : I n pu t RemoveI te mType!) { (comma n d : $comma n d) { id i te ms { sku produc t Id } i te msCou nt i te msQua nt i t y } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"9cbd8f316e254a679ba34a900fccb076\" , }","title":"RemoveCartItem"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/09-remove-cart-item/#removecartitem","text":"This mutation enables removing an item from the cart.","title":"RemoveCartItem"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/09-remove-cart-item/#query","text":"mu tat io n ($comma n d : I n pu t RemoveI te mType!) { (comma n d : $comma n d) { id i te ms { sku produc t Id } i te msCou nt i te msQua nt i t y } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/09-remove-cart-item/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"9cbd8f316e254a679ba34a900fccb076\" , }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/10-add-coupon/","text":"AddCoupon This mutation checks and adds coupons to cart. Query mu tat io n ($comma n d : I n pu t AddCoupo n Type!) { (comma n d : $comma n d) { na me coupo ns { code isAppliedSuccess full y } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"couponCode\" : \"freeItemsCouponCode\" , }","title":"AddCoupon"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/10-add-coupon/#addcoupon","text":"This mutation checks and adds coupons to cart.","title":"AddCoupon"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/10-add-coupon/#query","text":"mu tat io n ($comma n d : I n pu t AddCoupo n Type!) { (comma n d : $comma n d) { na me coupo ns { code isAppliedSuccess full y } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/10-add-coupon/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"couponCode\" : \"freeItemsCouponCode\" , }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/11-remove-coupon/","text":"RemoveCoupon This mutation removes coupon from cart. Query mu tat io n ($comma n d : I n pu t RemoveCoupo n Type!) { (comma n d : $comma n d) { na me coupo ns { code isAppliedSuccess full y } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"couponCode\" : \"freeItemsCouponCode\" , }","title":"RemoveCoupon"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/11-remove-coupon/#removecoupon","text":"This mutation removes coupon from cart.","title":"RemoveCoupon"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/11-remove-coupon/#query","text":"mu tat io n ($comma n d : I n pu t RemoveCoupo n Type!) { (comma n d : $comma n d) { na me coupo ns { code isAppliedSuccess full y } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/11-remove-coupon/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"couponCode\" : \"freeItemsCouponCode\" , }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/12-remove-shipment/","text":"RemoveShipment This mutation removes shipping methods from the cart. Query mu tat io n ($comma n d : I n pu t RemoveShipme nt Type!) { (comma n d : $comma n d) { na me availableShippi n gMe t hods { code op t io n Name op t io n Descrip t io n } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"shipmentId\" : \"7777-7777-7777-7777\" , }","title":"RemoveShipment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/12-remove-shipment/#removeshipment","text":"This mutation removes shipping methods from the cart.","title":"RemoveShipment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/12-remove-shipment/#query","text":"mu tat io n ($comma n d : I n pu t RemoveShipme nt Type!) { (comma n d : $comma n d) { na me availableShippi n gMe t hods { code op t io n Name op t io n Descrip t io n } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/12-remove-shipment/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"shipmentId\" : \"7777-7777-7777-7777\" , }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/13-add-or-update-cart-shipment/","text":"AddOrUpdateCartShipment This mutation adds or updates cart shipping methods. It supports partial update, with all fields in command.shipment and command.shipment.deliveryAddress being optional. Query mu tat io n ($comma n d : I n pu t AddOrUpda te Car t Shipme nt Type!) { (comma n d : $comma n d) { na me availableShippi n gMe t hods { code op t io n Name op t io n Descrip t io n } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"shipment\" : { \"fulfillmentCenterId\" : \"7777-7777-7777-7777\" , \"height\" : 7 , \"shipmentMethodCode\" : \"code\" , \"currency\" : \"USD\" , \"price\" : 98 , \"dynamicProperties\" : [ { \"name\" : \"ShipmentProperty\" , \"value\" : \"test value\" } ] }, } Tip To see all possible parametrs for the shipment object, check out our GitHub repository .","title":"AddOrUpdateCartShipment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/13-add-or-update-cart-shipment/#addorupdatecartshipment","text":"This mutation adds or updates cart shipping methods. It supports partial update, with all fields in command.shipment and command.shipment.deliveryAddress being optional.","title":"AddOrUpdateCartShipment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/13-add-or-update-cart-shipment/#query","text":"mu tat io n ($comma n d : I n pu t AddOrUpda te Car t Shipme nt Type!) { (comma n d : $comma n d) { na me availableShippi n gMe t hods { code op t io n Name op t io n Descrip t io n } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/13-add-or-update-cart-shipment/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"shipment\" : { \"fulfillmentCenterId\" : \"7777-7777-7777-7777\" , \"height\" : 7 , \"shipmentMethodCode\" : \"code\" , \"currency\" : \"USD\" , \"price\" : 98 , \"dynamicProperties\" : [ { \"name\" : \"ShipmentProperty\" , \"value\" : \"test value\" } ] }, } Tip To see all possible parametrs for the shipment object, check out our GitHub repository .","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/14-add-or-update-cart-payment/","text":"AddOrUpdateCartPayment This mutation adds or updates cart payment. It supports partial update, with all fields in command.payment and command.payment.billingAddress being optional. Query mu tat io n ($comma n d : I n pu t AddOrUpda te Car t Payme nt Type!) { (comma n d : $comma n d) { na me availablePayme nt Me t hods { code na me payme nt Me t hodType } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"payment\" : { \"outerId\" : \"7777-7777-7777-7777\" , \"paymentGatewayCode\" : \"code\" , \"currency\" : \"USD\" , \"price\" : 98 , \"amount\" : 55 , \"dynamicProperties\" : [ { \"name\" : \"PaymentProperty\" , \"value\" : \"test value\" } ] }, } Tip To see all possible parametrs for the payment object, check out our GitHub repository .","title":"AddOrUpdateCartPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/14-add-or-update-cart-payment/#addorupdatecartpayment","text":"This mutation adds or updates cart payment. It supports partial update, with all fields in command.payment and command.payment.billingAddress being optional.","title":"AddOrUpdateCartPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/14-add-or-update-cart-payment/#query","text":"mu tat io n ($comma n d : I n pu t AddOrUpda te Car t Payme nt Type!) { (comma n d : $comma n d) { na me availablePayme nt Me t hods { code na me payme nt Me t hodType } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/14-add-or-update-cart-payment/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"payment\" : { \"outerId\" : \"7777-7777-7777-7777\" , \"paymentGatewayCode\" : \"code\" , \"currency\" : \"USD\" , \"price\" : 98 , \"amount\" : 55 , \"dynamicProperties\" : [ { \"name\" : \"PaymentProperty\" , \"value\" : \"test value\" } ] }, } Tip To see all possible parametrs for the payment object, check out our GitHub repository .","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/15-validate-coupon/","text":"ValidateCoupon This mutation validates coupons. Query mu tat io n ($comma n d : I n pu t Valida te Coupo n Type!) { (comma n d : $comma n d) } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"coupon\" : { \"code\" : \"freeItemsCouponCode\" }, }","title":"ValidateCoupon"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/15-validate-coupon/#validatecoupon","text":"This mutation validates coupons.","title":"ValidateCoupon"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/15-validate-coupon/#query","text":"mu tat io n ($comma n d : I n pu t Valida te Coupo n Type!) { (comma n d : $comma n d) }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/15-validate-coupon/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"coupon\" : { \"code\" : \"freeItemsCouponCode\" }, }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/16-merge-cart/","text":"MergeCart This mutation merges two carts. You can use it to merge an anonymous cart with a user cart after user authentication. Query mu tat io n ($comma n d : I n pu t MergeCar t Type!) { (comma n d : $comma n d) { id isA n o n ymous } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"secondCartId\" : \"7777-7777-7777-7777\" , }","title":"MergeCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/16-merge-cart/#mergecart","text":"This mutation merges two carts. You can use it to merge an anonymous cart with a user cart after user authentication.","title":"MergeCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/16-merge-cart/#query","text":"mu tat io n ($comma n d : I n pu t MergeCar t Type!) { (comma n d : $comma n d) { id isA n o n ymous } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/16-merge-cart/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"secondCartId\" : \"7777-7777-7777-7777\" , }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/17-remove-cart/","text":"RemoveCart This mutation allows you to remove a cart. Query mu tat io n ($comma n d : I n pu t RemoveCar t Type!) { (comma n d : $comma n d) } Variables \"command\": { \"cartId\": \"7777-7777-7777-7777\" }","title":"RemoveCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/17-remove-cart/#removecart","text":"This mutation allows you to remove a cart.","title":"RemoveCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/17-remove-cart/#query","text":"mu tat io n ($comma n d : I n pu t RemoveCar t Type!) { (comma n d : $comma n d) }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/17-remove-cart/#variables","text":"\"command\": { \"cartId\": \"7777-7777-7777-7777\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/18-clear-shipments/","text":"ClearShipments This mutation removes all shipping methods from the cart. Query mu tat io n ($comma n d : I n pu t ClearShipme nts Type!) { (comma n d : $comma n d) { na me availableShippi n gMe t hods { code op t io n Name op t io n Descrip t io n } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" }","title":"ClearShipments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/18-clear-shipments/#clearshipments","text":"This mutation removes all shipping methods from the cart.","title":"ClearShipments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/18-clear-shipments/#query","text":"mu tat io n ($comma n d : I n pu t ClearShipme nts Type!) { (comma n d : $comma n d) { na me availableShippi n gMe t hods { code op t io n Name op t io n Descrip t io n } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/18-clear-shipments/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/19-clear-payments/","text":"ClearPayments This mutation removes all payment methods from the cart. Query mu tat io n ($comma n d : I n pu t ClearPayme nts Type!) { (comma n d : $comma n d) { na me availablePayme nt Me t hods { code na me payme nt Me t hodType } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" }","title":"ClearPayments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/19-clear-payments/#clearpayments","text":"This mutation removes all payment methods from the cart.","title":"ClearPayments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/19-clear-payments/#query","text":"mu tat io n ($comma n d : I n pu t ClearPayme nts Type!) { (comma n d : $comma n d) { na me availablePayme nt Me t hods { code na me payme nt Me t hodType } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/19-clear-payments/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/20-update-cart-dynamic-properties/","text":"UpdateCartDynamicProperties This mutation updates dynamic properties within the cart. Query mu tat io n ($comma n d : I n pu t Upda te Car t Dy na micProper t iesType!) { upda te Car t Dy na micProper t ies(comma n d : $comma n d) { dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateCartDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/20-update-cart-dynamic-properties/#updatecartdynamicproperties","text":"This mutation updates dynamic properties within the cart.","title":"UpdateCartDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/20-update-cart-dynamic-properties/#query","text":"mu tat io n ($comma n d : I n pu t Upda te Car t Dy na micProper t iesType!) { upda te Car t Dy na micProper t ies(comma n d : $comma n d) { dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/20-update-cart-dynamic-properties/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/21-update-cart-item-dynamic-properties/","text":"UpdateCartItemDynamicProperties This mutation updates dynamic properties within the cart item. Query mu tat io n ($comma n d : I n pu t Upda te Car t I te mDy na micProper t iesType!) { upda te Car t I te mDy na micProper t ies(comma n d : $comma n d) { i te ms { id dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"dab09410-aa1a-4daf-8a32-4e41abee77b8\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateCartItemDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/21-update-cart-item-dynamic-properties/#updatecartitemdynamicproperties","text":"This mutation updates dynamic properties within the cart item.","title":"UpdateCartItemDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/21-update-cart-item-dynamic-properties/#query","text":"mu tat io n ($comma n d : I n pu t Upda te Car t I te mDy na micProper t iesType!) { upda te Car t I te mDy na micProper t ies(comma n d : $comma n d) { i te ms { id dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/21-update-cart-item-dynamic-properties/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"lineItemId\" : \"dab09410-aa1a-4daf-8a32-4e41abee77b8\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/22-update-cart-shipment-dynamic-properties/","text":"UpdateCartShipmentDynamicProperties This mutation updates dynamic properties for the cart shipping method. Query mu tat io n ($comma n d : I n pu t Upda te Car t I te mDy na micProper t iesType!) { upda te Car t Shipme nt Dy na micProper t ies(comma n d : $comma n d) { i te ms { id dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"shipmentId\" : \"79b8f095-9740-4353-998b-e1c4dd577ee6\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateCartShipmentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/22-update-cart-shipment-dynamic-properties/#updatecartshipmentdynamicproperties","text":"This mutation updates dynamic properties for the cart shipping method.","title":"UpdateCartShipmentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/22-update-cart-shipment-dynamic-properties/#query","text":"mu tat io n ($comma n d : I n pu t Upda te Car t I te mDy na micProper t iesType!) { upda te Car t Shipme nt Dy na micProper t ies(comma n d : $comma n d) { i te ms { id dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/22-update-cart-shipment-dynamic-properties/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"shipmentId\" : \"79b8f095-9740-4353-998b-e1c4dd577ee6\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/23-update-cart-payment-dynamic-properties/","text":"UpdateCartPaymentDynamicProperties This mutation updates dynamic properties for the cart payment method. Query mu tat io n ($comma n d : I n pu t Upda te Car t I te mDy na micProper t iesType!) { upda te Car t Payme nt Dy na micProper t ies(comma n d : $comma n d) { i te ms { id dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"paymentId\" : \"0859f1e8-16e8-4924-808b-47e03560085d\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateCartPaymentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/23-update-cart-payment-dynamic-properties/#updatecartpaymentdynamicproperties","text":"This mutation updates dynamic properties for the cart payment method.","title":"UpdateCartPaymentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/23-update-cart-payment-dynamic-properties/#query","text":"mu tat io n ($comma n d : I n pu t Upda te Car t I te mDy na micProper t iesType!) { upda te Car t Payme nt Dy na micProper t ies(comma n d : $comma n d) { i te ms { id dy na micProper t ies { na me value valueType dic t io nar yI te m { label na me id } } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/23-update-cart-payment-dynamic-properties/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"paymentId\" : \"0859f1e8-16e8-4924-808b-47e03560085d\" , \"dynamicProperties\" : [ { \"name\" : \"Example string property\" , \"value\" : \"12345678\" }, { \"name\" : \"Example multilanguage property\" , \"locale\" : \"de-DE\" , \"value\" : \"hallo welt\" }, { \"name\" : \"Example dictionary property\" , \"value\" : \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/24-add-cart-address/","text":"AddCartAddress This mutation adds a new address to the cart or updates an existing one through addressType . AddCartAddress supports partial update, with all fields in command.address being optional. Query mu tat io n addOrUpda te Car t Address ($comma n d : I n pu t AddOrUpda te Car t AddressType!) { addOrUpda te Car t Address (comma n d : $comma n d) { addresses { addressType ci t y cou ntr yCode cou ntr yName email f irs t Name id las t Name li ne 1 li ne 2 middleName na me orga n iza t io n pho ne pos tal Code regio n Id regio n Name zip } } } Variables \"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"address\" : { \"city\" : \"City name\" , \"countryCode\" : \"CountryCode\" , \"countryName\" : \"Country name\" , \"email\" : \"example@email.com\" , \"firstName\" : \"recipient name\" , \"middleName\" : \"recipient name\" , \"lastName\" : \"recipient name\" , \"line1\" : \"example address line 1\" , \"line2\" : \"example address line 1\" , \"organization\" : \"Organizatoin name\" , \"phone\" : \"77777-77777\" , \"postalCode\" : \"12345\" , \"regionId\" : \"RegionCode\" , \"regionName\" : \"Region name\" , \"zip\" : \"123\" , \"addressType\" : 3 } }","title":"AddCartAddress"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/24-add-cart-address/#addcartaddress","text":"This mutation adds a new address to the cart or updates an existing one through addressType . AddCartAddress supports partial update, with all fields in command.address being optional.","title":"AddCartAddress"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/24-add-cart-address/#query","text":"mu tat io n addOrUpda te Car t Address ($comma n d : I n pu t AddOrUpda te Car t AddressType!) { addOrUpda te Car t Address (comma n d : $comma n d) { addresses { addressType ci t y cou ntr yCode cou ntr yName email f irs t Name id las t Name li ne 1 li ne 2 middleName na me orga n iza t io n pho ne pos tal Code regio n Id regio n Name zip } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/24-add-cart-address/#variables","text":"\"command\" : { \"storeId\" : \"Electronics\" , \"cartName\" : \"default\" , \"userId\" : \"b57d06db-1638-4d37-9734-fd01a9bc59aa\" , \"cultureName\" : \"en-US\" , \"currencyCode\" : \"USD\" , \"cartType\" : \"cart\" , \"address\" : { \"city\" : \"City name\" , \"countryCode\" : \"CountryCode\" , \"countryName\" : \"Country name\" , \"email\" : \"example@email.com\" , \"firstName\" : \"recipient name\" , \"middleName\" : \"recipient name\" , \"lastName\" : \"recipient name\" , \"line1\" : \"example address line 1\" , \"line2\" : \"example address line 1\" , \"organization\" : \"Organizatoin name\" , \"phone\" : \"77777-77777\" , \"postalCode\" : \"12345\" , \"regionId\" : \"RegionCode\" , \"regionName\" : \"Region name\" , \"zip\" : \"123\" , \"addressType\" : 3 } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/25-add-wish-list-bulk-item/","text":"AddWishListBulkItem This mutation adds products to various wish lists. Query mu tat io n addWishlis t BulkI te m ($comma n d : I n pu t AddWishlis t BulkI te mType!) { addWishlis t BulkI te m (comma n d : $comma n d) { wishlis ts { na me id i te ms { id qua nt i t y produc t { na me } } } } } Variables \"command\" : { \"listIds\" : [ \"ce682f58-3bbd-42e5-a576-08c82a86ca11\" , \"1b249c7a-5b7b-434d-a9b5-56a67ff993fe\" ], \"productId\" : \"92e671024a8648de97dedcd488f58455\" }","title":"AddWishListBulkItem"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/25-add-wish-list-bulk-item/#addwishlistbulkitem","text":"This mutation adds products to various wish lists.","title":"AddWishListBulkItem"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/25-add-wish-list-bulk-item/#query","text":"mu tat io n addWishlis t BulkI te m ($comma n d : I n pu t AddWishlis t BulkI te mType!) { addWishlis t BulkI te m (comma n d : $comma n d) { wishlis ts { na me id i te ms { id qua nt i t y produc t { na me } } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/mutations/25-add-wish-list-bulk-item/#variables","text":"\"command\" : { \"listIds\" : [ \"ce682f58-3bbd-42e5-a576-08c82a86ca11\" , \"1b249c7a-5b7b-434d-a9b5-56a67ff993fe\" ], \"productId\" : \"92e671024a8648de97dedcd488f58455\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/objects/cart-type/","text":"CartType The chart below shows the components and relations of the CartType object: CartType Address Field The Cart.Addresses field in CartType is a functional enabler. Currently, it is not featured in any internal business logic and is separated from Cart.Billing.Addresses and Cart.Shipping.Addresses . Feel free to add your own business logic to it. You can find the address type structure here .","title":"CartType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/objects/cart-type/#carttype","text":"The chart below shows the components and relations of the CartType object:","title":"CartType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/objects/cart-type/#carttype-address-field","text":"The Cart.Addresses field in CartType is a functional enabler. Currently, it is not featured in any internal business logic and is separated from Cart.Billing.Addresses and Cart.Shipping.Addresses . Feel free to add your own business logic to it. You can find the address type structure here .","title":"CartType Address Field"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/queries/cart-connection/","text":"Carts Connection With this connection, you can get all user carts and whishlists. { carts (storeId: \"Electronics\" userId: \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cultureName: \"en-Us\" currencyCode: \"USD\" cartType: \"cart\" take: 5 skip: 0) { items { id name hasPhysicalProducts status storeId isAnonymous } pageInfo { startCursor endCursor hasNextPage hasPreviousPage } } }","title":"Cart Connection"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/queries/cart-connection/#carts-connection","text":"With this connection, you can get all user carts and whishlists. { carts (storeId: \"Electronics\" userId: \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cultureName: \"en-Us\" currencyCode: \"USD\" cartType: \"cart\" take: 5 skip: 0) { items { id name hasPhysicalProducts status storeId isAnonymous } pageInfo { startCursor endCursor hasNextPage hasPreviousPage } } }","title":"Carts Connection"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/queries/cart/","text":"Cart { cart (storeId: \"Electronics\" cartName: \"default\" userId: \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cultureName: \"en-Us\" currencyCode: \"USD\" cartType: \"cart\") { id name hasPhysicalProducts status storeId isAnonymous comment taxPercentRate taxType addresses { countryName regionName city addressType } dynamicProperties { name value valueType } shipments { shipmentMethodCode shipmentMethodOption } availableShippingMethods { code optionName optionDescription } discounts { amount description } currency { code symbol } payments { paymentGatewayCode } availablePaymentMethods { code paymentMethodType } items { id sku } coupons { code isAppliedSuccessfully } itemsCount itemsQuantity type } } Tip See also the CartType chart below for better understanding of the fields you can use in your requests.","title":"Cart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/queries/cart/#cart","text":"{ cart (storeId: \"Electronics\" cartName: \"default\" userId: \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cultureName: \"en-Us\" currencyCode: \"USD\" cartType: \"cart\") { id name hasPhysicalProducts status storeId isAnonymous comment taxPercentRate taxType addresses { countryName regionName city addressType } dynamicProperties { name value valueType } shipments { shipmentMethodCode shipmentMethodOption } availableShippingMethods { code optionName optionDescription } discounts { amount description } currency { code symbol } payments { paymentGatewayCode } availablePaymentMethods { code paymentMethodType } items { id sku } coupons { code isAppliedSuccessfully } itemsCount itemsQuantity type } } Tip See also the CartType chart below for better understanding of the fields you can use in your requests.","title":"Cart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/queries/query-list/","text":"Query List # Endpoint Arguments Return 1 cart storeId cartName userId cultureName currencyCode cartType Shopping cart 2 carts storeId cartName userId cultureName currencyCode cartType sort skip take Paginated shopping cart list","title":"Query List"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Cart/queries/query-list/#query-list","text":"# Endpoint Arguments Return 1 cart storeId cartName userId cultureName currencyCode cartType Shopping cart 2 carts storeId cartName userId cultureName currencyCode cartType sort skip take Paginated shopping cart list","title":"Query List"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/overview/","text":"X-Catalog X-Catalog provides high performance search queries for catalog data directly from the search index engine. Key Features You can view all X-Catalog's key features below: Full text search Fuzzy search Filter syntax Filtering by category, price, and other parameters Facets Multi-select faceting search How to Use Please refer to the Experience API Overview to for more information on how to use X-Catalog.","title":"Overview"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/overview/#x-catalog","text":"X-Catalog provides high performance search queries for catalog data directly from the search index engine.","title":"X-Catalog"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/overview/#key-features","text":"You can view all X-Catalog's key features below: Full text search Fuzzy search Filter syntax Filtering by category, price, and other parameters Facets Multi-select faceting search","title":"Key Features"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/overview/#how-to-use","text":"Please refer to the Experience API Overview to for more information on how to use X-Catalog.","title":"How to Use"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/01-full-text-search/","text":"Full Text Search The query parameter performs the full text search against the product index document. It expects a full text search phrase. Searchable Fields The search performs full text search over product data in the index. Product search returns all product variations a product has. All searchable text data of a product are stored in the single __content field in the resulting index document; the full text search is performed only for this field. An example of product document in the index may look like this: \"__content\" : [ \"JGC-85796278\" , \"ASUS ZenFone 2 ZE551ML Gold\" , \"asus\" , \"android\" , \"2.3 ghz intel gtx quad-core\" , \"micro-sim\" , \"1080\" ], The following product properties are stored in the __content field and are searched by default. product.name product.code product.seoinfos.seoinfo.slug product.properties.value product.variations.code product.variations.properties.value Example requests: # Search all produc ts by keyword `so n y` a n d re turn t he na me a n d primary image URL f or f irs t 20 f ou n d produc ts a n d t o tal cou nt { produc ts (query : \"sony\" s t oreId : \"Electronics\" f irs t : 20 ) { t o tal Cou nt i te ms { na me imgSrc } } }","title":"Full Text Search"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/01-full-text-search/#full-text-search","text":"The query parameter performs the full text search against the product index document. It expects a full text search phrase.","title":"Full Text Search"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/01-full-text-search/#searchable-fields","text":"The search performs full text search over product data in the index. Product search returns all product variations a product has. All searchable text data of a product are stored in the single __content field in the resulting index document; the full text search is performed only for this field. An example of product document in the index may look like this: \"__content\" : [ \"JGC-85796278\" , \"ASUS ZenFone 2 ZE551ML Gold\" , \"asus\" , \"android\" , \"2.3 ghz intel gtx quad-core\" , \"micro-sim\" , \"1080\" ], The following product properties are stored in the __content field and are searched by default. product.name product.code product.seoinfos.seoinfo.slug product.properties.value product.variations.code product.variations.properties.value Example requests: # Search all produc ts by keyword `so n y` a n d re turn t he na me a n d primary image URL f or f irs t 20 f ou n d produc ts a n d t o tal cou nt { produc ts (query : \"sony\" s t oreId : \"Electronics\" f irs t : 20 ) { t o tal Cou nt i te ms { na me imgSrc } } }","title":"Searchable Fields"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/02-fuzzy-search/","text":"Fuzzy Search When the fuzzy query parameter is set to true, the search will also return products that contain slight differences to the search text. For example, when someone searches for unversty , the fuzzy search would also return products labelled with university . The fuzzy level can be optionally set with the fuzzyLevel parameter; otherwise, the search will use auto fuzzy level based on the length of the searched text, with the minimum value at 3, and maximum, at 6. Example requests: # Will re turn produc ts t ha t co nta i n \"university\" , \"unversty\" , \"universe\" , e t c. { produc ts (query : \"unversty\" s t oreId : \"Electronics\" f irs t : 20 ) { t o tal Cou nt i te ms { na me imgSrc } } }","title":"Fuzzy Search"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/02-fuzzy-search/#fuzzy-search","text":"When the fuzzy query parameter is set to true, the search will also return products that contain slight differences to the search text. For example, when someone searches for unversty , the fuzzy search would also return products labelled with university . The fuzzy level can be optionally set with the fuzzyLevel parameter; otherwise, the search will use auto fuzzy level based on the length of the searched text, with the minimum value at 3, and maximum, at 6. Example requests: # Will re turn produc ts t ha t co nta i n \"university\" , \"unversty\" , \"universe\" , e t c. { produc ts (query : \"unversty\" s t oreId : \"Electronics\" f irs t : 20 ) { t o tal Cou nt i te ms { na me imgSrc } } }","title":"Fuzzy Search"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/","text":"Filters Search results can optionally be filtered and these filters are applied to the search hits at the very end of a search request , after all facets have already been calculated and don\u2019t influence facet counts any more. # The following example search request filters products of a certain color \u201cBlack\u201d OR \"Blue\" AND price between 100 USD inclusive TO 200 USD exlusive AND name starts with \"ASUS ZenFone 2\" { products(filter: \"color:Black,Blue price.usd:[100 TO 200) name:\\\"ASUS ZenFone 2*\\\" { totalCount items { name properties { name values } } } } Terms A query is broken up into terms and operators. There are two types of terms: Single Terms and Phrases . A Single Term is a single word such as \"test\" or \"hello\". A Phrase is a group of words surrounded by double quotes such as \"hello dolly\". Multiple terms can be combined together with Boolean operators to form a more complex query (see below). Fields When performing a search you can either specify a field by typing the field name followed by a colon \":\" and then the term you are looking for. name:\"My cool name\" color:Black Specifying multiple values in one field parameter, separated by a comma, will return products in which at least one of the specified values matches (OR-operator). The example search request below filters products of the color \u201cblack\u201d OR \u201cgrey\u201d or \"blue\": color:Black,Gey,Blue Range Filtration Range filtration allow one to match products whose field(s) values are between the lower and upper bound specified by the Range expression. Range filter expression can be inclusive or exclusive of the upper and lower bounds. Sorting is done lexicographically. price:[100 TO 200] This will find products whose prices have values between 100 and 200, inclusive. Inclusive range queries are denoted by square brackets. Exclusive range queries are denoted by round brackets. price:(100 TO 200] This will find products whose prices have values between 100 exclusive and 200 inclusive. You can skip one of the values to ignore either the lower or the upper bound price:(TO 100] where the price is less than or equal to 100 Boolean Operators Passing multiple field terms in the one filter expression separated by space delimiter will combine them with an AND operator. The following example search request filters products of a certain brand \"Onkyo\" AND of the color \u201cBlack\u201d. color:Black brand:Onkyo Warning At the moment, only the AND logical operator is supported for filter expressions. Wildcard Search You can use single and multiple character wildcard searches within single or phrase terms. To perform a single character wildcard search use the ? symbol. To perform a multiple character wildcard search use the * symbol. te?t Multiple character wildcard searches looks for 0 or more characters. For example, to search for test, tests or tester, you can use the search: test* You can also use the wildcard searches in the middle of a term. te*t Escaping Special Characters Inside the double quotes block you might use any unsafe characters, to escape double quote character use the \\ . See more details GraphQL String-Value \\\"my cool property\\\":\\\"&~!'\\\" More Examples color:Black,White where the color is 'Black' OR 'White' color:Black color:White where the color is 'Black' AND 'White' price_usd:[100 TO 200] where the price is in USD and between values including bounds price:(100 TO 200) where the price is in any currency and between values excluding bounds price:(0 TO) where the price is greater than zero price:(TO 100] where the price is less than or equal to 100 Da?? Red* use ? to replace a single character, and * to replace zero or more characters color:Black price:[100 TO 200) combine keywords and filters","title":"Filter Syntax"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#filters","text":"Search results can optionally be filtered and these filters are applied to the search hits at the very end of a search request , after all facets have already been calculated and don\u2019t influence facet counts any more. # The following example search request filters products of a certain color \u201cBlack\u201d OR \"Blue\" AND price between 100 USD inclusive TO 200 USD exlusive AND name starts with \"ASUS ZenFone 2\" { products(filter: \"color:Black,Blue price.usd:[100 TO 200) name:\\\"ASUS ZenFone 2*\\\" { totalCount items { name properties { name values } } } }","title":"Filters"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#terms","text":"A query is broken up into terms and operators. There are two types of terms: Single Terms and Phrases . A Single Term is a single word such as \"test\" or \"hello\". A Phrase is a group of words surrounded by double quotes such as \"hello dolly\". Multiple terms can be combined together with Boolean operators to form a more complex query (see below).","title":"Terms"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#fields","text":"When performing a search you can either specify a field by typing the field name followed by a colon \":\" and then the term you are looking for. name:\"My cool name\" color:Black Specifying multiple values in one field parameter, separated by a comma, will return products in which at least one of the specified values matches (OR-operator). The example search request below filters products of the color \u201cblack\u201d OR \u201cgrey\u201d or \"blue\": color:Black,Gey,Blue","title":"Fields"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#range-filtration","text":"Range filtration allow one to match products whose field(s) values are between the lower and upper bound specified by the Range expression. Range filter expression can be inclusive or exclusive of the upper and lower bounds. Sorting is done lexicographically. price:[100 TO 200] This will find products whose prices have values between 100 and 200, inclusive. Inclusive range queries are denoted by square brackets. Exclusive range queries are denoted by round brackets. price:(100 TO 200] This will find products whose prices have values between 100 exclusive and 200 inclusive. You can skip one of the values to ignore either the lower or the upper bound price:(TO 100] where the price is less than or equal to 100","title":"Range Filtration"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#boolean-operators","text":"Passing multiple field terms in the one filter expression separated by space delimiter will combine them with an AND operator. The following example search request filters products of a certain brand \"Onkyo\" AND of the color \u201cBlack\u201d. color:Black brand:Onkyo Warning At the moment, only the AND logical operator is supported for filter expressions.","title":"Boolean Operators"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#wildcard-search","text":"You can use single and multiple character wildcard searches within single or phrase terms. To perform a single character wildcard search use the ? symbol. To perform a multiple character wildcard search use the * symbol. te?t Multiple character wildcard searches looks for 0 or more characters. For example, to search for test, tests or tester, you can use the search: test* You can also use the wildcard searches in the middle of a term. te*t","title":"Wildcard Search"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#escaping-special-characters","text":"Inside the double quotes block you might use any unsafe characters, to escape double quote character use the \\ . See more details GraphQL String-Value \\\"my cool property\\\":\\\"&~!'\\\"","title":"Escaping Special Characters"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/03-filter-syntax/#more-examples","text":"color:Black,White where the color is 'Black' OR 'White' color:Black color:White where the color is 'Black' AND 'White' price_usd:[100 TO 200] where the price is in USD and between values including bounds price:(100 TO 200) where the price is in any currency and between values excluding bounds price:(0 TO) where the price is greater than zero price:(TO 100] where the price is less than or equal to 100 Da?? Red* use ? to replace a single character, and * to replace zero or more characters color:Black price:[100 TO 200) combine keywords and filters","title":"More Examples"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/","text":"Filtering The section below explains you how to manage the filtering process in the most frequently occuring scenarios. Filtering by Category You can also filter products that belong to the exactly specified category path. filter: \"category.path:{catalog id/category path}\" filter: \"category.path:catalogId/cat1d1/cat2id\" Note The search will be performed against the __path index field of the product document. Filter by category subtrees, keep only the products that belong to the specified Category or any of its descendant categories. filter: \"category.subtree:{catalog id/category path}\" filter: \"category.subtree:catalogId/cat1d1/cat2id\" Note The search will be performed against the __outline index field of the product document. Filtering by Price This filter will include only the products, the price of which matches the specified value or range: filter: \"price.{currency}.{pricelist?}:{range expression}\" filter: \"price.usd:(TO 100]\" filter: \"price.usd.pricelist_1:(20 TO 100]\" Keep only products that with at least one price set: filter: \"is:priced Note The search will be performed against the price_{currency} and price_{currency}_{pricelist} index fields of the product document. Note Only the indexed prices may be used for filtration. Scoped prices based on user groups or dynamic expressions temporary do not support filtration. Filtering by SKU Use this filter to keep only the product that matches the specified SKU: filter: \"sku:DLL-65789352 Filtering Products or Variations This includes only either the products or variations in the result. If not set, it will return both types. filter: \"is:product status:visible\" filter: \"is:variation status:hidden\" Example Displaying products and variations in a list from a specific category: query { produc ts ( s t oreId : \"B2B-store\" cul ture Name : \"en-US\" f irs t : 20 a fter : \"0\" f il ter : \"status:hidden,visible category.path:7829d35f417e4dd98851f51322f32c23/4fbaca886f014767a52f3f38b9df648f\" ) { i te ms { na me } t o tal Cou nt }} Filtering by Custom Properties Keep only the products or variation with the custom attribute matching the specified value or range: filter: \"properties.{property name}: {value} filter: \"properties.color:red To use property name contains spaces need to use the following syntax with escaped double quotes filter= \"\\\"processor core (ghz)\\\":\\\"1.8 GHz Intel GTX Quad-Core\\\"\" For numeric and date time properties you might use range filter filter: \"length:(10 TO 20)\" filter: \"publishDate:(TO \\\"2020-01-28\\\")\" Note All product custom properties are stored in the index as fields with the same names as the base properties have ( {property.name}:{property.value} ). Filtering by Product Availability Keep only the products or variations with the availability matching the specified value or range: filter: \"available_in:{warehouse}\" filter: \"available_in:my-warehouse\" Sorting By default, search results are sorted descending by their relevancy with respect to the provided text (that is their \u201cscore\u201d). An alternative sorting can be specified via the sort query parameter, which has the {field}:{asc|desc} structure. You can combine multiple sort expression using ; (semicolon): sort: \"priority:desc;price_usd;score\"","title":"Filtering"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#filtering","text":"The section below explains you how to manage the filtering process in the most frequently occuring scenarios.","title":"Filtering"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#filtering-by-category","text":"You can also filter products that belong to the exactly specified category path. filter: \"category.path:{catalog id/category path}\" filter: \"category.path:catalogId/cat1d1/cat2id\" Note The search will be performed against the __path index field of the product document. Filter by category subtrees, keep only the products that belong to the specified Category or any of its descendant categories. filter: \"category.subtree:{catalog id/category path}\" filter: \"category.subtree:catalogId/cat1d1/cat2id\" Note The search will be performed against the __outline index field of the product document.","title":"Filtering by Category"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#filtering-by-price","text":"This filter will include only the products, the price of which matches the specified value or range: filter: \"price.{currency}.{pricelist?}:{range expression}\" filter: \"price.usd:(TO 100]\" filter: \"price.usd.pricelist_1:(20 TO 100]\" Keep only products that with at least one price set: filter: \"is:priced Note The search will be performed against the price_{currency} and price_{currency}_{pricelist} index fields of the product document. Note Only the indexed prices may be used for filtration. Scoped prices based on user groups or dynamic expressions temporary do not support filtration.","title":"Filtering by Price"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#filtering-by-sku","text":"Use this filter to keep only the product that matches the specified SKU: filter: \"sku:DLL-65789352","title":"Filtering by SKU"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#filtering-products-or-variations","text":"This includes only either the products or variations in the result. If not set, it will return both types. filter: \"is:product status:visible\" filter: \"is:variation status:hidden\"","title":"Filtering Products or Variations"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#example","text":"Displaying products and variations in a list from a specific category: query { produc ts ( s t oreId : \"B2B-store\" cul ture Name : \"en-US\" f irs t : 20 a fter : \"0\" f il ter : \"status:hidden,visible category.path:7829d35f417e4dd98851f51322f32c23/4fbaca886f014767a52f3f38b9df648f\" ) { i te ms { na me } t o tal Cou nt }}","title":"Example"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#filtering-by-custom-properties","text":"Keep only the products or variation with the custom attribute matching the specified value or range: filter: \"properties.{property name}: {value} filter: \"properties.color:red To use property name contains spaces need to use the following syntax with escaped double quotes filter= \"\\\"processor core (ghz)\\\":\\\"1.8 GHz Intel GTX Quad-Core\\\"\" For numeric and date time properties you might use range filter filter: \"length:(10 TO 20)\" filter: \"publishDate:(TO \\\"2020-01-28\\\")\" Note All product custom properties are stored in the index as fields with the same names as the base properties have ( {property.name}:{property.value} ).","title":"Filtering by Custom Properties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#filtering-by-product-availability","text":"Keep only the products or variations with the availability matching the specified value or range: filter: \"available_in:{warehouse}\" filter: \"available_in:my-warehouse\"","title":"Filtering by Product Availability"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/04-filtering/#sorting","text":"By default, search results are sorted descending by their relevancy with respect to the provided text (that is their \u201cscore\u201d). An alternative sorting can be specified via the sort query parameter, which has the {field}:{asc|desc} structure. You can combine multiple sort expression using ; (semicolon): sort: \"priority:desc;price_usd;score\"","title":"Sorting"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/05-facets/","text":"Facets Faceted search (sometimes also called faceted navigation) allows users to navigate through a web site by applying filters for categories, attributes, price ranges and so on. The main idea behind faceted search is to present the attributes of the documents of the previous search result as filters, which can be used by the user to narrow down search results along with calculate statistical counts to aid. Facet calculation is requested by providing facet expression via the facet query parameter. Consider for example the following two facets: facet: \"color price:[TO 100),[100 TO 200])\" The resulting json would be like seen here: \"data\" : { \"products\" : { \"totalCount\" : 182 , \"items\" : [ ... ], \"range_facets\" : [ { \"name\" : \"price_*-100_100-200\" , \"ranges\" : [ { \"from\" : 0 , \"to\" : 100 , \"count\" : 5959 , \"includeTo\" : false , \"includeFrom\" : true }, { \"from\" : 100 , \"to\" : 200 , \"count\" : 2143 , \"includeTo\" : true , \"includeFrom\" : true } ] } ], \"term_facets\" : [ { \"name\" : \"color\" , \"terms\" : [ { \"term\" : \"EXPRESSO\" , \"count\" : 2343 }, { \"term\" : \"Sierra Brown\" , \"count\" : 362 }, ... }] } } TermFacet Expression To retrieve facet counts for all occurring values of a product document field the following notations can be applied: facet: \"category.path\" Counts the products of all categories. facet: \"{propertyName}\" facet: \"properties.{propertyName}\" Counts the product documents for all occurring values of custom properties. TermFacet Result The term type facets provide the counts for each of the different values the query parameter happens to have. name - represents the key of requested facet taken from facet expression. terms.term - one of the values for the field specified in facet expression for which at least one product could be found terms.count - amount of products for which the term applies terms.isSelected - flag indicates that requested facet term is used in filter expression, in order to simplify displaying the already selected facet terms on the frontend. RangeFacet Expression To aggregate facet counts across ranges of values, the range qualifier can be applied analogous to the filter parameters. The range notation is applicable to the date, time, datetime, number and money type fields. facet: \"price.{currency}:[TO 100),[100 TO 200])\" Counts the products whose price falls in one of the specified ranges facet: \"properties.{propertyName}[1 TO 100)\" Counts the products whose values of the custom property fall in one of the specified ranges RangeFacet result The range facet type counts the products for which the query value is a range specified in the range expression. Range facets are typically used to determine the minimum and maximum value for example product prices to filter products by price with a range slider. name : represents the key of requested facet taken from facet expression and build from range parameters concatenated by _ . e.g price_*-100_100-200 ranges.from : the range\u2019s lower endpoint in number format ranges.to : the range\u2019s upper endpoint in string format ranges.count : amount of products fall into the specified range ranges.includeTo : flag indicates that lower bound is included ranges.includeFrom : flag indicates that upper bound is included ranges.isSelected : flag indicates that requested facet term is used in filter expression, in order to simplify displaying the already selected facet terms on the frontend. Querying Product Breadcrumbs When querying breadcrumbs of the product make sure your store's SEO Links setting is not set to None , otherwise breadcrumbs for the store would not be created. To check the setting go to Store - select your store - Settings - SEO - SEO Links.","title":"Facets"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/05-facets/#facets","text":"Faceted search (sometimes also called faceted navigation) allows users to navigate through a web site by applying filters for categories, attributes, price ranges and so on. The main idea behind faceted search is to present the attributes of the documents of the previous search result as filters, which can be used by the user to narrow down search results along with calculate statistical counts to aid. Facet calculation is requested by providing facet expression via the facet query parameter. Consider for example the following two facets: facet: \"color price:[TO 100),[100 TO 200])\" The resulting json would be like seen here: \"data\" : { \"products\" : { \"totalCount\" : 182 , \"items\" : [ ... ], \"range_facets\" : [ { \"name\" : \"price_*-100_100-200\" , \"ranges\" : [ { \"from\" : 0 , \"to\" : 100 , \"count\" : 5959 , \"includeTo\" : false , \"includeFrom\" : true }, { \"from\" : 100 , \"to\" : 200 , \"count\" : 2143 , \"includeTo\" : true , \"includeFrom\" : true } ] } ], \"term_facets\" : [ { \"name\" : \"color\" , \"terms\" : [ { \"term\" : \"EXPRESSO\" , \"count\" : 2343 }, { \"term\" : \"Sierra Brown\" , \"count\" : 362 }, ... }] } }","title":"Facets"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/05-facets/#termfacet-expression","text":"To retrieve facet counts for all occurring values of a product document field the following notations can be applied: facet: \"category.path\" Counts the products of all categories. facet: \"{propertyName}\" facet: \"properties.{propertyName}\" Counts the product documents for all occurring values of custom properties.","title":"TermFacet Expression"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/05-facets/#termfacet-result","text":"The term type facets provide the counts for each of the different values the query parameter happens to have. name - represents the key of requested facet taken from facet expression. terms.term - one of the values for the field specified in facet expression for which at least one product could be found terms.count - amount of products for which the term applies terms.isSelected - flag indicates that requested facet term is used in filter expression, in order to simplify displaying the already selected facet terms on the frontend.","title":"TermFacet Result"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/05-facets/#rangefacet-expression","text":"To aggregate facet counts across ranges of values, the range qualifier can be applied analogous to the filter parameters. The range notation is applicable to the date, time, datetime, number and money type fields. facet: \"price.{currency}:[TO 100),[100 TO 200])\" Counts the products whose price falls in one of the specified ranges facet: \"properties.{propertyName}[1 TO 100)\" Counts the products whose values of the custom property fall in one of the specified ranges","title":"RangeFacet Expression"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/05-facets/#rangefacet-result","text":"The range facet type counts the products for which the query value is a range specified in the range expression. Range facets are typically used to determine the minimum and maximum value for example product prices to filter products by price with a range slider. name : represents the key of requested facet taken from facet expression and build from range parameters concatenated by _ . e.g price_*-100_100-200 ranges.from : the range\u2019s lower endpoint in number format ranges.to : the range\u2019s upper endpoint in string format ranges.count : amount of products fall into the specified range ranges.includeTo : flag indicates that lower bound is included ranges.includeFrom : flag indicates that upper bound is included ranges.isSelected : flag indicates that requested facet term is used in filter expression, in order to simplify displaying the already selected facet terms on the frontend.","title":"RangeFacet result"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/05-facets/#querying-product-breadcrumbs","text":"When querying breadcrumbs of the product make sure your store's SEO Links setting is not set to None , otherwise breadcrumbs for the store would not be created. To check the setting go to Store - select your store - Settings - SEO - SEO Links.","title":"Querying Product Breadcrumbs"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/06-multi-select-faceting-search/","text":"Muti Select Faceting Search This policy allows you to select multiple values of the same facet (e.g using a checkbox). You can read more about how the muti select faceting search work here and here . The multi select faceting search policy is enabled by default; you do not need any extra parameters or settings to activate it.","title":"Multi Select Faceting Search"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/examples/06-multi-select-faceting-search/#muti-select-faceting-search","text":"This policy allows you to select multiple values of the same facet (e.g using a checkbox). You can read more about how the muti select faceting search work here and here . The multi select faceting search policy is enabled by default; you do not need any extra parameters or settings to activate it.","title":"Muti Select Faceting Search"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/01-ProductType/","text":"ProductType The chart below shows the ProductType parameter and all its child parameters and options: Schema Fields # Name Type Description 1 id StringGraphType The unique ID of the product 2 code StringGraphType The product SKU 3 catalogId StringGraphType CatalogId of the product 4 category CategoryType Field to resolve category of the requested product 5 name StringGraphType Name of the product 6 descriptions List of DesciptionType Reviews of product 7 productType StringGraphType The type of product 8 slug StringGraphType Url of the product 9 metaDescription StringGraphType Meta description of the product 10 metaKeywords StringGraphType Meta keywords of the product 11 metaTitle StringGraphType Meta title of the product 12 imgSrc StringGraphType Main image of the product 13 outerId StringGraphType Category outer Id 14 brandName StringGraphType Brand name of the product 15 masterVariation VariationType Main variation of the product 16 variations List of VariationType Product variations 17 availabilityData AvailabilityDataType Product availability information 18 images List of ImageType Product images 19 prices List of PriceType Product prices 20 properties List of PropertyType Product properties 21 assets List of AssetType Product assets 22 outlines List of OutlineType Category outlines 23 seoInfos List of SeoInfoType SEO information of the product 24 associations ProductAssociationType Product associations 25 breadcrumbs BreadcrumbType Product navigation information 26 videos VideoType Product videos 27 keyProperties List of PropertyType Configurable list of properties Product Key Properties The ProductType query has a special configurable field, keyProperties . To make a catalog property appear in the keyProperties list, you need to configure it in the Catalog module by adding the KeyProperty attribute to Property Attributes . KeyProperties are auto sorted by the attribute value in the ascending order. The keyProperties field can be limited by the take argument. Example The following query enables showing only first three key properties: query { produc ts ( s t oreId : \"B2B-store\" cul ture Name : \"en-US\" ) { i te ms { keyProper t ies ( ta ke : 3 ) { na me value } } } }","title":"ProductType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/01-ProductType/#producttype","text":"The chart below shows the ProductType parameter and all its child parameters and options:","title":"ProductType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/01-ProductType/#schema-fields","text":"# Name Type Description 1 id StringGraphType The unique ID of the product 2 code StringGraphType The product SKU 3 catalogId StringGraphType CatalogId of the product 4 category CategoryType Field to resolve category of the requested product 5 name StringGraphType Name of the product 6 descriptions List of DesciptionType Reviews of product 7 productType StringGraphType The type of product 8 slug StringGraphType Url of the product 9 metaDescription StringGraphType Meta description of the product 10 metaKeywords StringGraphType Meta keywords of the product 11 metaTitle StringGraphType Meta title of the product 12 imgSrc StringGraphType Main image of the product 13 outerId StringGraphType Category outer Id 14 brandName StringGraphType Brand name of the product 15 masterVariation VariationType Main variation of the product 16 variations List of VariationType Product variations 17 availabilityData AvailabilityDataType Product availability information 18 images List of ImageType Product images 19 prices List of PriceType Product prices 20 properties List of PropertyType Product properties 21 assets List of AssetType Product assets 22 outlines List of OutlineType Category outlines 23 seoInfos List of SeoInfoType SEO information of the product 24 associations ProductAssociationType Product associations 25 breadcrumbs BreadcrumbType Product navigation information 26 videos VideoType Product videos 27 keyProperties List of PropertyType Configurable list of properties","title":"Schema Fields"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/01-ProductType/#product-key-properties","text":"The ProductType query has a special configurable field, keyProperties . To make a catalog property appear in the keyProperties list, you need to configure it in the Catalog module by adding the KeyProperty attribute to Property Attributes . KeyProperties are auto sorted by the attribute value in the ascending order. The keyProperties field can be limited by the take argument.","title":"Product Key Properties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/01-ProductType/#example","text":"The following query enables showing only first three key properties: query { produc ts ( s t oreId : \"B2B-store\" cul ture Name : \"en-US\" ) { i te ms { keyProper t ies ( ta ke : 3 ) { na me value } } } }","title":"Example"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/02-CategoryType/","text":"CategoryType The chart below shows the CategoryType parameter and all its child parameters and options: Schema Fields # Name Type Description 1 id StringGraphType Id of category 2 code StringGraphType SKU of category 3 name StringGraphType Name of category 4 slug StringGraphType Url of category 5 parent CategoryType Field to resolve parent category 6 hasParent BooleanGraphType Indicates if category has parent 7 images List of ImageType Category images 8 outlines List of OutlineType Category outlines 9 seoInfos List of SeoInfoType SEO information of the category 9 properties List of PropertyType Properties of the category","title":"CategoryType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/02-CategoryType/#categorytype","text":"The chart below shows the CategoryType parameter and all its child parameters and options:","title":"CategoryType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/02-CategoryType/#schema-fields","text":"# Name Type Description 1 id StringGraphType Id of category 2 code StringGraphType SKU of category 3 name StringGraphType Name of category 4 slug StringGraphType Url of category 5 parent CategoryType Field to resolve parent category 6 hasParent BooleanGraphType Indicates if category has parent 7 images List of ImageType Category images 8 outlines List of OutlineType Category outlines 9 seoInfos List of SeoInfoType SEO information of the category 9 properties List of PropertyType Properties of the category","title":"Schema Fields"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/03-FulfillmentCenterType/","text":"FulfillmentCenterType Schema Fields # Name Type Description 1 id StringGraphType Fulfillment center ID 2 name StringGraphType Fulfillment center name 4 description StringGraphType Full description of the fulfillment center 5 shortDescription StringGraphType Short description of the fulfillment center 6 geoLocation StringGraphType Fulfillment center geo location. Latitude and longitude are separated with a comma without spaces, e.g. \"41.40338,12.17403\" 9 outerId StringGraphType Fulfillment center outer ID 9 address FulfillmentCenterAddressType Fulfillment center address 9 nearest List of FulfillmentCenterType Contains the top 10 nearest fulfillment centers ordered by distance between geo-coordinates. Accepts the take (int) argument to limit the selection","title":"FulfullmentCenterType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/03-FulfillmentCenterType/#fulfillmentcentertype","text":"","title":"FulfillmentCenterType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/objects/03-FulfillmentCenterType/#schema-fields","text":"# Name Type Description 1 id StringGraphType Fulfillment center ID 2 name StringGraphType Fulfillment center name 4 description StringGraphType Full description of the fulfillment center 5 shortDescription StringGraphType Short description of the fulfillment center 6 geoLocation StringGraphType Fulfillment center geo location. Latitude and longitude are separated with a comma without spaces, e.g. \"41.40338,12.17403\" 9 outerId StringGraphType Fulfillment center outer ID 9 address FulfillmentCenterAddressType Fulfillment center address 9 nearest List of FulfillmentCenterType Contains the top 10 nearest fulfillment centers ordered by distance between geo-coordinates. Accepts the take (int) argument to limit the selection","title":"Schema Fields"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/01-product/","text":"Product This query allows you to get a product by its ID and calculate all fields based on the parameters being sent. Definition product(id: !string, storeId: !string, userId: !string, currencyCode: string, cultureName: string) Arguments # Name Type Description 1 id Non null StringGraphType Product of the Id 2 storeId Non null StringGraphType Store Id 3 userId Non null StringGraphType Current user Id 4 currencyCode StringGraphType Currency code (e.g. \"USD\") 5 cultureName StringGraphType Culture name (e.g. \"en-US\") Example { produc t ( id : \"8b7b07c165924a879392f4f51a6f7ce0\" s t oreId : \"Electronics\" userId : \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cul ture Name : \"en-us\" curre n cyCode : \"USD\" ) { id na me } } Displaying Tier Pricing on Product Page query { produc t ( id : \"9cbd8f316e254a679ba34a900fccb076\" s t oreId : \"Electronics\" curre n cyCode : \"USD\" ) { prices { mi n Qua nt i t y t ierPrices { qua nt i t y price { amou nt } } } } }","title":"Product"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/01-product/#product","text":"This query allows you to get a product by its ID and calculate all fields based on the parameters being sent.","title":"Product"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/01-product/#definition","text":"product(id: !string, storeId: !string, userId: !string, currencyCode: string, cultureName: string)","title":"Definition"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/01-product/#arguments","text":"# Name Type Description 1 id Non null StringGraphType Product of the Id 2 storeId Non null StringGraphType Store Id 3 userId Non null StringGraphType Current user Id 4 currencyCode StringGraphType Currency code (e.g. \"USD\") 5 cultureName StringGraphType Culture name (e.g. \"en-US\")","title":"Arguments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/01-product/#example","text":"{ produc t ( id : \"8b7b07c165924a879392f4f51a6f7ce0\" s t oreId : \"Electronics\" userId : \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cul ture Name : \"en-us\" curre n cyCode : \"USD\" ) { id na me } }","title":"Example"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/01-product/#displaying-tier-pricing-on-product-page","text":"query { produc t ( id : \"9cbd8f316e254a679ba34a900fccb076\" s t oreId : \"Electronics\" curre n cyCode : \"USD\" ) { prices { mi n Qua nt i t y t ierPrices { qua nt i t y price { amou nt } } } } }","title":"Displaying Tier Pricing on Product Page"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/02-products/","text":"Products This connection allows you to search for products. Definition products(productIds: string[], storeId: !string, userId: !string, currencyCode: string, cultureName: string, query: string, filter: string, fuzzy: bool, fuzzyLevel: int, facet: string, sort: string) Arguments # Name Type Description 1 productIds List of StringGraphType Products Ids 2 storeId Non null StringGraphType Store Id 3 userId Non null StringGraphType Current user Id 4 currencyCode StringGraphType Currency code (e.g. \"USD\") 5 cultureName StringGraphType Culture name (e.g. \"en-US\") 6 query StringGraphType The query parameter performs the full-text search 7 filter StringGraphType This parameter applies a filter to the query results 8 fuzzy BooleanGraphType When the fuzzy query parameter is set to true the search endpoint will also return products that contain slight differences to the search text 9 fuzzyLevel IntGraphType The fuzziness level is quantified in terms of the Damerau-Levenshtein distance, this distance being the number of operations needed to transform one word into another 10 facet StringGraphType Facets calculate statistical counts to aid in faceted navigation 11 sort StringGraphType The sort expression Example { produc ts ( s t oreId : \"Electronics\" userId : \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cul ture Name : \"en-Us\" curre n cyCode : \"USD\" f irs t : 10 a fter : \"10\" ) { i te ms { id code } pageI nf o { hasNex t Page s tart Cursor } } }","title":"Products"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/02-products/#products","text":"This connection allows you to search for products.","title":"Products"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/02-products/#definition","text":"products(productIds: string[], storeId: !string, userId: !string, currencyCode: string, cultureName: string, query: string, filter: string, fuzzy: bool, fuzzyLevel: int, facet: string, sort: string)","title":"Definition"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/02-products/#arguments","text":"# Name Type Description 1 productIds List of StringGraphType Products Ids 2 storeId Non null StringGraphType Store Id 3 userId Non null StringGraphType Current user Id 4 currencyCode StringGraphType Currency code (e.g. \"USD\") 5 cultureName StringGraphType Culture name (e.g. \"en-US\") 6 query StringGraphType The query parameter performs the full-text search 7 filter StringGraphType This parameter applies a filter to the query results 8 fuzzy BooleanGraphType When the fuzzy query parameter is set to true the search endpoint will also return products that contain slight differences to the search text 9 fuzzyLevel IntGraphType The fuzziness level is quantified in terms of the Damerau-Levenshtein distance, this distance being the number of operations needed to transform one word into another 10 facet StringGraphType Facets calculate statistical counts to aid in faceted navigation 11 sort StringGraphType The sort expression","title":"Arguments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/02-products/#example","text":"{ produc ts ( s t oreId : \"Electronics\" userId : \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cul ture Name : \"en-Us\" curre n cyCode : \"USD\" f irs t : 10 a fter : \"10\" ) { i te ms { id code } pageI nf o { hasNex t Page s tart Cursor } } }","title":"Example"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/03-categories/","text":"Categories This connection allows you to search for categories. Definition categories(categoryIds: string[], storeId: !string, userId: !string, currencyCode: string, cultureName: string, query: string, filter: string, fuzzy: bool, fuzzyLevel: int, facet: string, sort: string)` Arguments # Name Type Description 1 categoryIds List of StringGraphType Categories Ids 2 storeId Non null StringGraphType Store Id 3 userId Non null StringGraphType Current user Id 4 currencyCode StringGraphType Currency code (e.g. \"USD\") 5 cultureName StringGraphType Culture name (e.g. \"en-US\") 6 query StringGraphType The query parameter performs the full-text search 7 filter StringGraphType This parameter applies a filter to the query results 8 fuzzy BooleanGraphType When the fuzzy query parameter is set to true the search endpoint will also return products that contain slight differences to the search text 9 fuzzyLevel IntGraphType The fuzziness level is quantified in terms of the Damerau-Levenshtein distance, this distance being the number of operations needed to transform one word into another 10 facet StringGraphType Facets calculate statistical counts to aid in faceted navigation 11 sort StringGraphType The sort expression Example { ca te gories( s t oreId : \"Electronics\" userId : \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cul ture Name : \"en-Us\" curre n cyCode : \"USD\" f irs t : 10 a fter : \"10\" ) { i te ms { id na me hasPare nt } pageI nf o { hasNex t Page s tart Cursor } } }","title":"Categories"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/03-categories/#categories","text":"This connection allows you to search for categories.","title":"Categories"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/03-categories/#definition","text":"categories(categoryIds: string[], storeId: !string, userId: !string, currencyCode: string, cultureName: string, query: string, filter: string, fuzzy: bool, fuzzyLevel: int, facet: string, sort: string)`","title":"Definition"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/03-categories/#arguments","text":"# Name Type Description 1 categoryIds List of StringGraphType Categories Ids 2 storeId Non null StringGraphType Store Id 3 userId Non null StringGraphType Current user Id 4 currencyCode StringGraphType Currency code (e.g. \"USD\") 5 cultureName StringGraphType Culture name (e.g. \"en-US\") 6 query StringGraphType The query parameter performs the full-text search 7 filter StringGraphType This parameter applies a filter to the query results 8 fuzzy BooleanGraphType When the fuzzy query parameter is set to true the search endpoint will also return products that contain slight differences to the search text 9 fuzzyLevel IntGraphType The fuzziness level is quantified in terms of the Damerau-Levenshtein distance, this distance being the number of operations needed to transform one word into another 10 facet StringGraphType Facets calculate statistical counts to aid in faceted navigation 11 sort StringGraphType The sort expression","title":"Arguments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/03-categories/#example","text":"{ ca te gories( s t oreId : \"Electronics\" userId : \"d97ee2c7-e29d-440a-a43a-388eb5586087\" cul ture Name : \"en-Us\" curre n cyCode : \"USD\" f irs t : 10 a fter : \"10\" ) { i te ms { id na me hasPare nt } pageI nf o { hasNex t Page s tart Cursor } } }","title":"Example"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/04-properties/","text":"Properties This connection allows you to search for catalog property metadata. Definition properties(storeId: !string, types: [PropertyType], filter: string, cultureName: string) Arguments # Name Type Description 1 storeId Non null StringGraphType Store Id 2 types ListGraphType of PropertyTypeEnum's The owner types (Catalog, Category, Product, Variation or combinations) 3 filter StringGraphType This parameter applies a filter to the query results 4 cultureName StringGraphType Culture name (e.g. \"en-US\") Example 1: Enlisting Property Metadata with Dictionary Items, Specified Culture, Specific Name and Types: { proper t ies (s t oreId : \"Electronics\" , cul ture Name : \"de-DE\" , f il ter : \"keyword:Brand\" , t ypes :[ PRODUCT , VARIATION ] ) { i te ms { na me t ype id mul t ivalue proper t yDic t I te ms { t o tal Cou nt i te ms { value } } } } } Example 2: Getting Properties for Specific Category: { proper t ies (s t oreId : \"Electronics\" , f il ter : \"categoryId:53e239451c844442a3b2fe9aa82d95c8\" ) { i te ms { na me t ype id mul t ivalue proper t yDic t I te ms { t o tal Cou nt i te ms { value } } } } }","title":"Properties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/04-properties/#properties","text":"This connection allows you to search for catalog property metadata.","title":"Properties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/04-properties/#definition","text":"properties(storeId: !string, types: [PropertyType], filter: string, cultureName: string)","title":"Definition"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/04-properties/#arguments","text":"# Name Type Description 1 storeId Non null StringGraphType Store Id 2 types ListGraphType of PropertyTypeEnum's The owner types (Catalog, Category, Product, Variation or combinations) 3 filter StringGraphType This parameter applies a filter to the query results 4 cultureName StringGraphType Culture name (e.g. \"en-US\")","title":"Arguments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/04-properties/#example-1-enlisting-property-metadata-with-dictionary-items-specified-culture-specific-name-and-types","text":"{ proper t ies (s t oreId : \"Electronics\" , cul ture Name : \"de-DE\" , f il ter : \"keyword:Brand\" , t ypes :[ PRODUCT , VARIATION ] ) { i te ms { na me t ype id mul t ivalue proper t yDic t I te ms { t o tal Cou nt i te ms { value } } } } }","title":"Example 1: Enlisting Property Metadata with Dictionary Items, Specified Culture, Specific Name and Types:"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/04-properties/#example-2-getting-properties-for-specific-category","text":"{ proper t ies (s t oreId : \"Electronics\" , f il ter : \"categoryId:53e239451c844442a3b2fe9aa82d95c8\" ) { i te ms { na me t ype id mul t ivalue proper t yDic t I te ms { t o tal Cou nt i te ms { value } } } } }","title":"Example 2: Getting Properties for Specific Category:"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/05-property/","text":"Property This connection allows you to get metadata for a specific catalog property. Definition property(id: !string, cultureName: string) Arguments # Name Type Description 1 id Non null StringGraphType Property id 2 cultureName StringGraphType Culture name (e.g. \"en-US\") Example Getting a single property with dictionary items for a specific culture: { proper t y (id : \"43d14478-d142-4a65-956f-0a308d0c4ee8\" , cul ture Name : \"de-DE\" ) { proper t yDic t I te ms { i te ms { value } } } }","title":"Property"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/05-property/#property","text":"This connection allows you to get metadata for a specific catalog property.","title":"Property"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/05-property/#definition","text":"property(id: !string, cultureName: string)","title":"Definition"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/05-property/#arguments","text":"# Name Type Description 1 id Non null StringGraphType Property id 2 cultureName StringGraphType Culture name (e.g. \"en-US\")","title":"Arguments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/05-property/#example","text":"Getting a single property with dictionary items for a specific culture: { proper t y (id : \"43d14478-d142-4a65-956f-0a308d0c4ee8\" , cul ture Name : \"de-DE\" ) { proper t yDic t I te ms { i te ms { value } } } }","title":"Example"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/06-fulfillment-center/","text":"Fulfillment Center This query allows you to get a fulfillment center by its ID. Definition fulfillmentCenter(id: !string) Arguments # Name Type Description 1 id Non null StringGraphType Fulfillment center id Example Getting a single fulfillment center with the top three nearest fulfillment centers: query { fulfillmentCenter ( id : \"vendor-fulfillment\" ) { id name description shortDescription outerId geoLocation address { city } nearest ( take : 3 ) { name id } } }","title":"Fulfullment Center"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/06-fulfillment-center/#fulfillment-center","text":"This query allows you to get a fulfillment center by its ID.","title":"Fulfillment Center"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/06-fulfillment-center/#definition","text":"fulfillmentCenter(id: !string)","title":"Definition"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/06-fulfillment-center/#arguments","text":"# Name Type Description 1 id Non null StringGraphType Fulfillment center id","title":"Arguments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/06-fulfillment-center/#example","text":"Getting a single fulfillment center with the top three nearest fulfillment centers: query { fulfillmentCenter ( id : \"vendor-fulfillment\" ) { id name description shortDescription outerId geoLocation address { city } nearest ( take : 3 ) { name id } } }","title":"Example"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/07-fulfillment-centers/","text":"Fulfillment Centers This connection allows you to search for fulfillment centers. Definition fulfillmentCenters(after: String, first: Int, storeId: String, query: String, sort: String, fulfillmentCenterIds: [String]) Arguments # Name Type Description 1 first IntGraphType Pagination size. Default is 20 2 after StringGraphType Pagination cursor 3 sort StringGraphType The sort expression 4 storeId StringGraphType Search fulfillment centers by store ID 5 query StringGraphType Search by fulfillment center name 6 fulfillmentCenterIds List of StringGraphType Get fulfillment centers by provided IDs. Note: this argument is exclusive, if set it will override all other arguments Example 1 Getting two fulfillment centers by known IDs: query { fulfillmentCenters ( fulfillmentCenterIds : [ \"vendor-fulfillment\" , \"los-angeles-fulfillment\" ] ) { totalCount items { id name shortDescription address { city countryCode } } } } Example 2 Getting all fulfillment centers attached to B2B Store: query { fulfillmentCenters ( storeId : \"B2B-store\" ) { totalCount items { id name outerId geoLocation } } }","title":"Fulfullment Centers"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/07-fulfillment-centers/#fulfillment-centers","text":"This connection allows you to search for fulfillment centers.","title":"Fulfillment Centers"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/07-fulfillment-centers/#definition","text":"fulfillmentCenters(after: String, first: Int, storeId: String, query: String, sort: String, fulfillmentCenterIds: [String])","title":"Definition"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/07-fulfillment-centers/#arguments","text":"# Name Type Description 1 first IntGraphType Pagination size. Default is 20 2 after StringGraphType Pagination cursor 3 sort StringGraphType The sort expression 4 storeId StringGraphType Search fulfillment centers by store ID 5 query StringGraphType Search by fulfillment center name 6 fulfillmentCenterIds List of StringGraphType Get fulfillment centers by provided IDs. Note: this argument is exclusive, if set it will override all other arguments","title":"Arguments"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/07-fulfillment-centers/#example-1","text":"Getting two fulfillment centers by known IDs: query { fulfillmentCenters ( fulfillmentCenterIds : [ \"vendor-fulfillment\" , \"los-angeles-fulfillment\" ] ) { totalCount items { id name shortDescription address { city countryCode } } } }","title":"Example 1"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Catalog/queries/07-fulfillment-centers/#example-2","text":"Getting all fulfillment centers attached to B2B Store: query { fulfillmentCenters ( storeId : \"B2B-store\" ) { totalCount items { id name outerId geoLocation } } }","title":"Example 2"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/overview/","text":"Order xAPI The Order xAPI provides high performance API for order data with the following key features: Getting and searching orders Basic order workflow operations Jump to any of the following sections to see what exactly this API does: Queries Mutations Objects","title":"Overview"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/overview/#order-xapi","text":"The Order xAPI provides high performance API for order data with the following key features: Getting and searching orders Basic order workflow operations Jump to any of the following sections to see what exactly this API does: Queries Mutations Objects","title":"Order xAPI"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/01-mutation-list/","text":"Mutation List # Endpoint Arguments Description 1 createOrderFromCart !cartId Creates an order from an existing cart 2 changeOrderStatus !orderId !status Changes order status 3 confirmOrderPayment payment { id sum caurrency \u2026} Confirms order payment 4 cancelOrderPayment payment { id sum caurrency \u2026} Cancels order payment 5 updateOrderDynamicProperties !dynamicProperties Updates dynamic properties within an order 6 updateOrderItemDynamicProperties !lineItemId !dynamicProperties Updates dynamic properties within order items 7 updateOrderShipmentDynamicProperties !shipmentId !dynamicProperties Updates dynamic properties within order shipping methods 8 updateOrderPaymentDynamicProperties !paymentId !dynamicProperties Updates dynamic properties within order payment methods 9 initializePayment orderId !paymentId Initiates payment processing 10 authorizePayment orderId !paymentId parameters { key value } Finalizes the first step of payment processing 11 addOrUpdateOrderPayment !orderId !payment ( type ) Adds or updates payment method for an order Note The Arguments column lists additional arguments; those marked with an exclamation mark are required.","title":"Mutation List"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/01-mutation-list/#mutation-list","text":"# Endpoint Arguments Description 1 createOrderFromCart !cartId Creates an order from an existing cart 2 changeOrderStatus !orderId !status Changes order status 3 confirmOrderPayment payment { id sum caurrency \u2026} Confirms order payment 4 cancelOrderPayment payment { id sum caurrency \u2026} Cancels order payment 5 updateOrderDynamicProperties !dynamicProperties Updates dynamic properties within an order 6 updateOrderItemDynamicProperties !lineItemId !dynamicProperties Updates dynamic properties within order items 7 updateOrderShipmentDynamicProperties !shipmentId !dynamicProperties Updates dynamic properties within order shipping methods 8 updateOrderPaymentDynamicProperties !paymentId !dynamicProperties Updates dynamic properties within order payment methods 9 initializePayment orderId !paymentId Initiates payment processing 10 authorizePayment orderId !paymentId parameters { key value } Finalizes the first step of payment processing 11 addOrUpdateOrderPayment !orderId !payment ( type ) Adds or updates payment method for an order Note The Arguments column lists additional arguments; those marked with an exclamation mark are required.","title":"Mutation List"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/02-create-order-from-cart/","text":"CreateOrderFromCart This mutation creates an order from the cart with a specific ID. Query mutation { createOrderFromCart( command: { cartId: \"05479fa6-9b6f-4028-94b1-cda21447e268\" } ) { id items { id sku name } total { amount } } }","title":"CreateOrderFromCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/02-create-order-from-cart/#createorderfromcart","text":"This mutation creates an order from the cart with a specific ID.","title":"CreateOrderFromCart"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/02-create-order-from-cart/#query","text":"mutation { createOrderFromCart( command: { cartId: \"05479fa6-9b6f-4028-94b1-cda21447e268\" } ) { id items { id sku name } total { amount } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/03-change-order-status/","text":"ChangeOrderStatus This mutation changes order status. Query mutation { changeOrderStatus( command: { orderId: \"1672428e-52fe-4092-8380-7604c3637f91\" status: \"Approved\"} ) }","title":"ChangeOrderStatus"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/03-change-order-status/#changeorderstatus","text":"This mutation changes order status.","title":"ChangeOrderStatus"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/03-change-order-status/#query","text":"mutation { changeOrderStatus( command: { orderId: \"1672428e-52fe-4092-8380-7604c3637f91\" status: \"Approved\"} ) }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/04-confirm-order-payment/","text":"ConfirmOrderPayment This mutation confirms order payment. Query mutation { confirmOrderPayment( command: { payment: { orderId: \"9d27c868-2e31-4ab4-861b-909bc3f86657\" operationType: \"PaymentIn\" number: \"PA1508131823002\" isApproved: false status: \"Authorized\" comment: null isCancelled: false customerId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" sum: 100 currency: \"USD\" taxDetails: { name: \"State tax\", amount: 10, rate: 0.1 } taxTotal: 10 discounts: { discountAmount: 11, discountAmountWithTax: 11, currency: \"USD\" } } } ) }","title":"ConfirmOrderPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/04-confirm-order-payment/#confirmorderpayment","text":"This mutation confirms order payment.","title":"ConfirmOrderPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/04-confirm-order-payment/#query","text":"mutation { confirmOrderPayment( command: { payment: { orderId: \"9d27c868-2e31-4ab4-861b-909bc3f86657\" operationType: \"PaymentIn\" number: \"PA1508131823002\" isApproved: false status: \"Authorized\" comment: null isCancelled: false customerId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" sum: 100 currency: \"USD\" taxDetails: { name: \"State tax\", amount: 10, rate: 0.1 } taxTotal: 10 discounts: { discountAmount: 11, discountAmountWithTax: 11, currency: \"USD\" } } } ) }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/05-cancel-order-payment/","text":"CancelOrderPayment This mutation cancels order payment. Query mutation { cancelOrderPayment( command: { payment: { orderId: \"9d27c868-2e31-4ab4-861b-909bc3f86657\" operationType: \"PaymentIn\" number: \"PA1508131823002\" isApproved: false status: \"Authorized\" comment: null isCancelled: false customerId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" sum: 100 currency: \"USD\" taxDetails: { name: \"State tax\", amount: 10, rate: 0.1 } taxTotal: 10 discounts: { discountAmount: 11, discountAmountWithTax: 11, currency: \"USD\" } } } ) }","title":"CancelOrderPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/05-cancel-order-payment/#cancelorderpayment","text":"This mutation cancels order payment.","title":"CancelOrderPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/05-cancel-order-payment/#query","text":"mutation { cancelOrderPayment( command: { payment: { orderId: \"9d27c868-2e31-4ab4-861b-909bc3f86657\" operationType: \"PaymentIn\" number: \"PA1508131823002\" isApproved: false status: \"Authorized\" comment: null isCancelled: false customerId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" sum: 100 currency: \"USD\" taxDetails: { name: \"State tax\", amount: 10, rate: 0.1 } taxTotal: 10 discounts: { discountAmount: 11, discountAmountWithTax: 11, currency: \"USD\" } } } ) }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/06-update-order-dynamic-properties/","text":"UpdateOrderDynamicProperties This mutation updates dynamic properties for an order. Query mutation ($command: InputUpdateOrderDynamicPropertiesType!) { updateOrderDynamicProperties(command: $command) { dynamicProperties { name value valueType dictionaryItem { label name id } } } } Variables \"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateOrderDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/06-update-order-dynamic-properties/#updateorderdynamicproperties","text":"This mutation updates dynamic properties for an order.","title":"UpdateOrderDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/06-update-order-dynamic-properties/#query","text":"mutation ($command: InputUpdateOrderDynamicPropertiesType!) { updateOrderDynamicProperties(command: $command) { dynamicProperties { name value valueType dictionaryItem { label name id } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/06-update-order-dynamic-properties/#variables","text":"\"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/07-update-order-item-dynamic-properties/","text":"UpdateOrderItemDynamicProperties This mutation updates dynamic properties for an order item. Query mutation ($command: InputUpdateOrderItemDynamicPropertiesType!) { updateOrderItemDynamicProperties(command: $command) { items { id dynamicProperties { name value valueType dictionaryItem { label name id } } } } } Variables \"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"lineItemId\": \"dab09410-aa1a-4daf-8a32-4e41abee77b8\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateOrderItemDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/07-update-order-item-dynamic-properties/#updateorderitemdynamicproperties","text":"This mutation updates dynamic properties for an order item.","title":"UpdateOrderItemDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/07-update-order-item-dynamic-properties/#query","text":"mutation ($command: InputUpdateOrderItemDynamicPropertiesType!) { updateOrderItemDynamicProperties(command: $command) { items { id dynamicProperties { name value valueType dictionaryItem { label name id } } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/07-update-order-item-dynamic-properties/#variables","text":"\"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"lineItemId\": \"dab09410-aa1a-4daf-8a32-4e41abee77b8\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/08-update-order-shipment-dynamic-properties/","text":"UpdateOrderShipmentDynamicProperties This mutation updates dynamic properties for the order shipping method. Query mutation ($command: InputUpdateOrderShipmentDynamicPropertiesType!) { updateOrderShipmentDynamicProperties(command: $command) { shipments { id dynamicProperties { name value valueType dictionaryItem { label name id } } } } } Variables: \"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"shipmentId\": \"79b8f095-9740-4353-998b-e1c4dd577ee6\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateOrderShipmentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/08-update-order-shipment-dynamic-properties/#updateordershipmentdynamicproperties","text":"This mutation updates dynamic properties for the order shipping method.","title":"UpdateOrderShipmentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/08-update-order-shipment-dynamic-properties/#query","text":"mutation ($command: InputUpdateOrderShipmentDynamicPropertiesType!) { updateOrderShipmentDynamicProperties(command: $command) { shipments { id dynamicProperties { name value valueType dictionaryItem { label name id } } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/08-update-order-shipment-dynamic-properties/#variables","text":"\"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"shipmentId\": \"79b8f095-9740-4353-998b-e1c4dd577ee6\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables:"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/09-update-order-payment-dynamic-properties/","text":"UpdateOrderPaymentDynamicProperties This mutation updates dynamic properties for the order payment. Query mutation ($command: InputUpdateOrderPaymentDynamicPropertiesType!) { updateOrderPaymentDynamicProperties(command: $command) { inPayments { id dynamicProperties { name value valueType dictionaryItem { label name id } } } } } Variables \"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"paymentId\": \"0859f1e8-16e8-4924-808b-47e03560085d\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"UpdateOrderPaymentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/09-update-order-payment-dynamic-properties/#updateorderpaymentdynamicproperties","text":"This mutation updates dynamic properties for the order payment.","title":"UpdateOrderPaymentDynamicProperties"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/09-update-order-payment-dynamic-properties/#query","text":"mutation ($command: InputUpdateOrderPaymentDynamicPropertiesType!) { updateOrderPaymentDynamicProperties(command: $command) { inPayments { id dynamicProperties { name value valueType dictionaryItem { label name id } } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/09-update-order-payment-dynamic-properties/#variables","text":"\"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"paymentId\": \"0859f1e8-16e8-4924-808b-47e03560085d\", \"dynamicProperties\": [ { \"name\": \"Example string property\", \"value\": \"12345678\" }, { \"name\": \"Example multilanguage property\", \"locale\":\"de-DE\", \"value\": \"hallo welt\" }, { \"name\": \"Example dictionary property\", \"value\": \"578fadeb1d2a40b3b08b1daf8db09463\" } ] } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/10-initialize-payment/","text":"InitializePayment This mutation initiates payment processing. Query mutation ($command: InputInitializePaymentType!) { initializePayment(command: $command) { isSuccess errorMessage storeId paymentId orderId orderNumber paymentMethodCode paymentActionType actionRedirectUrl publicParameters { key value } } } Variables \"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"paymentId\": \"0859f1e8-16e8-4924-808b-47e03560085d\" }","title":"InitializePayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/10-initialize-payment/#initializepayment","text":"This mutation initiates payment processing.","title":"InitializePayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/10-initialize-payment/#query","text":"mutation ($command: InputInitializePaymentType!) { initializePayment(command: $command) { isSuccess errorMessage storeId paymentId orderId orderNumber paymentMethodCode paymentActionType actionRedirectUrl publicParameters { key value } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/10-initialize-payment/#variables","text":"\"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"paymentId\": \"0859f1e8-16e8-4924-808b-47e03560085d\" }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/11-authorize-payment/","text":"AuthorizePayment This mutation finalizes the first step of payment processing. Query mutation ($command: InputAuthorizePaymentType!) { authorizePayment(command: $command) { isSuccess errorMessage } } Variables \"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"paymentId\": \"0859f1e8-16e8-4924-808b-47e03560085d\", \"parameters\": [ { key: \"key1\", value: \"value1\" }, { key: \"key2\", value: \"value2\" } }","title":"AuthorizePayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/11-authorize-payment/#authorizepayment","text":"This mutation finalizes the first step of payment processing.","title":"AuthorizePayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/11-authorize-payment/#query","text":"mutation ($command: InputAuthorizePaymentType!) { authorizePayment(command: $command) { isSuccess errorMessage } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/11-authorize-payment/#variables","text":"\"command\": { \"orderId\": \"d548c750-5a74-4e54-b72b-f5209f44caa6\", \"paymentId\": \"0859f1e8-16e8-4924-808b-47e03560085d\", \"parameters\": [ { key: \"key1\", value: \"value1\" }, { key: \"key2\", value: \"value2\" } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/12-add-or-update-order-payment/","text":"AddOrUpdateOrderPayment This mutation adds or updates payment details for the order. It supports partial update, with all fields in command.payment and command.payment.billingAddress being optional. If you provide command.payment.id , the existing payment will be updated. Query mutation addOrUpdateOrderPayment($command: InputAddOrUpdateOrderPaymentType!) { addOrUpdateOrderPayment(command: $command) { id inPayments (first: 10, sort:\"ModifiedDate:desc\") { id createdDate billingAddress { id city countryCode countryName email firstName lastName line1 line2 middleName name organization phone postalCode regionId regionName zip addressType } paymentMethod { code paymentMethodType paymentMethodGroupType } } } } Variables \"command\": { \"orderId\": \"74d8b492-0bb5-486e-a0e6-0915848a7379\", \"payment\": { \"id\": \"New-Id-1\", \"paymentGatewayCode\": \"AuthorizeNetPaymentMethod\", \"billingAddress\": { \"city\": \"Test\", \"countryCode\": \"US\", \"countryName\": \"US\", \"email\": \"address@mail.test\", \"firstName\": \"First test name\", \"id\": \"KeyTest\", \"key\": \"KeyTest\", \"lastName\": \"Last name test\", \"line1\": \"Address Line 1\", \"line2\": \"Address line 2\", \"middleName\": \"Test Middle Name\", \"name\": \"First name address\", \"organization\": \"OrganizationTestName\", \"phone\": \"88005553535\", \"postalCode\": \"111111\", \"regionId\": \"Test region\", \"regionName\": \"Region 15\", \"zip\": \"13413\", \"addressType\": 2 } } }","title":"AddOrUpdateOrderPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/12-add-or-update-order-payment/#addorupdateorderpayment","text":"This mutation adds or updates payment details for the order. It supports partial update, with all fields in command.payment and command.payment.billingAddress being optional. If you provide command.payment.id , the existing payment will be updated.","title":"AddOrUpdateOrderPayment"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/12-add-or-update-order-payment/#query","text":"mutation addOrUpdateOrderPayment($command: InputAddOrUpdateOrderPaymentType!) { addOrUpdateOrderPayment(command: $command) { id inPayments (first: 10, sort:\"ModifiedDate:desc\") { id createdDate billingAddress { id city countryCode countryName email firstName lastName line1 line2 middleName name organization phone postalCode regionId regionName zip addressType } paymentMethod { code paymentMethodType paymentMethodGroupType } } } }","title":"Query"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/mutations/12-add-or-update-order-payment/#variables","text":"\"command\": { \"orderId\": \"74d8b492-0bb5-486e-a0e6-0915848a7379\", \"payment\": { \"id\": \"New-Id-1\", \"paymentGatewayCode\": \"AuthorizeNetPaymentMethod\", \"billingAddress\": { \"city\": \"Test\", \"countryCode\": \"US\", \"countryName\": \"US\", \"email\": \"address@mail.test\", \"firstName\": \"First test name\", \"id\": \"KeyTest\", \"key\": \"KeyTest\", \"lastName\": \"Last name test\", \"line1\": \"Address Line 1\", \"line2\": \"Address line 2\", \"middleName\": \"Test Middle Name\", \"name\": \"First name address\", \"organization\": \"OrganizationTestName\", \"phone\": \"88005553535\", \"postalCode\": \"111111\", \"regionId\": \"Test region\", \"regionName\": \"Region 15\", \"zip\": \"13413\", \"addressType\": 2 } } }","title":"Variables"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/objects/order-type/","text":"OrderType The chart below shows the components and relations of the OrderType object:","title":"OrderType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/objects/order-type/#ordertype","text":"The chart below shows the components and relations of the OrderType object:","title":"OrderType"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/queries/order-connection/","text":"Orders Connection With this connection, you can get all user orders. { orders( after: \"0\" first: 10 sort: \"createdDate:desc\" language: \"en-US\" userId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" ) { totalCount items { id customerId customerName createdDate addresses { postalCode } currency { code } items { sku name quantity } total { amount } cancelledDate } } } Result (click to expand) { \"data\": { \"orders\": { \"totalCount\": 3, \"items\": [ { \"id\": \"11a6d4a0-284f-46b1-8e17-add55983353f\", \"customerId\": \"0cda0396-43fe-4034-a20e-d0bab4c88c93\", \"customerName\": \"George Basker\", \"createdDate\": \"2019-01-06\", \"addresses\": [ { \"postalCode\": \"77462\" } ], \"currency\": { \"code\": \"EUR\" }, \"items\": [ { \"sku\": \"PTO-38363811\", \"name\": \"Laced In Love White Floral Prom Dress\", \"quantity\": 1 }, { \"sku\": \"EIQ-20582301\", \"name\": \"Burgundy Baroque Lace Waist Dress\", \"quantity\": 2 }, { \"sku\": \"334713255\", \"name\": \"Wide Fit Lilac Ankle Strap Straw Wedges\", \"quantity\": 1 } ], \"total\": { \"amount\": 106.98 }, \"cancelledDate\": null } ] } }, \"extensions\": {} }","title":"Order Connection"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/queries/order-connection/#orders-connection","text":"With this connection, you can get all user orders. { orders( after: \"0\" first: 10 sort: \"createdDate:desc\" language: \"en-US\" userId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" ) { totalCount items { id customerId customerName createdDate addresses { postalCode } currency { code } items { sku name quantity } total { amount } cancelledDate } } } Result (click to expand) { \"data\": { \"orders\": { \"totalCount\": 3, \"items\": [ { \"id\": \"11a6d4a0-284f-46b1-8e17-add55983353f\", \"customerId\": \"0cda0396-43fe-4034-a20e-d0bab4c88c93\", \"customerName\": \"George Basker\", \"createdDate\": \"2019-01-06\", \"addresses\": [ { \"postalCode\": \"77462\" } ], \"currency\": { \"code\": \"EUR\" }, \"items\": [ { \"sku\": \"PTO-38363811\", \"name\": \"Laced In Love White Floral Prom Dress\", \"quantity\": 1 }, { \"sku\": \"EIQ-20582301\", \"name\": \"Burgundy Baroque Lace Waist Dress\", \"quantity\": 2 }, { \"sku\": \"334713255\", \"name\": \"Wide Fit Lilac Ankle Strap Straw Wedges\", \"quantity\": 1 } ], \"total\": { \"amount\": 106.98 }, \"cancelledDate\": null } ] } }, \"extensions\": {} }","title":"Orders Connection"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/queries/order/","text":"Order { order( number: \"CU1508131823002\" userId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" ) { id customerId customerName createdDate dynamicProperties { name value valueType } addresses { postalCode } currency { code } items { sku name quantity } total { amount } cancelledDate } } Result (click to expand) { \"data\": { \"order\": { \"id\": \"9d27c868-2e31-4ab4-861b-909bc3f86657\", \"customerId\": \"0cda0396-43fe-4034-a20e-d0bab4c88c93\", \"customerName\": \"George Basker\", \"createdDate\": \"2019-01-06\", \"addresses\": [ { \"postalCode\": \"77462\" } ], \"currency\": { \"code\": \"EUR\" }, \"items\": [ { \"sku\": \"PTO-38363811\", \"name\": \"Laced In Love White Floral Prom Dress\", \"quantity\": 1 }, { \"sku\": \"QRY-61202734\", \"name\": \"Dark Blue Floral Print Twist Cut Out Back Dress\", \"quantity\": 1 } ], \"total\": { \"amount\": 62.99 }, \"cancelledDate\": null } }, \"extensions\": {} } Tip See the OrderType chart for better understanding of the fields you can use in your requests.","title":"Order"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/queries/order/#order","text":"{ order( number: \"CU1508131823002\" userId: \"0cda0396-43fe-4034-a20e-d0bab4c88c93\" ) { id customerId customerName createdDate dynamicProperties { name value valueType } addresses { postalCode } currency { code } items { sku name quantity } total { amount } cancelledDate } } Result (click to expand) { \"data\": { \"order\": { \"id\": \"9d27c868-2e31-4ab4-861b-909bc3f86657\", \"customerId\": \"0cda0396-43fe-4034-a20e-d0bab4c88c93\", \"customerName\": \"George Basker\", \"createdDate\": \"2019-01-06\", \"addresses\": [ { \"postalCode\": \"77462\" } ], \"currency\": { \"code\": \"EUR\" }, \"items\": [ { \"sku\": \"PTO-38363811\", \"name\": \"Laced In Love White Floral Prom Dress\", \"quantity\": 1 }, { \"sku\": \"QRY-61202734\", \"name\": \"Dark Blue Floral Print Twist Cut Out Back Dress\", \"quantity\": 1 } ], \"total\": { \"amount\": 62.99 }, \"cancelledDate\": null } }, \"extensions\": {} } Tip See the OrderType chart for better understanding of the fields you can use in your requests.","title":"Order"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/queries/overview/","text":"Queries # Endpoint Arguments Returns 1 order id number userId Order 2 orders filter sort language userId Paginated order list","title":"Overview"},{"location":"GraphQL-Storefront-API-Reference-xAPI/Order/queries/overview/#queries","text":"# Endpoint Arguments Returns 1 order id number userId Order 2 orders filter sort language userId Paginated order list","title":"Queries"},{"location":"Platform-Manager/style-guide/","text":"Introduction This Virto Commerce Platform Style Guide will help you develop consistent modules for the platform. You can use the existing styles described in our online Style Guide or, alternatively, create your own styles using the rules below. Apart from our Style Guide that refers to correctly using HTML and CSS when platform UI, we also have Blade Constructor that you can use to create your custom blades. Rules The purpose of these rules is to help developers easily make changes to CSS styles in a consistent manner. Naming Any module name should match the purpose of the module in question to have good understanding of what it stands for. Inheritance Inner module classes should be implemented only as part of the module: .block-module {} .block-module .element-module {} .block-module {} .element-module {} Style Tiers There are four module style tiers: Reset.css : The basis of all styles with the default styles reset, fonts set, and base sizes defined. Base modules.css : This tier has base elements, forms, and buttons defined. Project modules.css : Module style isolation tier with specific module styles defined. Cosmetic.css : Houses minor modifications of colors, as well as links. Naming conventions Use - (hyphen) as a word separator, e.g. input-field . Use _ (underscore) as a logic part separator, e.g., toolbar_logo . Use __ (double underscore) as a modifier separator, e.g., module_list.__modifier . Module Modifier Example Let's assume you have the following module defined: .module {} .module .module-t {} .module .module-decsr {} Once you need the module to get the red color theme, you have to add __red as a modifier separator: .module.__red {} In order to use the styling properly, you should also become familiar with the Multilayer CSS organization methodology .","title":"Style Guide"},{"location":"Platform-Manager/style-guide/#introduction","text":"This Virto Commerce Platform Style Guide will help you develop consistent modules for the platform. You can use the existing styles described in our online Style Guide or, alternatively, create your own styles using the rules below. Apart from our Style Guide that refers to correctly using HTML and CSS when platform UI, we also have Blade Constructor that you can use to create your custom blades.","title":"Introduction"},{"location":"Platform-Manager/style-guide/#rules","text":"The purpose of these rules is to help developers easily make changes to CSS styles in a consistent manner.","title":"Rules"},{"location":"Platform-Manager/style-guide/#naming","text":"Any module name should match the purpose of the module in question to have good understanding of what it stands for.","title":"Naming"},{"location":"Platform-Manager/style-guide/#inheritance","text":"Inner module classes should be implemented only as part of the module: .block-module {} .block-module .element-module {} .block-module {} .element-module {}","title":"Inheritance"},{"location":"Platform-Manager/style-guide/#style-tiers","text":"There are four module style tiers: Reset.css : The basis of all styles with the default styles reset, fonts set, and base sizes defined. Base modules.css : This tier has base elements, forms, and buttons defined. Project modules.css : Module style isolation tier with specific module styles defined. Cosmetic.css : Houses minor modifications of colors, as well as links.","title":"Style Tiers"},{"location":"Platform-Manager/style-guide/#naming-conventions","text":"Use - (hyphen) as a word separator, e.g. input-field . Use _ (underscore) as a logic part separator, e.g., toolbar_logo . Use __ (double underscore) as a modifier separator, e.g., module_list.__modifier .","title":"Naming conventions"},{"location":"Platform-Manager/style-guide/#module-modifier-example","text":"Let's assume you have the following module defined: .module {} .module .module-t {} .module .module-decsr {} Once you need the module to get the red color theme, you have to add __red as a modifier separator: .module.__red {} In order to use the styling properly, you should also become familiar with the Multilayer CSS organization methodology .","title":"Module Modifier Example"},{"location":"Platform-Manager/ui-scroll-directive/","text":"Introduction Generic UI scroll directive helps developers add dropdown lists to the UI and bind them to a custom data source. Using Directive UI scroll is implemented as the uiScrollDropDown Angular.js directive and has the following features: Bound to a search resource function allowing pagination and filtering Enables single select drop down list or multiple select Allows binding to a custom data source Can define data filter expression Supports events Basic Usage Example This is how UI scroll directive would work in an HTML template: < form > ... < ui-scroll-drop-down ng-model = \"blade.currentEntity.mainReturnsFulfillmentCenterId\" data = \"searchFulfillmentCenters(criteria)\" placeholder = \"'stores.blades.store-advanced.placeholders.fulfillment-center'\" > </ ui-scroll-drop-down > ... </ form > This is how it will work in an underlying .js file: $scope . searchFulfillmentCenters = function ( criteria ) { return fulfillments . search ( criteria ); } Parameters Parameter Description data Function that provides data to the dropdown list. filter Function that will be applied to the data after each page fetch. multiple Manages single select or multiple dropdown select mode. onSelect Function that is triggered when a value is selected. onRemove Function that is triggered when the selected value is cleared or removed. pageSize Manages page size on a single scroll (default at 20). placeholder Defines the text that is displayed when the dropdown value is not selected. isRequired The required flag value of the underlying ui-select directive ( false by default). isReadOnly The disabled flag value oof the underlying ui-select directive ( false by default). Examples Data Function The data function should either return a resource call result ( $promise ) or an array of predefined objects: < ui-scroll-drop-down ng-model = \"currentEntity\" data = \"getData(criteria)\" > </ ui-scroll-drop-down > Server call: $scope . getData = function ( criteria ) { return resource . search ( criteria ); } Predefined data array: $scope . currentEntity = 'ID2' ; $scope . getData = function () { return [{ id : 'ID1' , name : 'name 1' }, { id : 'ID2' , name : 'name 2' }, { id : 'ID3' , name : 'name 3' }]; } Multiple Select Mode To enable multi select mode, run the following code: < ui-scroll-drop-down multiple ng-model = \"currentEntity\" data = \"getData(criteria)\" > </ ui-scroll-drop-down > Model value must be an array type if you use multiple : $scope . currentEntity = [ 'ID2' , 'ID3' ]; Filter Expression If set, this function is called after each new page of data is fetched. This does not work with predefined array data function. < ui-scroll-drop-down ng-model = \"currentEntity\" data = \"serverSearch(criteria)\" filter = \"entitiesToHideFnc(items)\" > </ ui-scroll-drop-down > $scope . entitiesToHideFnc = function ( items ) { return _ . filter ( items , function ( x ) { console . log ( x . name ); if ( x . name === 'name2' ) return false ; return true ; }); } Events The directive provides on-select and on-delete events: < ui-scroll-drop-down ng-model = \"currentEntity\" data = \"getData(criteria)\" on-select = \"onSelect(item, model)\" on-remove = \"onRemove(item, model)\" > </ ui-scroll-drop-down > $scope . onSelect = function ( item , model ) { console . log ( item ); } $scope . onRemove = function ( item , model ) { console . log ( item ); }","title":"UI Scroll Directive"},{"location":"Platform-Manager/ui-scroll-directive/#introduction","text":"Generic UI scroll directive helps developers add dropdown lists to the UI and bind them to a custom data source.","title":"Introduction"},{"location":"Platform-Manager/ui-scroll-directive/#using-directive","text":"UI scroll is implemented as the uiScrollDropDown Angular.js directive and has the following features: Bound to a search resource function allowing pagination and filtering Enables single select drop down list or multiple select Allows binding to a custom data source Can define data filter expression Supports events","title":"Using Directive"},{"location":"Platform-Manager/ui-scroll-directive/#basic-usage-example","text":"This is how UI scroll directive would work in an HTML template: < form > ... < ui-scroll-drop-down ng-model = \"blade.currentEntity.mainReturnsFulfillmentCenterId\" data = \"searchFulfillmentCenters(criteria)\" placeholder = \"'stores.blades.store-advanced.placeholders.fulfillment-center'\" > </ ui-scroll-drop-down > ... </ form > This is how it will work in an underlying .js file: $scope . searchFulfillmentCenters = function ( criteria ) { return fulfillments . search ( criteria ); }","title":"Basic Usage Example"},{"location":"Platform-Manager/ui-scroll-directive/#parameters","text":"Parameter Description data Function that provides data to the dropdown list. filter Function that will be applied to the data after each page fetch. multiple Manages single select or multiple dropdown select mode. onSelect Function that is triggered when a value is selected. onRemove Function that is triggered when the selected value is cleared or removed. pageSize Manages page size on a single scroll (default at 20). placeholder Defines the text that is displayed when the dropdown value is not selected. isRequired The required flag value of the underlying ui-select directive ( false by default). isReadOnly The disabled flag value oof the underlying ui-select directive ( false by default).","title":"Parameters"},{"location":"Platform-Manager/ui-scroll-directive/#examples","text":"","title":"Examples"},{"location":"Platform-Manager/ui-scroll-directive/#data-function","text":"The data function should either return a resource call result ( $promise ) or an array of predefined objects: < ui-scroll-drop-down ng-model = \"currentEntity\" data = \"getData(criteria)\" > </ ui-scroll-drop-down > Server call: $scope . getData = function ( criteria ) { return resource . search ( criteria ); } Predefined data array: $scope . currentEntity = 'ID2' ; $scope . getData = function () { return [{ id : 'ID1' , name : 'name 1' }, { id : 'ID2' , name : 'name 2' }, { id : 'ID3' , name : 'name 3' }]; }","title":"Data Function"},{"location":"Platform-Manager/ui-scroll-directive/#multiple-select-mode","text":"To enable multi select mode, run the following code: < ui-scroll-drop-down multiple ng-model = \"currentEntity\" data = \"getData(criteria)\" > </ ui-scroll-drop-down > Model value must be an array type if you use multiple : $scope . currentEntity = [ 'ID2' , 'ID3' ];","title":"Multiple Select Mode"},{"location":"Platform-Manager/ui-scroll-directive/#filter-expression","text":"If set, this function is called after each new page of data is fetched. This does not work with predefined array data function. < ui-scroll-drop-down ng-model = \"currentEntity\" data = \"serverSearch(criteria)\" filter = \"entitiesToHideFnc(items)\" > </ ui-scroll-drop-down > $scope . entitiesToHideFnc = function ( items ) { return _ . filter ( items , function ( x ) { console . log ( x . name ); if ( x . name === 'name2' ) return false ; return true ; }); }","title":"Filter Expression"},{"location":"Platform-Manager/ui-scroll-directive/#events","text":"The directive provides on-select and on-delete events: < ui-scroll-drop-down ng-model = \"currentEntity\" data = \"getData(criteria)\" on-select = \"onSelect(item, model)\" on-remove = \"onRemove(item, model)\" > </ ui-scroll-drop-down > $scope . onSelect = function ( item , model ) { console . log ( item ); } $scope . onRemove = function ( item , model ) { console . log ( item ); }","title":"Events"},{"location":"Platform-Manager/Extensibility-Points/blade-toolbar/","text":"Introduction Blade toolbar represents a dedicated area inside a blade , where one can add controls , which we will call, for convenience, toolbar items . Four toolbar items nested in the blade toolbar Toolbar items can be added to a blade instance directly or using Virto Commerce platform toolbar extensibility service. Adding Toolbar Items Directly to Blade Instance Toolbar items are usually defined and added in the Angular.js controller, which is bound to a specific blade in the UI. Adding an item to the toolbar is pretty straightforward: you just need to define the $scope.blade.toolbarCommands array with the items in question: $scope . blade . toolbarCommands = [ { name : \"Save\" , icon : 'fa fa-save' , title : 'Save action tooltip text' , // or you can use keys for translation \"platform.commands.titles.save\" executeMethod : function () { $scope . saveChanges (); }, canExecuteMethod : function () { return isDirty (); }, permission : 'platform:security:manage' }, { name : \"Reset\" , icon : 'fa fa-undo' , title : 'Reset action tooltip text' , executeMethod : function () { angular . copy ( $scope . blade . origEntity , $scope . blade . currentEntity ); userStateCommand . updateName (); }, canExecuteMethod : function () { return isDirty (); }, permission : 'platform:security:manage' }, { name : \"Change password\" , icon : 'fa fa-refresh' , title : 'Change password action tooltip text' , executeMethod : function () { var newBlade = { id : 'accountDetailChild' , currentEntityId : $scope . blade . currentEntity . userName , title : $scope . blade . title , subtitle : \"Change your password\" , controller : 'platformWebApp.accountChangePasswordController' , template : 'Scripts/common/security/blades/account-changePassword.tpl.html' }; bladeNavigationService . showBlade ( newBlade , $scope . blade ); }, canExecuteMethod : function () { return true ; }, permission : 'platform:security:manage' } ]; Adding Toolbar Items from External Code A dedicated service is used for adding toolbar items externally, without having any reference to the blade instance. The preferred place for registering a toolbar item is the module run block in Angular.js. What you need is reference platformWebApp.toolbarService as toolbarService , create item option, and call register against the service: toolbarService . register ({ name : \"ADDITIONAL COMMAND\" , icon : 'fa fa-cloud' , title : 'Action command tooltip text' , executeMethod : function ( blade ) { console . log ( 'test: ' + this . name + this . icon + blade ); }, canExecuteMethod : function () { return true ; }, index : 2 }, 'virtoCommerce.marketingModule.itemsDynamicContentListController' ); toolbarService.register parameters: Parameter Description toolbarItem Toolbar item definition. toolbarController Full toolbar controller name. Toolbar item definition structure: Member Description name Display name for the item. icon Icon for toobar item. title Tooltip message for the button. executeMethod Function to run when the item is activated. canExecuteMethod Function to determine whether the item could be executed. The item is disabled in the toolbar if the false value is returned. index The 0-based position to insert the item in the toolbar.","title":"Blade Toolbar"},{"location":"Platform-Manager/Extensibility-Points/blade-toolbar/#introduction","text":"Blade toolbar represents a dedicated area inside a blade , where one can add controls , which we will call, for convenience, toolbar items . Four toolbar items nested in the blade toolbar Toolbar items can be added to a blade instance directly or using Virto Commerce platform toolbar extensibility service.","title":"Introduction"},{"location":"Platform-Manager/Extensibility-Points/blade-toolbar/#adding-toolbar-items-directly-to-blade-instance","text":"Toolbar items are usually defined and added in the Angular.js controller, which is bound to a specific blade in the UI. Adding an item to the toolbar is pretty straightforward: you just need to define the $scope.blade.toolbarCommands array with the items in question: $scope . blade . toolbarCommands = [ { name : \"Save\" , icon : 'fa fa-save' , title : 'Save action tooltip text' , // or you can use keys for translation \"platform.commands.titles.save\" executeMethod : function () { $scope . saveChanges (); }, canExecuteMethod : function () { return isDirty (); }, permission : 'platform:security:manage' }, { name : \"Reset\" , icon : 'fa fa-undo' , title : 'Reset action tooltip text' , executeMethod : function () { angular . copy ( $scope . blade . origEntity , $scope . blade . currentEntity ); userStateCommand . updateName (); }, canExecuteMethod : function () { return isDirty (); }, permission : 'platform:security:manage' }, { name : \"Change password\" , icon : 'fa fa-refresh' , title : 'Change password action tooltip text' , executeMethod : function () { var newBlade = { id : 'accountDetailChild' , currentEntityId : $scope . blade . currentEntity . userName , title : $scope . blade . title , subtitle : \"Change your password\" , controller : 'platformWebApp.accountChangePasswordController' , template : 'Scripts/common/security/blades/account-changePassword.tpl.html' }; bladeNavigationService . showBlade ( newBlade , $scope . blade ); }, canExecuteMethod : function () { return true ; }, permission : 'platform:security:manage' } ];","title":"Adding Toolbar Items Directly to Blade Instance"},{"location":"Platform-Manager/Extensibility-Points/blade-toolbar/#adding-toolbar-items-from-external-code","text":"A dedicated service is used for adding toolbar items externally, without having any reference to the blade instance. The preferred place for registering a toolbar item is the module run block in Angular.js. What you need is reference platformWebApp.toolbarService as toolbarService , create item option, and call register against the service: toolbarService . register ({ name : \"ADDITIONAL COMMAND\" , icon : 'fa fa-cloud' , title : 'Action command tooltip text' , executeMethod : function ( blade ) { console . log ( 'test: ' + this . name + this . icon + blade ); }, canExecuteMethod : function () { return true ; }, index : 2 }, 'virtoCommerce.marketingModule.itemsDynamicContentListController' ); toolbarService.register parameters: Parameter Description toolbarItem Toolbar item definition. toolbarController Full toolbar controller name. Toolbar item definition structure: Member Description name Display name for the item. icon Icon for toobar item. title Tooltip message for the button. executeMethod Function to run when the item is activated. canExecuteMethod Function to determine whether the item could be executed. The item is disabled in the toolbar if the false value is returned. index The 0-based position to insert the item in the toolbar.","title":"Adding Toolbar Items from External Code"},{"location":"Platform-Manager/Extensibility-Points/blades-and-navigation/","text":"Overview Virto Commerce Platform's UI is organized and divided into multiple screens called blades. Blades are ordered left to right and share parent-child hierarchy. Any parent blade has one or more child ones, while every child has a reference to its parent. The hierarchy depth is virtually unlimited. Example of unlimited parent-child blade hierarchy Blade Structure and Properties Every blade is instantiated from a highly customizable template. The template has a few basic parts, such as the maximize area, top and title bottons, toolbar, main content placeholders, etc. We have a dedicated Blade constructor page showing all customization options and allowing you to build your own blade on the fly. Our Blade constructor is also a useful resource for quick reference. You can check it out here . Any blade object has the following properties that Virto Commerce platform respects: Property Type Description id string Blade identifier, which is required and should be unique at the module level. isLoading bool Toggles the loading indicator in the UI. headIcon string An icon to show on the blade header. A Font Awesome icon identifier. If undefined, the default fa-folder icon is displayed. title string Blade title subtitle string Blade subtitle toolbarCommands object [] Toolbar controls (read more here ). controller string Angular.js controller ID. This property is required. template string Angular.js template path. This property is required. parentBlade object Reference to parent blade. Platform sets this value automatically. childrenBlades object [] Child blades. Platform sets and manages this value automatically. isClosingDisabled bool Shows whether the close botton ( x ) should be grayed out. A blade with such button grayed out can be closed only using a script. onClose(callback) function Action to call before closing the blade. This can prevent a blade from closing if the provided callback action is not run. The onClose property is usually used to show confirmation dialog. isExpandable bool Causes the blade to open maximized and then shrink when a child blade is opened. onExpand() function Action to call on maximizing the blade; most often used to expand inner controls of the blade. Info Blade instances can have other additional properties, such as isNew , currentEntity , etc. However, you have to manually change such properties in the associated controller. Blade Navigation To manage blades, we use platformWebApp.bladeNavigationService that has the following methods: Method Description showBlade(blade, parentBlade) Opens a new blade instance for the parent blade in question. The blade parameter should have at least the id , controller , and template properties set. closeBlade(blade, callback, onBeforeClosing) Attempts to close the blade in question. If specified, the onBeforeClosing function is called before closing the blade. If provided, the callback function is called after it was closed. closeChildrenBlades(blade, callback) Attempts to close all child blades. The callback function is called only if all child blades were closed successfully. setError(msg, blade) Sets an error message for the blade. To clear an error message, leave the msg parameter blank. angular.module('sampleApp') .controller('sampleController', ['$scope', 'platformWebApp.bladeNavigationService', function ($scope, bladeNavigationService) { ... var newBlade = { id: \"settingDetailChild\", currentEntityId: node.name, title: $scope.blade.title, controller: 'platformWebApp.settingDictionaryController', template: 'Scripts/app/settings/blades/setting-dictionary.tpl.html' }; bladeNavigationService.showBlade(newBlade, $scope.blade); The blade instance can be accessed in the associated controller by the $scope.blade property.","title":"Blades and Navigation"},{"location":"Platform-Manager/Extensibility-Points/blades-and-navigation/#overview","text":"Virto Commerce Platform's UI is organized and divided into multiple screens called blades. Blades are ordered left to right and share parent-child hierarchy. Any parent blade has one or more child ones, while every child has a reference to its parent. The hierarchy depth is virtually unlimited. Example of unlimited parent-child blade hierarchy","title":"Overview"},{"location":"Platform-Manager/Extensibility-Points/blades-and-navigation/#blade-structure-and-properties","text":"Every blade is instantiated from a highly customizable template. The template has a few basic parts, such as the maximize area, top and title bottons, toolbar, main content placeholders, etc. We have a dedicated Blade constructor page showing all customization options and allowing you to build your own blade on the fly. Our Blade constructor is also a useful resource for quick reference. You can check it out here . Any blade object has the following properties that Virto Commerce platform respects: Property Type Description id string Blade identifier, which is required and should be unique at the module level. isLoading bool Toggles the loading indicator in the UI. headIcon string An icon to show on the blade header. A Font Awesome icon identifier. If undefined, the default fa-folder icon is displayed. title string Blade title subtitle string Blade subtitle toolbarCommands object [] Toolbar controls (read more here ). controller string Angular.js controller ID. This property is required. template string Angular.js template path. This property is required. parentBlade object Reference to parent blade. Platform sets this value automatically. childrenBlades object [] Child blades. Platform sets and manages this value automatically. isClosingDisabled bool Shows whether the close botton ( x ) should be grayed out. A blade with such button grayed out can be closed only using a script. onClose(callback) function Action to call before closing the blade. This can prevent a blade from closing if the provided callback action is not run. The onClose property is usually used to show confirmation dialog. isExpandable bool Causes the blade to open maximized and then shrink when a child blade is opened. onExpand() function Action to call on maximizing the blade; most often used to expand inner controls of the blade. Info Blade instances can have other additional properties, such as isNew , currentEntity , etc. However, you have to manually change such properties in the associated controller.","title":"Blade Structure and\u00a0Properties"},{"location":"Platform-Manager/Extensibility-Points/blades-and-navigation/#blade-navigation","text":"To manage blades, we use platformWebApp.bladeNavigationService that has the following methods: Method Description showBlade(blade, parentBlade) Opens a new blade instance for the parent blade in question. The blade parameter should have at least the id , controller , and template properties set. closeBlade(blade, callback, onBeforeClosing) Attempts to close the blade in question. If specified, the onBeforeClosing function is called before closing the blade. If provided, the callback function is called after it was closed. closeChildrenBlades(blade, callback) Attempts to close all child blades. The callback function is called only if all child blades were closed successfully. setError(msg, blade) Sets an error message for the blade. To clear an error message, leave the msg parameter blank. angular.module('sampleApp') .controller('sampleController', ['$scope', 'platformWebApp.bladeNavigationService', function ($scope, bladeNavigationService) { ... var newBlade = { id: \"settingDetailChild\", currentEntityId: node.name, title: $scope.blade.title, controller: 'platformWebApp.settingDictionaryController', template: 'Scripts/app/settings/blades/setting-dictionary.tpl.html' }; bladeNavigationService.showBlade(newBlade, $scope.blade); The blade instance can be accessed in the associated controller by the $scope.blade property.","title":"Blade Navigation"},{"location":"Platform-Manager/Extensibility-Points/extending-grid-columns/","text":"Extending Grid Columns To extend grid columns, get platformWebApp.ui-grid.extension in the module run function, and then register the extension function to add a custom column permanently (data-independent) into the list. order2.js ... gridOptionExtension . registerExtension ( \"customerOrder-list-grid\" , function ( gridOptions ) { var customColumnDefs = [ { name : 'newField' , displayName : 'orders.blades.customerOrder-list.labels.newField' , width : '***' } ]; gridOptions . columnDefs = _ . union ( gridOptions . columnDefs , customColumnDefs ); }); ... This will allow you to add a column that will be always available.","title":"Extending Grid Columns"},{"location":"Platform-Manager/Extensibility-Points/extending-grid-columns/#extending-grid-columns","text":"To extend grid columns, get platformWebApp.ui-grid.extension in the module run function, and then register the extension function to add a custom column permanently (data-independent) into the list. order2.js ... gridOptionExtension . registerExtension ( \"customerOrder-list-grid\" , function ( gridOptions ) { var customColumnDefs = [ { name : 'newField' , displayName : 'orders.blades.customerOrder-list.labels.newField' , width : '***' } ]; gridOptions . columnDefs = _ . union ( gridOptions . columnDefs , customColumnDefs ); }); ... This will allow you to add a column that will be always available.","title":"Extending Grid Columns"},{"location":"Platform-Manager/Extensibility-Points/extending-main-menu/","text":"Adding New Items to Application Menu Use this code to add new menu items: . run ( [ '$rootScope' , 'platformWebApp.mainMenuService' , '$state' , function ( $rootScope , mainMenuService , $state ) { //Register module in main menu var menuItem = { path : 'browse/unmanaged module' , icon : 'fa fa-cube' , title : 'My cool module' , priority : 110 , state : function () { $state . go ( 'workspace.unmanagedModuleTemplate' ); }, permission : 'UnmanagedModulePermission' }; mainMenuService . addMenuItem ( menuItem ); }]); Note The priority property defines the menu position relative to the other menu options. A smaller number means a higher priority , and such a menu item will be displayed first.","title":"Extending Main Menu"},{"location":"Platform-Manager/Extensibility-Points/extending-main-menu/#adding-new-items-to-application-menu","text":"Use this code to add new menu items: . run ( [ '$rootScope' , 'platformWebApp.mainMenuService' , '$state' , function ( $rootScope , mainMenuService , $state ) { //Register module in main menu var menuItem = { path : 'browse/unmanaged module' , icon : 'fa fa-cube' , title : 'My cool module' , priority : 110 , state : function () { $state . go ( 'workspace.unmanagedModuleTemplate' ); }, permission : 'UnmanagedModulePermission' }; mainMenuService . addMenuItem ( menuItem ); }]); Note The priority property defines the menu position relative to the other menu options. A smaller number means a higher priority , and such a menu item will be displayed first.","title":"Adding New Items to Application Menu"},{"location":"Platform-Manager/Extensibility-Points/metaform/","text":"Introduction Most Virto Commerce Platform's blades contain lists or data entry forms. Typically, the data entry form is made of static HTML code with Angular.js bindings. This strategy comes with the following drawbacks: You cannot add any new UI elements without changing the source code. You cannot update the existing UI without changing the source code. Most content is produced through copying and pasting HTML code, which may lead to maintenance problems in the future, as data entry forms may potentially lose their common look and feel . In order to eliminate the issues above, we developed a new Angular.js component called metaform : Metaform is a placeholder (container) control that renders UI content based on the provided metadata. Meta-field is a JavaScript object defining metadata for a single logical element inside the metaform being rendered. Using Metaform Metaform is implemented as vaMetaform Angular.js directive and has the following features: Renders UI elements in a rectangular area and typically should be placed inside a form. Has customizable column count. The rendering runs left to right and top to bottom. Occupies all available width and has auto height. Supports simple input types and custom template elements. <form> ... <va-metaform registered-inputs=\"blade.metaFields\" blade=\"blade\" column-count=\"2\"></va-metaform> ... </form> Parameter Description registered-inputs Reference to metadata (meta-fields) blade Reference to parent blade column-count Number of columns to arrange the rendered elements (optional) Metaform Sample Code You can view and download our Metaform sample code here . Registering meta-fields Here is how you can run meta-field registration directly in a blade: blade.metaFields = [ { name: 'isApproved', title: \"Is approved\", valueType: \"Boolean\", isVisibleFn: function (blade) { return !blade.isNew; } }, { name: 'status', templateUrl: 'statusSelector.html' }, { name: 'startDate', isReadOnly: true, title: \"Data created\", valueType: \"DateTime\" }, { name: 'customerId', title: \"orders.blades.customerOrder-detail.labels.customer\", templateUrl: 'customerSelector.html' }]; Meta-field registration can also be done using the Platform-level factory. This way, any module can access and change the fields displayed inside the metaform: Reference platformWebApp.metaFormsService (as metaFormsService ) in your module's run method. Create meta-field definitions and register them using the metaFormsService.registerMetaFields method. metaFormsService.registerMetaFields(\"accountDetails\", [ { name: \"isAdministrator\", title: \"Is admin\", valueType: \"Boolean\" } ]); Meta-field Data Structure A meta-field has the following structure: Parameter Description name Property name to bind to. Under the hood, it is bound to blade.currentEntity.<<name>> . title Label value, which can be simple text or a key to localized resource. valueType Type of auto generated input control. Supported values: ShortText, LongText, Integer, Decimal, DateTime, Boolean, SecureString, Url, Email, Html. isRequired Required property for auto generated input control. Set to false by default. isReadOnly Disables the value for changing auto generated input control. Set to false by default. templateUrl A URL for custom content template. If specified, this template is rendered instead of the auto-generated content. isVisibleFn Function to control meta-field visibility. The meta-field gets rendered only if this function returns true or is undefined.","title":"Metaform"},{"location":"Platform-Manager/Extensibility-Points/metaform/#introduction","text":"Most Virto Commerce Platform's blades contain lists or data entry forms. Typically, the data entry form is made of static HTML code with Angular.js bindings. This strategy comes with the following drawbacks: You cannot add any new UI elements without changing the source code. You cannot update the existing UI without changing the source code. Most content is produced through copying and pasting HTML code, which may lead to maintenance problems in the future, as data entry forms may potentially lose their common look and feel . In order to eliminate the issues above, we developed a new Angular.js component called metaform : Metaform is a placeholder (container) control that renders UI content based on the provided metadata. Meta-field is a JavaScript object defining metadata for a single logical element inside the metaform being rendered.","title":"Introduction"},{"location":"Platform-Manager/Extensibility-Points/metaform/#using-metaform","text":"Metaform is implemented as vaMetaform Angular.js directive and has the following features: Renders UI elements in a rectangular area and typically should be placed inside a form. Has customizable column count. The rendering runs left to right and top to bottom. Occupies all available width and has auto height. Supports simple input types and custom template elements. <form> ... <va-metaform registered-inputs=\"blade.metaFields\" blade=\"blade\" column-count=\"2\"></va-metaform> ... </form> Parameter Description registered-inputs Reference to metadata (meta-fields) blade Reference to parent blade column-count Number of columns to arrange the rendered elements (optional)","title":"Using Metaform"},{"location":"Platform-Manager/Extensibility-Points/metaform/#metaform-sample-code","text":"You can view and download our Metaform sample code here .","title":"Metaform Sample Code"},{"location":"Platform-Manager/Extensibility-Points/metaform/#registering-meta-fields","text":"Here is how you can run meta-field registration directly in a blade: blade.metaFields = [ { name: 'isApproved', title: \"Is approved\", valueType: \"Boolean\", isVisibleFn: function (blade) { return !blade.isNew; } }, { name: 'status', templateUrl: 'statusSelector.html' }, { name: 'startDate', isReadOnly: true, title: \"Data created\", valueType: \"DateTime\" }, { name: 'customerId', title: \"orders.blades.customerOrder-detail.labels.customer\", templateUrl: 'customerSelector.html' }]; Meta-field registration can also be done using the Platform-level factory. This way, any module can access and change the fields displayed inside the metaform: Reference platformWebApp.metaFormsService (as metaFormsService ) in your module's run method. Create meta-field definitions and register them using the metaFormsService.registerMetaFields method. metaFormsService.registerMetaFields(\"accountDetails\", [ { name: \"isAdministrator\", title: \"Is admin\", valueType: \"Boolean\" } ]);","title":"Registering meta-fields"},{"location":"Platform-Manager/Extensibility-Points/metaform/#meta-field-data-structure","text":"A meta-field has the following structure: Parameter Description name Property name to bind to. Under the hood, it is bound to blade.currentEntity.<<name>> . title Label value, which can be simple text or a key to localized resource. valueType Type of auto generated input control. Supported values: ShortText, LongText, Integer, Decimal, DateTime, Boolean, SecureString, Url, Email, Html. isRequired Required property for auto generated input control. Set to false by default. isReadOnly Disables the value for changing auto generated input control. Set to false by default. templateUrl A URL for custom content template. If specified, this template is rendered instead of the auto-generated content. isVisibleFn Function to control meta-field visibility. The meta-field gets rendered only if this function returns true or is undefined.","title":"Meta-field Data Structure"},{"location":"Platform-Manager/Extensibility-Points/widgets/","text":"Introduction A widget is a relatively simple and intuitive web UI component within Virto Commerce Platform. It is basically a transient or auxiliary tile, which: Occupies just a fraction of a blade Provides useful information Usually enables opening another blade with extra information and functions Is reusable and can be added to as many blades ( widget containers ) as you want A widget container is a placeholder control for widgets , which: Displays widgets in a rectangular area Accepts options like size, widget column and row count, etc. Allows the user to manage widget position within designated area A widget service is a platform level engine for registering widgets and distributing them to the appropriate widget containers . Widget Container You can implement widget containes as the vaWidgetContainer Angular.js directive. We use angular-gridster under the hood, which means our containers support and accept angular-gridster options. <va-widget-container group=\"itemDetail\" blade=\"blade\" gridster-opts=\"{columns: 6, minRows: 4}\"></va-widget-container> Parameter Description group Widget group ID. Only widgets from this group will be displayed. The value should be in line with the context of the container, e.g. itemDetail , and be unique among all widget containers. blade Reference to parent blade. Sent to each widget inside the container. gridster-opts Angular-gridster options (optional value). Registering Widget You can register widgets through the Platform-level factory, which means any module can register new widgets to any widget container : Reference platformWebApp.widgetService (as widgetService ) in your module's run method. Create widget option definition and call widgetService.registerWidget . var variationWidget = { controller: 'virtoCommerce.catalogModule.itemVariationWidgetController', size: [2, 1], isVisible: function (blade) { return !blade.isNew && blade.controller === 'virtoCommerce.catalogModule.itemDetailController'; }, template: 'Modules/$(VirtoCommerce.Catalog)/Scripts/widgets/itemVariationWidget.tpl.html' }; widgetService.registerWidget(variationWidget, 'itemDetail'); WidgetService.registerWidget parameters: Parameter Description widget Widget options containerName Widget group ID that will be added to the widget container having the same group. Widget options: Option Description controller An Angular.js controller for the widget. Instantiated only on widget rendering, which means parent blade is accessible in the $scope.blade variable. size Widget dimensions: [number of columns, number of rows]. An optional parameter with the default value at [1,1]. isVisible Toggles widget visibility (a widget get invisible if this option is set to false ). Set to true by default. template Template URL for the widget. Check our Style Guide for details. Widget Visibility and Permissions Widget visibility is controlled by defining the isVisible method in widget registration options. There are at least two use cases when limiting visibility is required: The widget is appropriate only in some scenarios, e.g., you need to hide order widget while creating a new item or hide inventory widget for a digital product. Access to the widget is restricted by security permission, as in the sample piece of code below: isVisible: function (blade) { return authService.checkPermission('pricing:query'); },","title":"Widgets"},{"location":"Platform-Manager/Extensibility-Points/widgets/#introduction","text":"A widget is a relatively simple and intuitive web UI component within Virto Commerce Platform. It is basically a transient or auxiliary tile, which: Occupies just a fraction of a blade Provides useful information Usually enables opening another blade with extra information and functions Is reusable and can be added to as many blades ( widget containers ) as you want A widget container is a placeholder control for widgets , which: Displays widgets in a rectangular area Accepts options like size, widget column and row count, etc. Allows the user to manage widget position within designated area A widget service is a platform level engine for registering widgets and distributing them to the appropriate widget containers .","title":"Introduction"},{"location":"Platform-Manager/Extensibility-Points/widgets/#widget-container","text":"You can implement widget containes as the vaWidgetContainer Angular.js directive. We use angular-gridster under the hood, which means our containers support and accept angular-gridster options. <va-widget-container group=\"itemDetail\" blade=\"blade\" gridster-opts=\"{columns: 6, minRows: 4}\"></va-widget-container> Parameter Description group Widget group ID. Only widgets from this group will be displayed. The value should be in line with the context of the container, e.g. itemDetail , and be unique among all widget containers. blade Reference to parent blade. Sent to each widget inside the container. gridster-opts Angular-gridster options (optional value).","title":"Widget Container"},{"location":"Platform-Manager/Extensibility-Points/widgets/#registering-widget","text":"You can register widgets through the Platform-level factory, which means any module can register new widgets to any widget container : Reference platformWebApp.widgetService (as widgetService ) in your module's run method. Create widget option definition and call widgetService.registerWidget . var variationWidget = { controller: 'virtoCommerce.catalogModule.itemVariationWidgetController', size: [2, 1], isVisible: function (blade) { return !blade.isNew && blade.controller === 'virtoCommerce.catalogModule.itemDetailController'; }, template: 'Modules/$(VirtoCommerce.Catalog)/Scripts/widgets/itemVariationWidget.tpl.html' }; widgetService.registerWidget(variationWidget, 'itemDetail'); WidgetService.registerWidget parameters: Parameter Description widget Widget options containerName Widget group ID that will be added to the widget container having the same group. Widget options: Option Description controller An Angular.js controller for the widget. Instantiated only on widget rendering, which means parent blade is accessible in the $scope.blade variable. size Widget dimensions: [number of columns, number of rows]. An optional parameter with the default value at [1,1]. isVisible Toggles widget visibility (a widget get invisible if this option is set to false ). Set to true by default. template Template URL for the widget. Check our Style Guide for details.","title":"Registering Widget"},{"location":"Platform-Manager/Extensibility-Points/widgets/#widget-visibility-and-permissions","text":"Widget visibility is controlled by defining the isVisible method in widget registration options. There are at least two use cases when limiting visibility is required: The widget is appropriate only in some scenarios, e.g., you need to hide order widget while creating a new item or hide inventory widget for a digital product. Access to the widget is restricted by security permission, as in the sample piece of code below: isVisible: function (blade) { return authService.checkPermission('pricing:query'); },","title":"Widget Visibility and Permissions"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/","text":"Creating New Module The Virto Commerce ecosystem allows you to create your own custom module according to your business or technical needs. In this tutorial, you will learn how you can do so. Creating Solution from Template To run your own Virto Commerce module, you can create it from scratch. However, it is recommendable you do it based on a predefined template. For that, you need to: Create a source directory or, if you already have it, navigate to it Open Windows CMD or PowerShell Run these commands: dotnet new --install VirtoCommerce.Module.Template dotnet new vc-module --ModuleName MyCoolModule --Author \"Jon Doe\" --CompanyName MyCoolCompany --PlatformVersion \"3.200.0\" --PlatformNuGetPackageVersion \"3.200.0\" Once you are done, you will get your vc-module-MyCoolModule solution with the following structure, which you will be able to see as you open your newly created module with Visual Studio: Working with Database Your next step is connecting your module to a database. Namely, you need to define a model, entity, and repository classes that would make up the persistent layer. In the Data Project Models directory, add a file called Blog.cs with the following code: using System ; using VirtoCommerce.Platform.Core.Common ; namespace MyCoolCompany.MyCoolModule.Core.Models ; public class Blog : AuditableEntity , ICloneable { public string Name { get ; set ; } public object Clone () => MemberwiseClone (); } and another one called BlogEntity.cs with the following code: using MyCoolCompany.MyCoolModule.Core.Models ; using VirtoCommerce.Platform.Core.Common ; using VirtoCommerce.Platform.Core.Domain ; namespace MyCoolCompany.MyCoolModule.Data.Models ; public class BlogEntity : AuditableEntity , IDataEntity < BlogEntity , Blog > { public string Name { get ; set ; } public Blog ToModel ( Blog model ) { model . Id = Id ; model . Name = Name ; return model ; } public BlogEntity FromModel ( Blog model , PrimaryKeyResolvingMap pkMap ) { pkMap . AddPair ( model , this ); Id = model . Id ; Name = model . Name ; return this ; } public void Patch ( BlogEntity target ) { target . Name = Name ; } } In the Data Project Repositories directory, add BlogRepository.cs with the following code: using System ; using System.Collections.Generic ; using System.Linq ; using System.Threading.Tasks ; using Microsoft.EntityFrameworkCore ; using MyCoolCompany.MyCoolModule.Data.Models ; using VirtoCommerce.Platform.Core.Domain ; using VirtoCommerce.Platform.Data.Infrastructure ; namespace MyCoolCompany.MyCoolModule.Data.Repositories ; public class BlogRepository : DbContextRepositoryBase < MyCoolModuleDbContext > { public BlogRepository ( MyCoolModuleDbContext dbContext , IUnitOfWork unitOfWork = null ) : base ( dbContext , unitOfWork ) { } public IQueryable < BlogEntity > Blogs => DbContext . Set < BlogEntity >(); public virtual async Task < ICollection < BlogEntity >> GetBlogsByIdsAsync ( IEnumerable < string > ids ) { var result = await Blogs . Where ( x => ids . Contains ( x . Id )). ToListAsync (); return result ; } } In the same Data Project Repositories directory, change the MyCoolModuleDbContext.cs file as follows: using EntityFrameworkCore.Triggers ; using Microsoft.EntityFrameworkCore ; using MyCoolCompany.MyCoolModule.Data.Models ; namespace MyCoolCompany.MyCoolModule.Data.Repositories ; public class MyCoolModuleDbContext : DbContextWithTriggers { public MyCoolModuleDbContext ( DbContextOptions < MyCoolModuleDbContext > options ) : base ( options ) { } protected MyCoolModuleDbContext ( DbContextOptions options ) : base ( options ) { } protected override void OnModelCreating ( ModelBuilder modelBuilder ) { modelBuilder . Entity < BlogEntity >(). ToTable ( \"Blogs\" ). HasKey ( x => x . Id ); modelBuilder . Entity < BlogEntity >(). Property ( x => x . Id ). HasMaxLength ( 128 ). ValueGeneratedOnAdd (); modelBuilder . Entity < BlogEntity >(). Property ( x => x . Name ). HasMaxLength ( 128 ); base . OnModelCreating ( modelBuilder ); } } Create the initial migration file in Visual Studio: Navigate to Tools > NuGet Package Manager > Package Manager Console Run the following command: Add-Migration InitialMigration -Context MyCoolCompany.MyCoolModule.Data.Repositories.MyCoolModuleDbContext -Verbose -OutputDir Migrations -Project MyCoolCompany.MyCoolModule.Data -StartupProject MyCoolCompany.MyCoolModule.Data -Debug This will bring the InitialMigration.cs file to the Data Project Migrations directory. Adding New API Next, you need to define services and an API layer to access the model. In the Data Project Services directory, add the BlogService.cs file with the following code: using System ; using System.Collections.Generic ; using System.Threading.Tasks ; using MyCoolCompany.MyCoolModule.Core.Models ; using MyCoolCompany.MyCoolModule.Data.Models ; using MyCoolCompany.MyCoolModule.Data.Repositories ; using VirtoCommerce.Platform.Core.Caching ; using VirtoCommerce.Platform.Core.Common ; using VirtoCommerce.Platform.Core.Events ; using VirtoCommerce.Platform.Data.GenericCrud ; namespace MyCoolCompany.MyCoolModule.Data.Services ; public class BlogService : CrudService < Blog , BlogEntity , BlogChangingEvent , BlogChangedEvent > { public BlogService ( Func < BlogRepository > repositoryFactory , IPlatformMemoryCache platformMemoryCache , IEventPublisher eventPublisher ) : base ( repositoryFactory , platformMemoryCache , eventPublisher ) { } protected override async Task < IEnumerable < BlogEntity >> LoadEntities ( IRepository repository , IEnumerable < string > ids , string responseGroup ) { var blogRepository = repository as BlogRepository ; return await blogRepository . GetBlogsByIdsAsync ( ids ); } } public class BlogChangedEvent : GenericChangedEntryEvent < Blog > { public BlogChangedEvent ( IEnumerable < GenericChangedEntry < Blog >> changedEntries ) : base ( changedEntries ) { } } public class BlogChangingEvent : GenericChangedEntryEvent < Blog > { public BlogChangingEvent ( IEnumerable < GenericChangedEntry < Blog >> changedEntries ) : base ( changedEntries ) { } } and another file, BlogSearchService.cs , with the following code: using System ; using System.Collections.Generic ; using System.Linq ; using MyCoolCompany.MyCoolModule.Core.Models ; using MyCoolCompany.MyCoolModule.Data.Models ; using MyCoolCompany.MyCoolModule.Data.Repositories ; using VirtoCommerce.Platform.Core.Caching ; using VirtoCommerce.Platform.Core.Common ; using VirtoCommerce.Platform.Core.GenericCrud ; using VirtoCommerce.Platform.Data.GenericCrud ; namespace MyCoolCompany.MyCoolModule.Data.Services ; public class BlogSearchService : SearchService < BlogSearchCriteria , BlogSearchResult , Blog , BlogEntity > { public BlogSearchService ( Func < BlogRepository > repositoryFactory , IPlatformMemoryCache platformMemoryCache , ICrudService < Blog > crudService ) : base ( repositoryFactory , platformMemoryCache , crudService ) { } protected override IQueryable < BlogEntity > BuildQuery ( IRepository repository , BlogSearchCriteria criteria ) { var query = (( BlogRepository ) repository ). Blogs ; return query ; } protected override IList < SortInfo > BuildSortExpression ( BlogSearchCriteria criteria ) { var sortInfos = criteria . SortInfos ; if ( sortInfos . IsNullOrEmpty ()) { sortInfos = new [] { new SortInfo { SortColumn = nameof ( BlogEntity . Id ) } }; } return sortInfos ; } } public class BlogSearchCriteria : SearchCriteriaBase { } public class BlogSearchResult : GenericSearchResult < Blog > { } In the Web project Controllers/Api directory, change MyCoolModuleController.cs as follows: using System.Collections.Generic ; using System.Threading.Tasks ; using Microsoft.AspNetCore.Mvc ; using MyCoolCompany.MyCoolModule.Core.Models ; using MyCoolCompany.MyCoolModule.Data.Services ; using VirtoCommerce.Platform.Core.GenericCrud ; namespace MyCoolCompany.MyCoolModule.Web.Controllers.Api { [Route(\"api/MyCoolModule\")] public class MyCoolModuleController : Controller { private readonly ICrudService < Blog > _blogService ; private readonly ISearchService < BlogSearchCriteria , BlogSearchResult , Blog > _blogSearchService ; public MyCoolModuleController ( ICrudService < Blog > blogService , ISearchService < BlogSearchCriteria , BlogSearchResult , Blog > blogSearchService ) { _blogService = blogService ; _blogSearchService = blogSearchService ; } [HttpPost] [Route(\"\")] public async Task < ActionResult < Blog >> AddBlog ( string name ) { var blog = new Blog { Name = name }; await _blogService . SaveChangesAsync ( new List < Blog > { blog }); return Ok ( blog ); } [HttpGet] [Route(\"\")] public async Task < ActionResult < BlogSearchResult >> GetAll () { var result = await _blogSearchService . SearchAsync ( new BlogSearchCriteria ()); return Ok ( result ); } } } Register all created services by changing the Initialize method in Module.cs as follows: public void Initialize ( IServiceCollection serviceCollection ) { // database initialization serviceCollection . AddDbContext < MyCoolModuleDbContext >(( provider , options ) => { var configuration = provider . GetRequiredService < IConfiguration >(); options . UseSqlServer ( configuration . GetConnectionString ( ModuleInfo . Id ) ?? configuration . GetConnectionString ( \"VirtoCommerce\" )); }); serviceCollection . AddTransient < BlogRepository >(); serviceCollection . AddTransient < Func < BlogRepository >>( provider => () => provider . CreateScope (). ServiceProvider . GetRequiredService < BlogRepository >()); serviceCollection . AddTransient < ICrudService < Blog >, BlogService >(); serviceCollection . AddTransient < ISearchService < BlogSearchCriteria , BlogSearchResult , Blog >, BlogSearchService >(); } } Testing and Debugging API After you are done creating your module, you need then to install it from your source and debug it. This can be handled with a few steps: Link the Module Web directory to the Platform/modules directory: mklink /d c:\\source\\vc-platform\\src\\VirtoCommerce.Platform.Web\\modules\\my-cool-module\\ c:\\source\\vc-module-MyCoolModule\\src\\MyCoolCompany.MyCoolModule.Web\\ Note In the above example, c:\\source\\ means the path to your repository. Restart the platform Open Swagger API at http://localhost:10645/docs/index.html , find MyCoolModule extension module , and run the POST method to verify whether everything is working properly: This will create a new blog record. Finally, to debug your module, attach the platform process to the Visual Studio module solution by navigating to Tools > Attach to Process > [Find the platform process] > Attach : Extending VC Manager with New UI Our module template provides scripts that will help you extend the Platform Manager UI. You can find these scripts in the Web Scripts directory: + module.js: contains UI module registration code + resources/my-cool-module-api.js: contains the web API service + blades/hello-world.js: houses the basic blade template To start extending the Platform Manager UI, do the following: Change blades/hello-world.js as follows: angular . module ( 'MyCoolModule' ) . controller ( 'MyCoolModule.helloWorldController' , [ '$scope' , 'MyCoolModule.webApi' , function ( $scope , api ) { var blade = $scope . blade ; blade . title = 'MyCoolModule' ; blade . refresh = function () { api . get ( function ( data ) { blade . title = 'MyCoolModule.blades.hello-world.title' ; blade . data = data . results ; blade . isLoading = false ; }); }; blade . refresh (); }]); Change blades/hello-world.html as follows: < div class = \"blade-content\" > < div class = \"blade-inner\" > < div class = \"inner-block\" > < div class = \"table-wrapper\" > < table class = \"table __normal\" > < tbody ng-model = \"blade.data\" > < tr class = \"table-item\" ng-repeat = \"data in blade.data track by data.name\" > < td class = \"table-col\" > < div class = \"table-t\" > {{ data.name }} </ div > </ td > </ tr > </ tbody > </ table > </ div > </ div > </ div > </ div > Build script artifacts: Navigate to the module Web project directory Open Windows CMD or PowerShell and run the following commands: npm install npm run webpack:build Verify that the platform UI was extended with your module scripts: by opening the platform UI and navigating to the MyCoolModule menu, you should see all created Blogs records. Adding Authentication Options Our module template also provides you with out of the box default authentication permissions, which are located in the ModuleConstants.cs file: public static class Permissions { public const string Access = \"MyCoolModule:access\" ; public const string Create = \"MyCoolModule:create\" ; public const string Read = \"MyCoolModule:read\" ; public const string Update = \"MyCoolModule:update\" ; public const string Delete = \"MyCoolModule:delete\" ; } You can find the registration code inside the Module.cs PostInitialize method: // register permissions var permissionsProvider = appBuilder . ApplicationServices . GetRequiredService < IPermissionsRegistrar >(); permissionsProvider . RegisterPermissions ( ModuleConstants . Security . Permissions . AllPermissions . Select ( x => new Permission () { GroupName = \"MyCoolModule\" , ModuleId = ModuleInfo . Id , Name = x }). ToArray ()); To restrict access to an endpoint with a permission, add the Authorize attribute to it: [HttpGet] [Route(\"\")] [Authorize(ModuleConstants.Security.Permissions.Read)] public async Task < ActionResult < BlogSearchResult >> GetAll () Packing Your Module To build your custom module for distribution, use our Virto Commerce CLI tool: Navigate to the module root directory Open Windows CMD or PowerShell Run the following commands: dotnet tool install VirtoCommerce.GlobalTool -g vc-build compress This is what you will get: Note The new module package will be created in the Artifacts folder. Distribution and Installation The module package can be uploaded and installed to the Virto Commerce Platform. To do this, you need to: Open Virto Commerce Admin Portal and sign into it Select the Modules menu and navigate to the Advanced section Install or update the module from a file Restart the platform If the module is installed properly, you should see the new module in the list of the installed modules, Admin UI, and Swagger API:","title":"Creating Custom Module"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#creating-new-module","text":"The Virto Commerce ecosystem allows you to create your own custom module according to your business or technical needs. In this tutorial, you will learn how you can do so.","title":"Creating New Module"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#creating-solution-from-template","text":"To run your own Virto Commerce module, you can create it from scratch. However, it is recommendable you do it based on a predefined template. For that, you need to: Create a source directory or, if you already have it, navigate to it Open Windows CMD or PowerShell Run these commands: dotnet new --install VirtoCommerce.Module.Template dotnet new vc-module --ModuleName MyCoolModule --Author \"Jon Doe\" --CompanyName MyCoolCompany --PlatformVersion \"3.200.0\" --PlatformNuGetPackageVersion \"3.200.0\" Once you are done, you will get your vc-module-MyCoolModule solution with the following structure, which you will be able to see as you open your newly created module with Visual Studio:","title":"Creating Solution from Template"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#working-with-database","text":"Your next step is connecting your module to a database. Namely, you need to define a model, entity, and repository classes that would make up the persistent layer. In the Data Project Models directory, add a file called Blog.cs with the following code: using System ; using VirtoCommerce.Platform.Core.Common ; namespace MyCoolCompany.MyCoolModule.Core.Models ; public class Blog : AuditableEntity , ICloneable { public string Name { get ; set ; } public object Clone () => MemberwiseClone (); } and another one called BlogEntity.cs with the following code: using MyCoolCompany.MyCoolModule.Core.Models ; using VirtoCommerce.Platform.Core.Common ; using VirtoCommerce.Platform.Core.Domain ; namespace MyCoolCompany.MyCoolModule.Data.Models ; public class BlogEntity : AuditableEntity , IDataEntity < BlogEntity , Blog > { public string Name { get ; set ; } public Blog ToModel ( Blog model ) { model . Id = Id ; model . Name = Name ; return model ; } public BlogEntity FromModel ( Blog model , PrimaryKeyResolvingMap pkMap ) { pkMap . AddPair ( model , this ); Id = model . Id ; Name = model . Name ; return this ; } public void Patch ( BlogEntity target ) { target . Name = Name ; } } In the Data Project Repositories directory, add BlogRepository.cs with the following code: using System ; using System.Collections.Generic ; using System.Linq ; using System.Threading.Tasks ; using Microsoft.EntityFrameworkCore ; using MyCoolCompany.MyCoolModule.Data.Models ; using VirtoCommerce.Platform.Core.Domain ; using VirtoCommerce.Platform.Data.Infrastructure ; namespace MyCoolCompany.MyCoolModule.Data.Repositories ; public class BlogRepository : DbContextRepositoryBase < MyCoolModuleDbContext > { public BlogRepository ( MyCoolModuleDbContext dbContext , IUnitOfWork unitOfWork = null ) : base ( dbContext , unitOfWork ) { } public IQueryable < BlogEntity > Blogs => DbContext . Set < BlogEntity >(); public virtual async Task < ICollection < BlogEntity >> GetBlogsByIdsAsync ( IEnumerable < string > ids ) { var result = await Blogs . Where ( x => ids . Contains ( x . Id )). ToListAsync (); return result ; } } In the same Data Project Repositories directory, change the MyCoolModuleDbContext.cs file as follows: using EntityFrameworkCore.Triggers ; using Microsoft.EntityFrameworkCore ; using MyCoolCompany.MyCoolModule.Data.Models ; namespace MyCoolCompany.MyCoolModule.Data.Repositories ; public class MyCoolModuleDbContext : DbContextWithTriggers { public MyCoolModuleDbContext ( DbContextOptions < MyCoolModuleDbContext > options ) : base ( options ) { } protected MyCoolModuleDbContext ( DbContextOptions options ) : base ( options ) { } protected override void OnModelCreating ( ModelBuilder modelBuilder ) { modelBuilder . Entity < BlogEntity >(). ToTable ( \"Blogs\" ). HasKey ( x => x . Id ); modelBuilder . Entity < BlogEntity >(). Property ( x => x . Id ). HasMaxLength ( 128 ). ValueGeneratedOnAdd (); modelBuilder . Entity < BlogEntity >(). Property ( x => x . Name ). HasMaxLength ( 128 ); base . OnModelCreating ( modelBuilder ); } } Create the initial migration file in Visual Studio: Navigate to Tools > NuGet Package Manager > Package Manager Console Run the following command: Add-Migration InitialMigration -Context MyCoolCompany.MyCoolModule.Data.Repositories.MyCoolModuleDbContext -Verbose -OutputDir Migrations -Project MyCoolCompany.MyCoolModule.Data -StartupProject MyCoolCompany.MyCoolModule.Data -Debug This will bring the InitialMigration.cs file to the Data Project Migrations directory.","title":"Working with Database"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#adding-new-api","text":"Next, you need to define services and an API layer to access the model. In the Data Project Services directory, add the BlogService.cs file with the following code: using System ; using System.Collections.Generic ; using System.Threading.Tasks ; using MyCoolCompany.MyCoolModule.Core.Models ; using MyCoolCompany.MyCoolModule.Data.Models ; using MyCoolCompany.MyCoolModule.Data.Repositories ; using VirtoCommerce.Platform.Core.Caching ; using VirtoCommerce.Platform.Core.Common ; using VirtoCommerce.Platform.Core.Events ; using VirtoCommerce.Platform.Data.GenericCrud ; namespace MyCoolCompany.MyCoolModule.Data.Services ; public class BlogService : CrudService < Blog , BlogEntity , BlogChangingEvent , BlogChangedEvent > { public BlogService ( Func < BlogRepository > repositoryFactory , IPlatformMemoryCache platformMemoryCache , IEventPublisher eventPublisher ) : base ( repositoryFactory , platformMemoryCache , eventPublisher ) { } protected override async Task < IEnumerable < BlogEntity >> LoadEntities ( IRepository repository , IEnumerable < string > ids , string responseGroup ) { var blogRepository = repository as BlogRepository ; return await blogRepository . GetBlogsByIdsAsync ( ids ); } } public class BlogChangedEvent : GenericChangedEntryEvent < Blog > { public BlogChangedEvent ( IEnumerable < GenericChangedEntry < Blog >> changedEntries ) : base ( changedEntries ) { } } public class BlogChangingEvent : GenericChangedEntryEvent < Blog > { public BlogChangingEvent ( IEnumerable < GenericChangedEntry < Blog >> changedEntries ) : base ( changedEntries ) { } } and another file, BlogSearchService.cs , with the following code: using System ; using System.Collections.Generic ; using System.Linq ; using MyCoolCompany.MyCoolModule.Core.Models ; using MyCoolCompany.MyCoolModule.Data.Models ; using MyCoolCompany.MyCoolModule.Data.Repositories ; using VirtoCommerce.Platform.Core.Caching ; using VirtoCommerce.Platform.Core.Common ; using VirtoCommerce.Platform.Core.GenericCrud ; using VirtoCommerce.Platform.Data.GenericCrud ; namespace MyCoolCompany.MyCoolModule.Data.Services ; public class BlogSearchService : SearchService < BlogSearchCriteria , BlogSearchResult , Blog , BlogEntity > { public BlogSearchService ( Func < BlogRepository > repositoryFactory , IPlatformMemoryCache platformMemoryCache , ICrudService < Blog > crudService ) : base ( repositoryFactory , platformMemoryCache , crudService ) { } protected override IQueryable < BlogEntity > BuildQuery ( IRepository repository , BlogSearchCriteria criteria ) { var query = (( BlogRepository ) repository ). Blogs ; return query ; } protected override IList < SortInfo > BuildSortExpression ( BlogSearchCriteria criteria ) { var sortInfos = criteria . SortInfos ; if ( sortInfos . IsNullOrEmpty ()) { sortInfos = new [] { new SortInfo { SortColumn = nameof ( BlogEntity . Id ) } }; } return sortInfos ; } } public class BlogSearchCriteria : SearchCriteriaBase { } public class BlogSearchResult : GenericSearchResult < Blog > { } In the Web project Controllers/Api directory, change MyCoolModuleController.cs as follows: using System.Collections.Generic ; using System.Threading.Tasks ; using Microsoft.AspNetCore.Mvc ; using MyCoolCompany.MyCoolModule.Core.Models ; using MyCoolCompany.MyCoolModule.Data.Services ; using VirtoCommerce.Platform.Core.GenericCrud ; namespace MyCoolCompany.MyCoolModule.Web.Controllers.Api { [Route(\"api/MyCoolModule\")] public class MyCoolModuleController : Controller { private readonly ICrudService < Blog > _blogService ; private readonly ISearchService < BlogSearchCriteria , BlogSearchResult , Blog > _blogSearchService ; public MyCoolModuleController ( ICrudService < Blog > blogService , ISearchService < BlogSearchCriteria , BlogSearchResult , Blog > blogSearchService ) { _blogService = blogService ; _blogSearchService = blogSearchService ; } [HttpPost] [Route(\"\")] public async Task < ActionResult < Blog >> AddBlog ( string name ) { var blog = new Blog { Name = name }; await _blogService . SaveChangesAsync ( new List < Blog > { blog }); return Ok ( blog ); } [HttpGet] [Route(\"\")] public async Task < ActionResult < BlogSearchResult >> GetAll () { var result = await _blogSearchService . SearchAsync ( new BlogSearchCriteria ()); return Ok ( result ); } } } Register all created services by changing the Initialize method in Module.cs as follows: public void Initialize ( IServiceCollection serviceCollection ) { // database initialization serviceCollection . AddDbContext < MyCoolModuleDbContext >(( provider , options ) => { var configuration = provider . GetRequiredService < IConfiguration >(); options . UseSqlServer ( configuration . GetConnectionString ( ModuleInfo . Id ) ?? configuration . GetConnectionString ( \"VirtoCommerce\" )); }); serviceCollection . AddTransient < BlogRepository >(); serviceCollection . AddTransient < Func < BlogRepository >>( provider => () => provider . CreateScope (). ServiceProvider . GetRequiredService < BlogRepository >()); serviceCollection . AddTransient < ICrudService < Blog >, BlogService >(); serviceCollection . AddTransient < ISearchService < BlogSearchCriteria , BlogSearchResult , Blog >, BlogSearchService >(); } }","title":"Adding New API"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#testing-and-debugging-api","text":"After you are done creating your module, you need then to install it from your source and debug it. This can be handled with a few steps: Link the Module Web directory to the Platform/modules directory: mklink /d c:\\source\\vc-platform\\src\\VirtoCommerce.Platform.Web\\modules\\my-cool-module\\ c:\\source\\vc-module-MyCoolModule\\src\\MyCoolCompany.MyCoolModule.Web\\ Note In the above example, c:\\source\\ means the path to your repository. Restart the platform Open Swagger API at http://localhost:10645/docs/index.html , find MyCoolModule extension module , and run the POST method to verify whether everything is working properly: This will create a new blog record. Finally, to debug your module, attach the platform process to the Visual Studio module solution by navigating to Tools > Attach to Process > [Find the platform process] > Attach :","title":"Testing and Debugging API"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#extending-vc-manager-with-new-ui","text":"Our module template provides scripts that will help you extend the Platform Manager UI. You can find these scripts in the Web Scripts directory: + module.js: contains UI module registration code + resources/my-cool-module-api.js: contains the web API service + blades/hello-world.js: houses the basic blade template To start extending the Platform Manager UI, do the following: Change blades/hello-world.js as follows: angular . module ( 'MyCoolModule' ) . controller ( 'MyCoolModule.helloWorldController' , [ '$scope' , 'MyCoolModule.webApi' , function ( $scope , api ) { var blade = $scope . blade ; blade . title = 'MyCoolModule' ; blade . refresh = function () { api . get ( function ( data ) { blade . title = 'MyCoolModule.blades.hello-world.title' ; blade . data = data . results ; blade . isLoading = false ; }); }; blade . refresh (); }]); Change blades/hello-world.html as follows: < div class = \"blade-content\" > < div class = \"blade-inner\" > < div class = \"inner-block\" > < div class = \"table-wrapper\" > < table class = \"table __normal\" > < tbody ng-model = \"blade.data\" > < tr class = \"table-item\" ng-repeat = \"data in blade.data track by data.name\" > < td class = \"table-col\" > < div class = \"table-t\" > {{ data.name }} </ div > </ td > </ tr > </ tbody > </ table > </ div > </ div > </ div > </ div > Build script artifacts: Navigate to the module Web project directory Open Windows CMD or PowerShell and run the following commands: npm install npm run webpack:build Verify that the platform UI was extended with your module scripts: by opening the platform UI and navigating to the MyCoolModule menu, you should see all created Blogs records.","title":"Extending VC Manager with New UI"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#adding-authentication-options","text":"Our module template also provides you with out of the box default authentication permissions, which are located in the ModuleConstants.cs file: public static class Permissions { public const string Access = \"MyCoolModule:access\" ; public const string Create = \"MyCoolModule:create\" ; public const string Read = \"MyCoolModule:read\" ; public const string Update = \"MyCoolModule:update\" ; public const string Delete = \"MyCoolModule:delete\" ; } You can find the registration code inside the Module.cs PostInitialize method: // register permissions var permissionsProvider = appBuilder . ApplicationServices . GetRequiredService < IPermissionsRegistrar >(); permissionsProvider . RegisterPermissions ( ModuleConstants . Security . Permissions . AllPermissions . Select ( x => new Permission () { GroupName = \"MyCoolModule\" , ModuleId = ModuleInfo . Id , Name = x }). ToArray ()); To restrict access to an endpoint with a permission, add the Authorize attribute to it: [HttpGet] [Route(\"\")] [Authorize(ModuleConstants.Security.Permissions.Read)] public async Task < ActionResult < BlogSearchResult >> GetAll ()","title":"Adding Authentication Options"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#packing-your-module","text":"To build your custom module for distribution, use our Virto Commerce CLI tool: Navigate to the module root directory Open Windows CMD or PowerShell Run the following commands: dotnet tool install VirtoCommerce.GlobalTool -g vc-build compress This is what you will get: Note The new module package will be created in the Artifacts folder.","title":"Packing Your Module"},{"location":"Tutorials-and-How-tos/Tutorials/creating-custom-module/#distribution-and-installation","text":"The module package can be uploaded and installed to the Virto Commerce Platform. To do this, you need to: Open Virto Commerce Admin Portal and sign into it Select the Modules menu and navigate to the Advanced section Install or update the module from a file Restart the platform If the module is installed properly, you should see the new module in the list of the installed modules, Admin UI, and Swagger API:","title":"Distribution and Installation"},{"location":"Tutorials-and-How-tos/Tutorials/extending-domain-models/","text":"Extending Domain Models VirtoCommerce supports extension of managed code domain types. This article will show you how to use various techniques to extend an existing domain type without direct code modification. To view or download our sample code, click here . Extending through Type Inheritance Common domain classes have a fixed structure and are defined in modules. This means you cannot simply add any additional properties to the existing domain types without direct code modification. In order to fix this, you can extend an entity class and add properties to the subclass. Let\u2019s see how the domain model extension works by extending the CustomerOrder type defined in the Order Module , with new properties. Warning This approach does not work when a single domain entity type is to be extended from multiple modules. The extension domain model is based on class inheritance. Meanwhile, .NET does not support multiple class inheritance, so, as a result, only the last registered extension wins. Our first step is to define a new subclass, CustomerOrder2 , derived from the original CustomerOrder class. VirtoCommerce.OrdersModule2.Web/Model/CustomerOrder2.cs public class CustomerOrder2 : CustomerOrder { public CustomerOrder2 () { Invoices = new List < Invoice >(); } public string NewField { get ; set ; } public ICollection < Invoice > Invoices { get ; set ; } } Now, we need to register the newly defined CustomerOrder2 type in AbstractFactory<> to tell the system that CustomerOrder2 is now overriding (replacing) the original CustomerOrder class and will be used everywhere instead of it. VirtoCommerce.OrdersModule2.Web/Module.cs public class Module : IModule { public void PostInitialize ( IApplicationBuilder appBuilder ) { ... AbstractTypeFactory < CustomerOrder >. OverrideType < CustomerOrder , CustomerOrder2 >() . WithFactory (() => new CustomerOrder2 { OperationType = \"CustomerOrder\" }); //need to preserve original order discriminator value ... } } Info AbstractTypeFactory<> is the key element of Virto's extension concept that is responsible for activating a particular type of instance based on the internal type mapping table. Each piece of code that should support domain type extensions must use AbstractTypeFactory<BaseType>.TryCreateInstance() instead of the new BaseType() statement. When you need to override any base type with another derived type, you must call AbstractTypeFactory<BaseType>.OverrideType<BaseType, DerivedType>() ; each call of AbstractTypeFactory< BaseType>.TryCreateInstance() will return your DerivedType object instance instead of BaseType . This is how the type extension magic works. Persistent Layer Extension Schema We just extended the existing CustomerOrder class with a new CustomerOrder2 class housing new properties. The questions now is: how can you actually change the current DB schema and persist these new types into the database through Entity Framework (EF) Core? To solve this task, we can also use the inheritance techniques and define and derive new Order2DbContext from original OrderDbContext , along with OrderRepository2 derived from OrderRepository . VirtoCommerce.OrdersModule2.Web/Repositories/Order2DbContext.cs //Derive custom DB context from the OrderDbContext public class Order2DbContext : OrderDbContext { public Order2DbContext ( DbContextOptions < Order2DbContext > builderOptions ) : base ( builderOptions ) { } protected override void OnModelCreating ( ModelBuilder modelBuilder ) { //the method code } } VirtoCommerce.OrdersModule2.Web/Repositories/OrderRepository2.cs public class OrderRepository2 : OrderRepository { public OrderRepository2 ( Order2DbContext dbContext , IUnitOfWork unitOfWork = null ) : base ( dbContext , unitOfWork ) { } } In Virto, for persistence logic we use the Data Mapper pattern, which helps to completely isolate your domain from the persistence layer. Leveraging this pattern gives one more benefits with keeping domain contracts in a more stable state. It also enables changing the persistence schema without affecting the domain used for public contracts. Each domain type has its own representation in the database, namely dedicated DataEntitity classes that are defined in EF Core's DbContext through fluent syntax.Such classes have three methods: ToModel and FromModel , which map domain type objects to persistent ones, and vice versa; Patch , which applies changes to the specified columns only. This method is crucial for implementing partial update logic. Now let\u2019s define the new persistence CustomerOrder2Entity type that will represent the persistence schema model of the new CustomerOrder2 class: VirtoCommerce.OrdersModule2.Web/Model/CustomerOrder2Entity.cs public class CustomerOrder2Entity : CustomerOrderEntity { public override OrderOperation ToModel ( OrderOperation operation ) { //the method code } public override OperationEntity FromModel ( OrderOperation operation , PrimaryKeyResolvingMap pkMap ) { //the method code } } At the next stage, we need to generate new DB migration for our newly extended Order2DbContext . We can do that by running the following command within the Nuget package version console in Visual Studio : Add-Migration InitialOrder2 -Context VirtoCommerce.OrdersModule2.Web.Repositories. Order2DbContext -Verbose -OutputDir Migrations -Project VirtoCommerce.OrdersModule2.Web -StartupProject VirtoCommerce.OrdersModule2.Web -Debug Running this command will yield the Migrations/XXXXXX_InitialOrder2.cs file containing the original (extendable) order module DB schema along with a new one. Thus, you will have to manually edit the resulting InitialOrder2.cs file leaving only those DB schema changes that are relevant to your extension. VirtoCommerce.OrdersModule2.Web/Migrations/20200324130250_InitialOrders2.cs public partial class InitialOrders2 : Migration { protected override void Up ( MigrationBuilder migrationBuilder ) { //the method code } } Tip To avoid editing the resulting migration file, which may be time consuming and tricky, we recommend you first creating an empty initial migration file for the derived DbContext class with no changes. Then, you can just clean up the resulting migration .cs file and leave the Up and Down methods empty. This will allow you to make changes to the custom 'derived' DbContext and generate a new migration file containing only your custom changes. Finally, the last step is to register our derived OrderRepository2 and Order2DbContext in a DI container. By registering the new OrderRepository2 in DI, we override the base OrderRepository defined in CustomerOrder.Module : VirtoCommerce.OrdersModule2.Web/Module.cs public class Module : IModule { public void Initialize ( IServiceCollection serviceCollection ) { var snapshot = serviceCollection . BuildServiceProvider (); var configuration = snapshot . GetService < IConfiguration >(); serviceCollection . AddDbContext < Order2DbContext >( options => options . UseSqlServer ( configuration . GetConnectionString ( \"VirtoCommerce\" ))); serviceCollection . AddTransient < IOrderRepository , OrderRepository2 >(); } } It is also important to register our new persistent schema representation, CustomerOrder2Entity , in AbstractTypeFactory<> and override the base CustomerOrderEntity with new type: VirtoCommerce.OrdersModule2.Web/Module.cs public class Module : IModule { public void PostInitialize ( IApplicationBuilder appBuilder ) { ... AbstractTypeFactory < IOperation >. OverrideType < CustomerOrder , CustomerOrder2 >(); AbstractTypeFactory < CustomerOrderEntity >. OverrideType < CustomerOrderEntity , CustomerOrder2Entity >(); ... } } How API Understands and Deserializes Derived Domain Types Up to now, we talked about extending domain types and persistent layers. In some cases, however, this is not enough. This is especially true when your domain types are used as DTOs (Data Transfer Objects) in public API contracts and can be leveraged as a result or parameter in the API endpoints. Basically, you may need to instantiate the right instance of an 'efficient' type from the incoming JSON data, which is called deserialization. There are two ways to force ASP.NET Core API JSON serializer to understand our domain extensions: Use platform-defined PolymorphJsonConverter , which is preferable in most cases. PolymorphJsonConverter transparently deserializes extended domain types with no developer effort. Transfer custom JSON converter to MvcNewtonsoftJsonOptions . Consider using it only in case PolymorphJsonConverter is not suitable for your specific case.","title":"Extending Domain Models"},{"location":"Tutorials-and-How-tos/Tutorials/extending-domain-models/#extending-domain-models","text":"VirtoCommerce supports extension of managed code domain types. This article will show you how to use various techniques to extend an existing domain type without direct code modification. To view or download our sample code, click here .","title":"Extending Domain Models"},{"location":"Tutorials-and-How-tos/Tutorials/extending-domain-models/#extending-through-type-inheritance","text":"Common domain classes have a fixed structure and are defined in modules. This means you cannot simply add any additional properties to the existing domain types without direct code modification. In order to fix this, you can extend an entity class and add properties to the subclass. Let\u2019s see how the domain model extension works by extending the CustomerOrder type defined in the Order Module , with new properties. Warning This approach does not work when a single domain entity type is to be extended from multiple modules. The extension domain model is based on class inheritance. Meanwhile, .NET does not support multiple class inheritance, so, as a result, only the last registered extension wins. Our first step is to define a new subclass, CustomerOrder2 , derived from the original CustomerOrder class. VirtoCommerce.OrdersModule2.Web/Model/CustomerOrder2.cs public class CustomerOrder2 : CustomerOrder { public CustomerOrder2 () { Invoices = new List < Invoice >(); } public string NewField { get ; set ; } public ICollection < Invoice > Invoices { get ; set ; } } Now, we need to register the newly defined CustomerOrder2 type in AbstractFactory<> to tell the system that CustomerOrder2 is now overriding (replacing) the original CustomerOrder class and will be used everywhere instead of it. VirtoCommerce.OrdersModule2.Web/Module.cs public class Module : IModule { public void PostInitialize ( IApplicationBuilder appBuilder ) { ... AbstractTypeFactory < CustomerOrder >. OverrideType < CustomerOrder , CustomerOrder2 >() . WithFactory (() => new CustomerOrder2 { OperationType = \"CustomerOrder\" }); //need to preserve original order discriminator value ... } } Info AbstractTypeFactory<> is the key element of Virto's extension concept that is responsible for activating a particular type of instance based on the internal type mapping table. Each piece of code that should support domain type extensions must use AbstractTypeFactory<BaseType>.TryCreateInstance() instead of the new BaseType() statement. When you need to override any base type with another derived type, you must call AbstractTypeFactory<BaseType>.OverrideType<BaseType, DerivedType>() ; each call of AbstractTypeFactory< BaseType>.TryCreateInstance() will return your DerivedType object instance instead of BaseType . This is how the type extension magic works.","title":"Extending through Type Inheritance"},{"location":"Tutorials-and-How-tos/Tutorials/extending-domain-models/#persistent-layer-extension-schema","text":"We just extended the existing CustomerOrder class with a new CustomerOrder2 class housing new properties. The questions now is: how can you actually change the current DB schema and persist these new types into the database through Entity Framework (EF) Core? To solve this task, we can also use the inheritance techniques and define and derive new Order2DbContext from original OrderDbContext , along with OrderRepository2 derived from OrderRepository . VirtoCommerce.OrdersModule2.Web/Repositories/Order2DbContext.cs //Derive custom DB context from the OrderDbContext public class Order2DbContext : OrderDbContext { public Order2DbContext ( DbContextOptions < Order2DbContext > builderOptions ) : base ( builderOptions ) { } protected override void OnModelCreating ( ModelBuilder modelBuilder ) { //the method code } } VirtoCommerce.OrdersModule2.Web/Repositories/OrderRepository2.cs public class OrderRepository2 : OrderRepository { public OrderRepository2 ( Order2DbContext dbContext , IUnitOfWork unitOfWork = null ) : base ( dbContext , unitOfWork ) { } } In Virto, for persistence logic we use the Data Mapper pattern, which helps to completely isolate your domain from the persistence layer. Leveraging this pattern gives one more benefits with keeping domain contracts in a more stable state. It also enables changing the persistence schema without affecting the domain used for public contracts. Each domain type has its own representation in the database, namely dedicated DataEntitity classes that are defined in EF Core's DbContext through fluent syntax.Such classes have three methods: ToModel and FromModel , which map domain type objects to persistent ones, and vice versa; Patch , which applies changes to the specified columns only. This method is crucial for implementing partial update logic. Now let\u2019s define the new persistence CustomerOrder2Entity type that will represent the persistence schema model of the new CustomerOrder2 class: VirtoCommerce.OrdersModule2.Web/Model/CustomerOrder2Entity.cs public class CustomerOrder2Entity : CustomerOrderEntity { public override OrderOperation ToModel ( OrderOperation operation ) { //the method code } public override OperationEntity FromModel ( OrderOperation operation , PrimaryKeyResolvingMap pkMap ) { //the method code } } At the next stage, we need to generate new DB migration for our newly extended Order2DbContext . We can do that by running the following command within the Nuget package version console in Visual Studio : Add-Migration InitialOrder2 -Context VirtoCommerce.OrdersModule2.Web.Repositories. Order2DbContext -Verbose -OutputDir Migrations -Project VirtoCommerce.OrdersModule2.Web -StartupProject VirtoCommerce.OrdersModule2.Web -Debug Running this command will yield the Migrations/XXXXXX_InitialOrder2.cs file containing the original (extendable) order module DB schema along with a new one. Thus, you will have to manually edit the resulting InitialOrder2.cs file leaving only those DB schema changes that are relevant to your extension. VirtoCommerce.OrdersModule2.Web/Migrations/20200324130250_InitialOrders2.cs public partial class InitialOrders2 : Migration { protected override void Up ( MigrationBuilder migrationBuilder ) { //the method code } } Tip To avoid editing the resulting migration file, which may be time consuming and tricky, we recommend you first creating an empty initial migration file for the derived DbContext class with no changes. Then, you can just clean up the resulting migration .cs file and leave the Up and Down methods empty. This will allow you to make changes to the custom 'derived' DbContext and generate a new migration file containing only your custom changes. Finally, the last step is to register our derived OrderRepository2 and Order2DbContext in a DI container. By registering the new OrderRepository2 in DI, we override the base OrderRepository defined in CustomerOrder.Module : VirtoCommerce.OrdersModule2.Web/Module.cs public class Module : IModule { public void Initialize ( IServiceCollection serviceCollection ) { var snapshot = serviceCollection . BuildServiceProvider (); var configuration = snapshot . GetService < IConfiguration >(); serviceCollection . AddDbContext < Order2DbContext >( options => options . UseSqlServer ( configuration . GetConnectionString ( \"VirtoCommerce\" ))); serviceCollection . AddTransient < IOrderRepository , OrderRepository2 >(); } } It is also important to register our new persistent schema representation, CustomerOrder2Entity , in AbstractTypeFactory<> and override the base CustomerOrderEntity with new type: VirtoCommerce.OrdersModule2.Web/Module.cs public class Module : IModule { public void PostInitialize ( IApplicationBuilder appBuilder ) { ... AbstractTypeFactory < IOperation >. OverrideType < CustomerOrder , CustomerOrder2 >(); AbstractTypeFactory < CustomerOrderEntity >. OverrideType < CustomerOrderEntity , CustomerOrder2Entity >(); ... } }","title":"Persistent Layer Extension Schema"},{"location":"Tutorials-and-How-tos/Tutorials/extending-domain-models/#how-api-understands-and-deserializes-derived-domain-types","text":"Up to now, we talked about extending domain types and persistent layers. In some cases, however, this is not enough. This is especially true when your domain types are used as DTOs (Data Transfer Objects) in public API contracts and can be leveraged as a result or parameter in the API endpoints. Basically, you may need to instantiate the right instance of an 'efficient' type from the incoming JSON data, which is called deserialization. There are two ways to force ASP.NET Core API JSON serializer to understand our domain extensions: Use platform-defined PolymorphJsonConverter , which is preferable in most cases. PolymorphJsonConverter transparently deserializes extended domain types with no developer effort. Transfer custom JSON converter to MvcNewtonsoftJsonOptions . Consider using it only in case PolymorphJsonConverter is not suitable for your specific case.","title":"How API Understands and Deserializes Derived Domain Types"}]}